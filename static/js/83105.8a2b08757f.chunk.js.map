{"version":3,"file":"static/js/83105.8a2b08757f.chunk.js","mappings":"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","sources":["webpack://web/../../node_modules/@ckb-lumos/ckb-indexer/lib/ckbIndexerFilter.js","webpack://web/../../node_modules/@ckb-lumos/ckb-indexer/lib/collector.js","webpack://web/../../node_modules/@ckb-lumos/ckb-indexer/lib/index.js","webpack://web/../../node_modules/@ckb-lumos/ckb-indexer/lib/indexer.js","webpack://web/../../node_modules/@ckb-lumos/ckb-indexer/lib/paramsFormatter.js","webpack://web/../../node_modules/@ckb-lumos/ckb-indexer/lib/resultFormatter.js","webpack://web/../../node_modules/@ckb-lumos/ckb-indexer/lib/rpc.js","webpack://web/../../node_modules/@ckb-lumos/ckb-indexer/lib/services.js","webpack://web/../../node_modules/@ckb-lumos/ckb-indexer/lib/transaction_collector.js","webpack://web/../../node_modules/@ckb-lumos/ckb-indexer/lib/type.js","webpack://web/../../node_modules/@ckb-lumos/codec/lib/blockchain.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/lib/anyone_can_pay.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/lib/common.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/lib/dao.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/lib/deploy.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/lib/from_info.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/lib/helper.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/lib/index.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/lib/locktime_pool.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/lib/omnilock-bitcoin.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/lib/omnilock-solana.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/lib/omnilock.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/lib/p2pkh.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/lib/secp256k1_blake160.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/lib/secp256k1_blake160_multisig.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/lib/sudt.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/node_modules/base-x/src/index.js","webpack://web/../../node_modules/@ckb-lumos/common-scripts/node_modules/bs58/index.js","webpack://web/../../node_modules/@ckb-lumos/rpc/lib/Base/chain.js","webpack://web/../../node_modules/@ckb-lumos/rpc/lib/Base/experimental.js","webpack://web/../../node_modules/@ckb-lumos/rpc/lib/Base/index.js","webpack://web/../../node_modules/@ckb-lumos/rpc/lib/Base/indexer.js","webpack://web/../../node_modules/@ckb-lumos/rpc/lib/Base/net.js","webpack://web/../../node_modules/@ckb-lumos/rpc/lib/Base/pool.js","webpack://web/../../node_modules/@ckb-lumos/rpc/lib/Base/stats.js","webpack://web/../../node_modules/@ckb-lumos/rpc/lib/exceptions/ErrorCode.js","webpack://web/../../node_modules/@ckb-lumos/rpc/lib/exceptions/batch.js","webpack://web/../../node_modules/@ckb-lumos/rpc/lib/exceptions/formatter.js","webpack://web/../../node_modules/@ckb-lumos/rpc/lib/exceptions/index.js","webpack://web/../../node_modules/@ckb-lumos/rpc/lib/exceptions/rpc.js","webpack://web/../../node_modules/@ckb-lumos/rpc/lib/index.js","webpack://web/../../node_modules/@ckb-lumos/rpc/lib/method.js","webpack://web/../../node_modules/@ckb-lumos/rpc/lib/paramsFormatter.js","webpack://web/../../node_modules/@ckb-lumos/rpc/lib/resultFormatter.js","webpack://web/../../node_modules/abort-controller/browser.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertQueryOptionToLumosSearchKey = convertQueryOptionToLumosSearchKey;\nexports.filterByLumosQueryOptions = filterByLumosQueryOptions;\nexports.filterByLumosSearchKey = filterByLumosSearchKey;\nexports.instanceOfDataWithSearchMode = instanceOfDataWithSearchMode;\nexports.instanceOfScriptWrapper = instanceOfScriptWrapper;\nexports.unwrapScriptWrapper = exports.unwrapDataWrapper = void 0;\nvar _base = require(\"@ckb-lumos/base\");\nvar _codec = require(\"@ckb-lumos/codec\");\nvar _bi = require(\"@ckb-lumos/bi\");\n/**\n * @description the following fields are not supported:\n * 1. `fromBlock` pending cells don't have block number\n * 2. `toBlock` pending cells don't have block number\n * 3. `skip` not search key, shoule be implmented in cell collector\n * 4. `order` not search key, shoule be implmented in cell collector\n */\n\n/**\n * @description `blockRange` is not supported, because pending cells don't have block number\n */\n\nfunction convertQueryOptionToLumosSearchKey(queryOptions) {\n  let searchKeyLock;\n  let searchKeyType;\n  let searchKey;\n  const queryLock = queryOptions.lock;\n  const queryType = queryOptions.type;\n  if (queryLock) {\n    if (instanceOfScriptWrapper(queryLock)) {\n      searchKeyLock = queryLock.script;\n    } else {\n      searchKeyLock = queryLock;\n    }\n  }\n  if (queryType && queryType !== \"empty\") {\n    if (instanceOfScriptWrapper(queryType)) {\n      searchKeyType = queryType.script;\n    } else {\n      searchKeyType = queryType;\n    }\n  }\n  if (searchKeyLock) {\n    searchKey = {\n      script: searchKeyLock,\n      scriptType: \"lock\",\n      scriptSearchMode: instanceOfScriptWrapper(queryLock) ? queryLock.searchMode || \"prefix\" : \"prefix\",\n      filter: {}\n    };\n    searchKeyType && (searchKey.filter.script = searchKeyType);\n  } else if (searchKeyType) {\n    searchKey = {\n      script: searchKeyType,\n      scriptType: \"type\",\n      scriptSearchMode: instanceOfScriptWrapper(queryType) ? queryType.searchMode || \"prefix\" : \"prefix\",\n      filter: {}\n    };\n  } else {\n    throw new Error(\"query.lock and query.type can't be both empty\");\n  }\n  const {\n    outputDataLenRange,\n    outputCapacityRange,\n    scriptLenRange\n  } = queryOptions;\n  searchKey.filter.outputDataLenRange = outputDataLenRange;\n  searchKey.filter.outputCapacityRange = outputCapacityRange;\n  searchKey.filter.scriptLenRange = scriptLenRange;\n  if (queryType === \"empty\") {\n    searchKey.filter.scriptLenRange = [\"0x0\", \"0x1\"];\n  }\n  return searchKey;\n}\nfunction filterByLumosQueryOptions(cells, options) {\n  const searchKey = convertQueryOptionToLumosSearchKey(options);\n  let filteredCells = cells.filter(cell => filterByLumosSearchKey(cell, searchKey));\n  if (options.argsLen && options.argsLen !== \"any\" && options.argsLen !== -1) {\n    filteredCells = filteredCells.filter(cell => _codec.bytes.bytify(cell.cellOutput.lock.args).length === options.argsLen);\n  }\n  if (!!options.data && options.data !== \"any\") {\n    if (instanceOfDataWithSearchMode(options.data) && options.data.searchMode === \"exact\") {\n      const dataSearch = options.data;\n      filteredCells = filteredCells.filter(cell => _codec.bytes.equal(_codec.bytes.bytify(cell.data), _codec.bytes.bytify(dataSearch.data)));\n    } else if (instanceOfDataWithSearchMode(options.data) && options.data.searchMode === \"prefix\") {\n      const dataSearch = options.data;\n      filteredCells = filteredCells.filter(cell => {\n        const expectPrefix = _codec.bytes.bytify(dataSearch.data);\n        const actualPrefix = _codec.bytes.bytify(cell.data).slice(0, expectPrefix.length);\n        return _codec.bytes.equal(expectPrefix, actualPrefix);\n      });\n    } else {\n      filteredCells = filteredCells.filter(cell => {\n        const expectPrefix = _codec.bytes.bytify(options.data);\n        const actualPrefix = _codec.bytes.bytify(cell.data).slice(0, expectPrefix.length);\n        return _codec.bytes.equal(expectPrefix, actualPrefix);\n      });\n    }\n  }\n  return filteredCells;\n}\n\n/**\n * @internal\n */\nfunction filterByLumosSearchKey(cell, searchKey) {\n  const isExactMode = searchKey.scriptSearchMode === \"exact\";\n  const {\n    cellOutput\n  } = cell;\n  const {\n    scriptType,\n    script,\n    filter\n  } = searchKey;\n\n  // Search mode\n  if (isExactMode) {\n    if (scriptType === \"lock\") {\n      if (!_codec.bytes.equal(_base.blockchain.Script.pack(cellOutput.lock), _base.blockchain.Script.pack(script))) {\n        return false;\n      }\n    } else {\n      if (!cellOutput.type || !_codec.bytes.equal(_base.blockchain.Script.pack(cellOutput.type), _base.blockchain.Script.pack(script))) {\n        return false;\n      }\n    }\n    // Prefix mode\n  } else {\n    if (scriptType === \"lock\") {\n      if (!checkScriptWithPrefixMode(cellOutput.lock, script)) {\n        return false;\n      }\n    } else {\n      if (!checkScriptWithPrefixMode(cellOutput.type, script)) {\n        return false;\n      }\n    }\n  }\n\n  // the \"exact\" mode works only on \"SearchKey.script\",\n  // not on \"SearchKey.filter.script\"\n  // the \"SearchKey.filter.script\" is always in prefix mode\n  if (!filter) return true;\n  // filter type script if scriptType is \"lock\"\n  if (scriptType === \"lock\") {\n    if (filter.script && !checkScriptWithPrefixMode(cellOutput.type, filter.script)) {\n      return false;\n    }\n    if (filter.scriptLenRange && !checkScriptLenRange(cellOutput.type, filter.scriptLenRange)) {\n      return false;\n    }\n    // filter lock script if scriptType is \"type\"\n  } else {\n    if (filter.script && !checkScriptWithPrefixMode(cellOutput.lock, filter.script)) {\n      return false;\n    }\n    if (filter.scriptLenRange && !checkScriptLenRange(cellOutput.lock, filter.scriptLenRange)) {\n      return false;\n    }\n  }\n  const {\n    outputCapacityRange,\n    outputDataLenRange\n  } = filter;\n  if (outputCapacityRange) {\n    const capacity = _bi.BI.from(cellOutput.capacity);\n    const fromCapacity = _bi.BI.from(outputCapacityRange[0]);\n    const toCapacity = _bi.BI.from(outputCapacityRange[1]);\n    if (capacity.lt(fromCapacity) || capacity.gte(toCapacity)) {\n      return false;\n    }\n  }\n  if (outputDataLenRange) {\n    const dataLen = _bi.BI.from(_codec.bytes.bytify(cell.data).length);\n    const fromDataLen = _bi.BI.from(outputDataLenRange[0]);\n    const toDataLen = _bi.BI.from(outputDataLenRange[1]);\n    if (dataLen.lt(fromDataLen) || dataLen.gte(toDataLen)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction checkScriptWithPrefixMode(script, filterScript) {\n  if (!script) {\n    return false;\n  }\n\n  // codeHash should always be 32 bytes, so it only supports exact match mode\n  if (!_codec.bytes.equal(filterScript.codeHash, script.codeHash)) {\n    return false;\n  }\n  const expectArgsPrefix = _codec.bytes.bytify(filterScript.args);\n  const actualArgsPrefix = _codec.bytes.bytify(script.args).slice(0, expectArgsPrefix.length);\n  if (!_codec.bytes.equal(expectArgsPrefix, actualArgsPrefix)) {\n    return false;\n  }\n  if (script.hashType !== filterScript.hashType) {\n    return false;\n  }\n  return true;\n}\nfunction checkScriptLenRange(script, scriptLenRange) {\n  const scriptLen = script ? _bi.BI.from(_codec.bytes.concat(script.codeHash, script.args).length + 1 /* hashType length is 1 */) : _bi.BI.from(0);\n  const fromScriptLen = _bi.BI.from(scriptLenRange[0]);\n  const toScriptLen = _bi.BI.from(scriptLenRange[1]);\n  if (scriptLen.lt(fromScriptLen) || scriptLen.gte(toScriptLen)) {\n    return false;\n  }\n  return true;\n}\nfunction instanceOfScriptWrapper(object) {\n  return typeof object === \"object\" && object != null && \"script\" in object;\n}\nfunction instanceOfDataWithSearchMode(object) {\n  return typeof object === \"object\" && object != null && \"data\" in object;\n}\nconst unwrapScriptWrapper = inputScript => {\n  if (instanceOfScriptWrapper(inputScript)) {\n    return inputScript.script;\n  }\n  return inputScript;\n};\nexports.unwrapScriptWrapper = unwrapScriptWrapper;\nconst unwrapDataWrapper = input => {\n  if (instanceOfDataWithSearchMode(input)) {\n    return input.data;\n  }\n  return input;\n};\nexports.unwrapDataWrapper = unwrapDataWrapper;\n//# sourceMappingURL=ckbIndexerFilter.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CKBCellCollector = void 0;\nvar _base = require(\"@ckb-lumos/base\");\nvar _toolkit = require(\"@ckb-lumos/toolkit\");\nvar _services = require(\"./services\");\nvar _crossFetch = _interopRequireDefault(require(\"cross-fetch\"));\nvar _ckbIndexerFilter = require(\"./ckbIndexerFilter\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/** CellCollector will not get cell with blockHash by default, please use OtherQueryOptions.withBlockHash and OtherQueryOptions.CKBRpcUrl to get blockHash if you need. */\nclass CKBCellCollector {\n  constructor(terminableCellFetcher, queries, otherQueryOptions) {\n    this.terminableCellFetcher = terminableCellFetcher;\n    this.otherQueryOptions = otherQueryOptions;\n    const defaultQuery = {\n      lock: undefined,\n      type: undefined,\n      argsLen: -1,\n      data: \"any\",\n      fromBlock: undefined,\n      toBlock: undefined,\n      order: \"asc\",\n      skip: undefined,\n      outputDataLenRange: undefined,\n      outputCapacityRange: undefined,\n      bufferSize: undefined\n    };\n    this.queries = (Array.isArray(queries) ? queries : [queries]).map(query => ({\n      ...defaultQuery,\n      ...query\n    }));\n    this.queries.forEach(query => {\n      this.validateQueryOption(query);\n    });\n    this.convertQueryOptionToSearchKey();\n  }\n  validateQueryOption(queries) {\n    if (!queries.lock && (!queries.type || queries.type === \"empty\")) {\n      throw new Error(\"Either lock or type script must be provided!\");\n    }\n    if (queries.lock) {\n      if (!(0, _ckbIndexerFilter.instanceOfScriptWrapper)(queries.lock)) {\n        _toolkit.validators.ValidateScript(queries.lock);\n      } else if ((0, _ckbIndexerFilter.instanceOfScriptWrapper)(queries.lock)) {\n        _toolkit.validators.ValidateScript(queries.lock.script);\n      }\n    }\n    if (queries.type && queries.type !== \"empty\") {\n      if (typeof queries.type === \"object\" && !(0, _ckbIndexerFilter.instanceOfScriptWrapper)(queries.type)) {\n        _toolkit.validators.ValidateScript(queries.type);\n      } else if (typeof queries.type === \"object\" && (0, _ckbIndexerFilter.instanceOfScriptWrapper)(queries.type)) {\n        _toolkit.validators.ValidateScript(queries.type.script);\n      }\n    }\n    if (queries.fromBlock) {\n      _base.utils.assertHexadecimal(\"fromBlock\", queries.fromBlock);\n    }\n    if (queries.toBlock) {\n      _base.utils.assertHexadecimal(\"toBlock\", queries.toBlock);\n    }\n    if (queries.order !== \"asc\" && queries.order !== \"desc\") {\n      throw new Error(\"Order must be either asc or desc!\");\n    }\n    if (queries.outputCapacityRange) {\n      _base.utils.assertHexadecimal(\"outputCapacityRange[0]\", queries.outputCapacityRange[0]);\n      _base.utils.assertHexadecimal(\"outputCapacityRange[1]\", queries.outputCapacityRange[1]);\n    }\n    if (queries.outputDataLenRange) {\n      _base.utils.assertHexadecimal(\"outputDataLenRange[0]\", queries.outputDataLenRange[0]);\n      _base.utils.assertHexadecimal(\"outputDataLenRange[1]\", queries.outputDataLenRange[1]);\n    }\n    if (queries.scriptLenRange) {\n      _base.utils.assertHexadecimal(\"scriptLenRange[0]\", queries.scriptLenRange[0]);\n      _base.utils.assertHexadecimal(\"scriptLenRange[1]\", queries.scriptLenRange[1]);\n    }\n    if (queries.outputDataLenRange && queries.data && queries.data !== \"any\") {\n      const dataLen = (0, _services.getHexStringBytes)((0, _ckbIndexerFilter.unwrapDataWrapper)(queries.data));\n      if (dataLen < Number(queries.outputDataLenRange[0]) || dataLen >= Number(queries.outputDataLenRange[1])) {\n        throw new Error(\"data length not match outputDataLenRange\");\n      }\n    }\n    if (queries.skip && typeof queries.skip !== \"number\") {\n      throw new Error(\"skip must be a number!\");\n    }\n    if (queries.bufferSize && typeof queries.bufferSize !== \"number\") {\n      throw new Error(\"bufferSize must be a number!\");\n    }\n  }\n  convertQueryOptionToSearchKey() {\n    this.queries.forEach(query => {\n      const queryLock = query.lock;\n      // unWrap `ScriptWrapper` into `Script`.\n      if (queryLock) {\n        if ((0, _ckbIndexerFilter.instanceOfScriptWrapper)(queryLock)) {\n          _toolkit.validators.ValidateScript(queryLock.script);\n          query.lock = queryLock.script;\n        }\n      }\n\n      // unWrap `ScriptWrapper` into `Script`.\n      if (query.type && query.type !== \"empty\") {\n        if (typeof query.type === \"object\" && (0, _ckbIndexerFilter.instanceOfScriptWrapper)(query.type)) {\n          _toolkit.validators.ValidateScript(query.type.script);\n          query.type = query.type.script;\n        }\n      }\n      if (!query.outputDataLenRange) {\n        if (query.data && query.data !== \"any\") {\n          const dataLenRange = (0, _services.getHexStringBytes)((0, _ckbIndexerFilter.unwrapDataWrapper)(query.data));\n          query.outputDataLenRange = [\"0x\" + dataLenRange.toString(16), \"0x\" + (dataLenRange + 1).toString(16)];\n        }\n      }\n      if (!query.scriptLenRange && query.type === \"empty\") {\n        query.scriptLenRange = [\"0x0\", \"0x1\"];\n      }\n    });\n  }\n  async getLiveCell(query, lastCursor) {\n    const searchKeyFilter = {\n      sizeLimit: query.bufferSize,\n      order: query.order,\n      lastCursor\n    };\n    const result = await this.terminableCellFetcher.getCells((0, _services.generateSearchKey)(query), undefined, searchKeyFilter);\n    return result;\n  }\n  async count() {\n    let counter = 0;\n    for await (const _cell of this.collect()) {\n      counter++;\n    }\n    return counter;\n  }\n\n  // eslint-disable-next-line\n  async request(rpcUrl, data) {\n    const res = await (0, _crossFetch.default)(rpcUrl, {\n      method: \"POST\",\n      body: JSON.stringify(data),\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n    if (res.status !== 200) {\n      throw new Error(`indexer request failed with HTTP code ${res.status}`);\n    }\n    const result = await res.json();\n    if (result.error !== undefined) {\n      throw new Error(`indexer request rpc failed with error: ${JSON.stringify(result.error)}`);\n    }\n    return result;\n  }\n  async getLiveCellWithBlockHash(query, lastCursor) {\n    if (!this.otherQueryOptions) {\n      throw new Error(\"CKB Rpc URL must provide\");\n    }\n    const result = await this.getLiveCell(query, lastCursor);\n    if (result.objects.length === 0) {\n      return result;\n    }\n    const requestData = result.objects.map((cell, index) => {\n      return {\n        id: index,\n        jsonrpc: \"2.0\",\n        method: \"get_block_hash\",\n        params: [cell.blockNumber]\n      };\n    });\n    const blockHashList = await this.request(this.otherQueryOptions.ckbRpcUrl, requestData);\n    result.objects = result.objects.map((item, index) => {\n      const rpcResponse = blockHashList.find(responseItem => responseItem.id === index);\n      const blockHash = rpcResponse && rpcResponse.result;\n      return {\n        ...item,\n        blockHash\n      };\n    });\n    return result;\n  }\n\n  /**\n   * collect cells without blockHash by default.if you need blockHash, please add OtherQueryOptions.withBlockHash and OtherQueryOptions.ckbRpcUrl when constructor CellCollect.\n   * don't use OtherQueryOption if you don't need blockHash,cause it will slowly your collect.\n   */\n  async *collect() {\n    const visitedCellKey = new Set();\n    for (const query of this.queries) {\n      for await (const cell of this.collectBySingleQuery(query)) {\n        var _cell$outPoint, _cell$outPoint2;\n        const key = `${(_cell$outPoint = cell.outPoint) === null || _cell$outPoint === void 0 ? void 0 : _cell$outPoint.txHash}-${(_cell$outPoint2 = cell.outPoint) === null || _cell$outPoint2 === void 0 ? void 0 : _cell$outPoint2.index}`;\n        if (visitedCellKey.has(key)) {\n          continue;\n        } else {\n          visitedCellKey.add(key);\n          yield cell;\n        }\n      }\n    }\n  }\n  async *collectBySingleQuery(query) {\n    //TODO: fix return type\n    const withBlockHash = this.otherQueryOptions && \"withBlockHash\" in this.otherQueryOptions && this.otherQueryOptions.withBlockHash;\n    let lastCursor = undefined;\n    const getCellWithCursor = async () => {\n      const result = await (withBlockHash ? this.getLiveCellWithBlockHash(query, lastCursor) : this.getLiveCell(query, lastCursor));\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n    let cells = await getCellWithCursor();\n    // filter cells by lumos query options\n    cells = (0, _ckbIndexerFilter.filterByLumosQueryOptions)(cells, query);\n    if (cells.length === 0) {\n      return;\n    }\n    let buffer = getCellWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (query.skip && skippedCount < query.skip) {\n        skippedCount++;\n      } else {\n        yield cells[index];\n      }\n      index++;\n      //reset index and exchange `cells` and `buffer` after yield last cell\n      if (index === cells.length) {\n        index = 0;\n        cells = await buffer;\n        // break if can not get more cells\n        if (cells.length === 0) {\n          break;\n        }\n        buffer = getCellWithCursor();\n      }\n    }\n  }\n}\nexports.CKBCellCollector = CKBCellCollector;\n//# sourceMappingURL=collector.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"CellCollector\", {\n  enumerable: true,\n  get: function () {\n    return _collector.CKBCellCollector;\n  }\n});\nObject.defineProperty(exports, \"Indexer\", {\n  enumerable: true,\n  get: function () {\n    return _indexer.CkbIndexer;\n  }\n});\nObject.defineProperty(exports, \"RPC\", {\n  enumerable: true,\n  get: function () {\n    return _rpc.RPC;\n  }\n});\nObject.defineProperty(exports, \"TerminableCellAdapter\", {\n  enumerable: true,\n  get: function () {\n    return _indexer.TerminableCellAdapter;\n  }\n});\nObject.defineProperty(exports, \"TransactionCollector\", {\n  enumerable: true,\n  get: function () {\n    return _transaction_collector.CKBIndexerTransactionCollector;\n  }\n});\nvar _collector = require(\"./collector\");\nvar _indexer = require(\"./indexer\");\nvar _transaction_collector = require(\"./transaction_collector\");\nvar _rpc = require(\"./rpc\");\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TerminableCellAdapter = exports.CkbIndexer = void 0;\nvar _base = require(\"@ckb-lumos/base\");\nvar _services = require(\"./services\");\nvar _collector = require(\"./collector\");\nvar _events = require(\"events\");\nvar _type = require(\"./type\");\nvar _bi = require(\"@ckb-lumos/bi\");\nvar _rpc = require(\"./rpc\");\nvar _rpc2 = require(\"@ckb-lumos/rpc\");\nvar _toolkit = require(\"@ckb-lumos/toolkit\");\nvar _ckbIndexerFilter = require(\"./ckbIndexerFilter\");\nconst DefaultTerminator = () => {\n  return {\n    stop: false,\n    push: true\n  };\n};\nfunction defaultLogger(level, message) {\n  console.log(`[${level}] ${message}`);\n}\n\n/** CkbIndexer.collector will not get cell with blockHash by default, please use OtherQueryOptions.withBlockHash and OtherQueryOptions.CKBRpcUrl to get blockHash if you need. */\nclass CkbIndexer {\n  static version = \"0.4.1\";\n  medianTimeEmitters = [];\n  emitters = [];\n  isSubscribeRunning = false;\n  constructor(ckbIndexerUrl, ckbRpcUrl) {\n    this.ckbIndexerUrl = ckbIndexerUrl;\n    this.ckbRpcUrl = ckbRpcUrl;\n    this.uri = ckbRpcUrl || ckbIndexerUrl;\n    this.ckbIndexerUri = ckbIndexerUrl;\n  }\n  getCkbRpc() {\n    return new _rpc2.CKBRPC(this.uri);\n  }\n\n  /* c8 ignore next 12 */\n  getIndexerRpc() {\n    if (this.uri === this.ckbIndexerUri) {\n      const rpc = this.getCkbRpc();\n      return {\n        ...rpc,\n        getTip: rpc.getIndexerTip\n      };\n    }\n    return new _rpc.RPC(this.ckbIndexerUri);\n  }\n  async tip() {\n    return await this.getIndexerRpc().getTip();\n  }\n  asyncSleep(timeout) {\n    return new Promise(resolve => setTimeout(resolve, timeout));\n  }\n  async waitForSync(blockDifference = 0) {\n    const rpcTipNumber = parseInt((await this.getCkbRpc().getTipHeader()).number, 16);\n    while (true) {\n      const indexerTipNumber = parseInt((await this.tip()).blockNumber, 16);\n      if (indexerTipNumber + blockDifference >= rpcTipNumber) {\n        return;\n      }\n      await this.asyncSleep(1000);\n    }\n  }\n\n  /** collector cells without blockHash by default.if you need blockHash, please add OtherQueryOptions.withBlockHash and OtherQueryOptions.ckbRpcUrl.\n   * don't use OtherQueryOption if you don't need blockHash,cause it will slowly your collect.\n   */\n  collector(queries, otherQueryOptions) {\n    return new _collector.CKBCellCollector(this, queries, otherQueryOptions);\n  }\n  async getCells(searchKey, terminator = DefaultTerminator, searchKeyFilter = {}) {\n    return new TerminableCellAdapter(this.getIndexerRpc()).getCells(searchKey, terminator, searchKeyFilter);\n  }\n  async getTransactions(searchKey, searchKeyFilter = {}) {\n    let infos = [];\n    let cursor = searchKeyFilter.lastCursor;\n    const sizeLimit = searchKeyFilter.sizeLimit || 100;\n    const order = searchKeyFilter.order || \"asc\";\n    while (true) {\n      const res = await this.getIndexerRpc().getTransactions(searchKey, order, `0x${sizeLimit.toString(16)}`, cursor);\n      const txs = res.objects;\n      cursor = res.lastCursor;\n      infos = infos.concat(txs);\n      if (txs.length <= sizeLimit) {\n        break;\n      }\n    }\n    return {\n      objects: infos,\n      lastCursor: cursor\n    };\n  }\n  running() {\n    return true;\n  }\n  start() {\n    defaultLogger(\"warn\", \"deprecated: no need to start the ckb-indexer manually\");\n  }\n  startForever() {\n    defaultLogger(\"warn\", \"deprecated: no need to startForever the ckb-indexer manually\");\n  }\n  stop() {\n    defaultLogger(\"warn\", \"deprecated: no need to stop the ckb-indexer manually\");\n  }\n  subscribe(queries) {\n    this.isSubscribeRunning = true;\n    this.scheduleLoop();\n    if (queries.lock && queries.type) {\n      throw new Error(\"The notification machanism only supports you subscribing for one script once so far!\");\n    }\n    if (queries.toBlock !== null || queries.skip !== null) {\n      defaultLogger(\"warn\", \"The passing fields such as toBlock and skip are ignored in subscribe() method.\");\n    }\n    const emitter = new _type.IndexerEmitter();\n    emitter.argsLen = queries.argsLen;\n    emitter.outputData = queries.data && (0, _ckbIndexerFilter.unwrapDataWrapper)(queries.data);\n    if (queries.fromBlock) {\n      _base.utils.assertHexadecimal(\"fromBlock\", queries.fromBlock);\n    }\n    emitter.fromBlock = !queries.fromBlock ? _bi.BI.from(0) : _bi.BI.from(queries.fromBlock);\n    if (queries.lock) {\n      _toolkit.validators.ValidateScript(queries.lock);\n      emitter.lock = queries.lock;\n    } else if (queries.type && queries.type !== \"empty\") {\n      _toolkit.validators.ValidateScript(queries.type);\n      emitter.type = queries.type;\n    } else {\n      throw new Error(\"Either lock or type script must be provided!\");\n    }\n    this.emitters.push(emitter);\n    return emitter;\n  }\n  loop() {\n    if (!this.isSubscribeRunning) {\n      return;\n    }\n    this.poll().then(timeout => {\n      this.scheduleLoop(timeout);\n    }).catch(e => {\n      defaultLogger(\"error\", `Error occurs: ${e} ${e.stack}, stopping indexer!`);\n      this.isSubscribeRunning = false;\n    });\n  }\n  scheduleLoop(timeout = 1) {\n    setTimeout(() => {\n      this.loop();\n    }, timeout);\n  }\n  async poll() {\n    let timeout = 1;\n    const tip = await this.tip();\n    const {\n      blockNumber,\n      blockHash\n    } = tip;\n    if (blockNumber === \"0x0\") {\n      const block = await this.getCkbRpc().getBlockByNumber(blockNumber);\n      await this.publishAppendBlockEvents(block);\n    }\n    const nextBlockNumber = _bi.BI.from(blockNumber).add(1);\n    const block = await this.getCkbRpc().getBlockByNumber(`0x${nextBlockNumber.toString(16)}`);\n    if (block) {\n      if (block.header.parentHash === blockHash) {\n        await this.publishAppendBlockEvents(block);\n      } else {\n        const block = await this.getCkbRpc().getBlockByNumber(blockNumber);\n        await this.publishAppendBlockEvents(block);\n      }\n    } else {\n      const block = await this.getCkbRpc().getBlockByNumber(blockNumber);\n      await this.publishAppendBlockEvents(block);\n      timeout = 3 * 1000;\n    }\n    return timeout;\n  }\n  async publishAppendBlockEvents(block) {\n    for (const [txIndex, tx] of block.transactions.entries()) {\n      const blockNumber = block.header.number;\n      // publish changed events if subscribed script exists in previous output cells , skip the cellbase.\n      if (txIndex > 0) {\n        const inputTxHashes = tx.inputs.map(input => input.previousOutput.txHash);\n\n        // batch request by block\n        const transactionResponse = await (0, _services.requestBatchTransactionWithStatus)(this.uri, inputTxHashes).then(response => {\n          return response.map((txWithStatus, index) => {\n            const cellIndex = tx.inputs[index].previousOutput.index;\n            const outputCell = txWithStatus.transaction.outputs[parseInt(cellIndex)];\n            const outputData = txWithStatus.transaction.outputsData[parseInt(cellIndex)];\n            return {\n              output: outputCell,\n              outputData\n            };\n          });\n        });\n        transactionResponse.forEach(({\n          output,\n          outputData\n        }) => {\n          this.filterEvents(output, blockNumber, outputData);\n        });\n      }\n      // publish changed events if subscribed script exists in output cells.\n      for (const [outputIndex, output] of tx.outputs.entries()) {\n        const outputData = tx.outputsData[outputIndex];\n        this.filterEvents(output, blockNumber, outputData);\n      }\n    }\n    await this.emitMedianTimeEvents();\n  }\n  filterEvents(output, blockNumber, outputData) {\n    for (const emitter of this.emitters) {\n      if (emitter.lock !== undefined && this.checkFilterOptions(emitter, blockNumber, outputData, emitter.lock, output.lock)) {\n        emitter.emit(\"changed\");\n      }\n    }\n    if (output.type !== null) {\n      for (const emitter of this.emitters) {\n        if (emitter.type !== undefined && this.checkFilterOptions(emitter, blockNumber, outputData, emitter.type, output.type)) {\n          emitter.emit(\"changed\");\n        }\n      }\n    }\n  }\n  checkFilterOptions(emitter, blockNumber, outputData, emitterScript, script) {\n    const checkBlockNumber = emitter.fromBlock ? _bi.BI.from(emitter.fromBlock).lte(blockNumber) : true;\n    const checkOutputData = emitter.outputData === \"any\" || !emitter.outputData ? true : emitter.outputData === outputData;\n    const checkScript = !script ? true : emitterScript.codeHash === script.codeHash && emitterScript.hashType === script.hashType && this.checkArgs(emitter.argsLen, emitterScript.args, script.args);\n    return checkBlockNumber && checkOutputData && checkScript;\n  }\n  checkArgs(argsLen, emitterArgs, args) {\n    if (argsLen === -1 || !argsLen && argsLen !== 0) {\n      return emitterArgs === args;\n    } else if (typeof argsLen === \"number\" && args.length === argsLen * 2 + 2) {\n      return args.substring(0, emitterArgs.length) === emitterArgs;\n    } else if (argsLen === \"any\") {\n      return args.substring(0, emitterArgs.length) === emitterArgs;\n    } else {\n      return false;\n    }\n  }\n  async emitMedianTimeEvents() {\n    if (this.medianTimeEmitters.length === 0) {\n      return;\n    }\n    const info = await this.getCkbRpc().getBlockchainInfo();\n    const medianTime = info.medianTime;\n    for (const medianTimeEmitter of this.medianTimeEmitters) {\n      medianTimeEmitter.emit(\"changed\", medianTime);\n    }\n  }\n  subscribeMedianTime() {\n    this.isSubscribeRunning = true;\n    this.scheduleLoop();\n    const medianTimeEmitter = new _events.EventEmitter();\n    this.medianTimeEmitters.push(medianTimeEmitter);\n    return medianTimeEmitter;\n  }\n}\nexports.CkbIndexer = CkbIndexer;\nclass TerminableCellAdapter {\n  constructor(getCellsableRpc) {\n    this.getCellsableRpc = getCellsableRpc;\n  }\n  async getCells(searchKey, terminator = DefaultTerminator, searchKeyFilter = {}) {\n    const infos = [];\n    let cursor = searchKeyFilter.lastCursor;\n    const sizeLimit = searchKeyFilter.sizeLimit || 100;\n    const order = searchKeyFilter.order || \"asc\";\n    const index = 0;\n    while (true) {\n      const res = await this.getCellsableRpc.getCells(searchKey, order, `0x${sizeLimit.toString(16)}`, cursor);\n      const liveCells = res.objects;\n      cursor = res.lastCursor;\n      for (const liveCell of liveCells) {\n        const cell = {\n          cellOutput: liveCell.output,\n          data: liveCell.outputData,\n          outPoint: liveCell.outPoint ? liveCell.outPoint : undefined,\n          blockNumber: liveCell.blockNumber\n        };\n        const {\n          stop,\n          push\n        } = terminator(index, cell);\n        if (push) {\n          infos.push(cell);\n        }\n        if (stop) {\n          return {\n            objects: infos,\n            lastCursor: cursor\n          };\n        }\n      }\n      if (liveCells.length <= sizeLimit) {\n        break;\n      }\n    }\n    return {\n      objects: infos,\n      lastCursor: cursor\n    };\n  }\n}\nexports.TerminableCellAdapter = TerminableCellAdapter;\n//# sourceMappingURL=indexer.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toSearchKey = exports.toSearchFilter = exports.toScript = exports.toGetTransactionsSearchKey = exports.toGetCellsSearchKey = void 0;\nconst toScript = data => ({\n  code_hash: data.codeHash,\n  hash_type: data.hashType,\n  args: data.args\n});\nexports.toScript = toScript;\nconst toSearchFilter = data => {\n  return {\n    script: data.script ? toScript(data.script) : data.script,\n    output_data_len_range: data.outputDataLenRange,\n    output_capacity_range: data.outputCapacityRange,\n    block_range: data.blockRange,\n    script_len_range: data.scriptLenRange\n  };\n};\nexports.toSearchFilter = toSearchFilter;\nconst toSearchKey = data => ({\n  script: toScript(data.script),\n  script_type: data.scriptType,\n  filter: data.filter ? toSearchFilter(data.filter) : data.filter,\n  script_search_mode: data.scriptSearchMode ? data.scriptSearchMode : \"prefix\"\n});\nexports.toSearchKey = toSearchKey;\nconst toGetCellsSearchKey = data => ({\n  ...toSearchKey(data),\n  with_data: data.withData\n});\nexports.toGetCellsSearchKey = toGetCellsSearchKey;\nconst toGetTransactionsSearchKey = data => ({\n  ...toSearchKey(data),\n  group_by_transaction: data.groupByTransaction\n});\nexports.toGetTransactionsSearchKey = toGetTransactionsSearchKey;\n//# sourceMappingURL=paramsFormatter.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toTip = exports.toSearchKey = exports.toSearchFilter = exports.toScript = exports.toOutPoint = exports.toCellOutPut = void 0;\nconst toTip = tip => ({\n  blockHash: tip.block_hash,\n  blockNumber: tip.block_number\n});\nexports.toTip = toTip;\nconst toScript = data => ({\n  codeHash: data.code_hash,\n  hashType: data.hash_type,\n  args: data.args\n});\nexports.toScript = toScript;\nconst toOutPoint = data => ({\n  txHash: data.tx_hash,\n  index: data.index\n});\nexports.toOutPoint = toOutPoint;\nconst toCellOutPut = data => ({\n  ...data,\n  lock: toScript(data.lock),\n  type: data.type ? toScript(data.type) : undefined\n});\nexports.toCellOutPut = toCellOutPut;\nconst toSearchFilter = data => {\n  return {\n    script: data.script ? toScript(data.script) : data.script,\n    outputDataLenRange: data.output_data_len_range,\n    outputCapacityRange: data.output_capacity_range,\n    scriptLenRange: data.script_len_range,\n    blockRange: data.block_range\n  };\n};\nexports.toSearchFilter = toSearchFilter;\nconst toSearchKey = data => ({\n  script: toScript(data.script),\n  scriptType: data.script_type,\n  filter: data.filter ? toSearchFilter(data.filter) : data.filter,\n  scriptSearchMode: data.script_search_mode\n});\nexports.toSearchKey = toSearchKey;\n//# sourceMappingURL=resultFormatter.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RPC = void 0;\nvar _base = require(\"@ckb-lumos/base\");\nvar _crossFetch = _interopRequireDefault(require(\"cross-fetch\"));\nvar _paramsFormatter = require(\"./paramsFormatter\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nclass RPC {\n  /**\n   *\n   * @param uri  indexer uri\n   */\n  constructor(uri) {\n    this.uri = uri;\n  }\n  async getTip() {\n    return _base.utils.deepCamel(await request(this.uri, \"get_tip\"));\n  }\n  async getCells(searchKey, order, limit, cursor) {\n    const params = [(0, _paramsFormatter.toGetCellsSearchKey)(searchKey), order, limit, cursor];\n    return _base.utils.deepCamel(await request(this.uri, \"get_cells\", params));\n  }\n  async getTransactions(searchKey, order, limit, cursor) {\n    const params = [(0, _paramsFormatter.toGetTransactionsSearchKey)(searchKey), order, limit, cursor];\n    return _base.utils.deepCamel(await request(this.uri, \"get_transactions\", params));\n  }\n  async getIndexerInfo() {\n    return _base.utils.deepCamel(await request(this.uri, \"get_indexer_info\"));\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */\nexports.RPC = RPC;\nconst request = async (ckbIndexerUrl, method, params) => {\n  const res = await (0, _crossFetch.default)(ckbIndexerUrl, {\n    method: \"POST\",\n    body: JSON.stringify({\n      id: 0,\n      jsonrpc: \"2.0\",\n      method,\n      params\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  });\n  if (res.status !== 200) {\n    throw new Error(`indexer request failed with HTTP code ${res.status}`);\n  }\n  const data = await res.json();\n  if (data.error !== undefined) {\n    throw new Error(`indexer request rpc failed with error: ${JSON.stringify(data.error)}`);\n  }\n  return data.result;\n};\n/* eslint-enalbe @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */\n//# sourceMappingURL=rpc.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getHexStringBytes = exports.generateSearchKey = void 0;\nexports.requestBatch = requestBatch;\nexports.requestBatchTransactionWithStatus = requestBatchTransactionWithStatus;\nvar _base = require(\"@ckb-lumos/base\");\nvar _crossFetch = _interopRequireDefault(require(\"cross-fetch\"));\nvar _bi = require(\"@ckb-lumos/bi\");\nvar _paramsFormatter = require(\"./paramsFormatter\");\nvar _resultFormatter = require(\"./resultFormatter\");\nvar _ckbIndexerFilter = require(\"./ckbIndexerFilter\");\nvar _rpc = require(\"@ckb-lumos/rpc\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nconst generateSearchKey = queries => {\n  let script = undefined;\n  const filter = {};\n  let script_type = undefined;\n  let script_search_mode = \"prefix\";\n  if (queries.lock) {\n    const lock = (0, _ckbIndexerFilter.unwrapScriptWrapper)(queries.lock);\n    script = (0, _paramsFormatter.toScript)(lock);\n    script_type = \"lock\";\n    if (queries.type && typeof queries.type !== \"string\") {\n      const type = (0, _ckbIndexerFilter.unwrapScriptWrapper)(queries.type);\n      filter.script = (0, _paramsFormatter.toScript)(type);\n    }\n  } else if (queries.type && typeof queries.type !== \"string\") {\n    const type = (0, _ckbIndexerFilter.unwrapScriptWrapper)(queries.type);\n    script = (0, _paramsFormatter.toScript)(type);\n    script_type = \"type\";\n  }\n  let block_range = null;\n  if (queries.fromBlock && queries.toBlock) {\n    //toBlock+1 cause toBlock need to be included\n    block_range = [queries.fromBlock, `0x${_bi.BI.from(queries.toBlock).add(1).toString(16)}`];\n  }\n  if (block_range) {\n    filter.block_range = block_range;\n  }\n  if (queries.outputDataLenRange) {\n    filter.output_data_len_range = queries.outputDataLenRange;\n  }\n  if (queries.outputCapacityRange) {\n    filter.output_capacity_range = queries.outputCapacityRange;\n  }\n  if (queries.scriptLenRange) {\n    filter.script_len_range = queries.scriptLenRange;\n  }\n  if (queries.scriptSearchMode) {\n    script_search_mode = queries.scriptSearchMode;\n  }\n  if (!script) {\n    throw new Error(\"Either lock or type script must be provided!\");\n  }\n  if (!script_type) {\n    throw new Error(\"script_type must be provided\");\n  }\n  return (0, _resultFormatter.toSearchKey)({\n    script,\n    script_type,\n    filter,\n    script_search_mode\n  });\n};\nexports.generateSearchKey = generateSearchKey;\nconst getHexStringBytes = hexString => {\n  _base.utils.assertHexString(\"\", hexString);\n  return Math.ceil(hexString.substr(2).length / 2);\n};\nexports.getHexStringBytes = getHexStringBytes;\nlet id = 0;\n// will be tested in e2e\n/* c8 ignore next 25 */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function requestBatch(rpcUrl,\n// eslint-disable-next-line\ndata) {\n  if (!data.length) {\n    return [];\n  }\n  const res = await (0, _crossFetch.default)(rpcUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(data.map(item => ({\n      id: id++,\n      ...item\n    })))\n  });\n  if (res.status !== 200) {\n    throw new Error(`Indexer request failed with HTTP code ${res.status}`);\n  }\n  const result = await res.json();\n  if (result.error !== undefined) {\n    throw new Error(`indexer request rpc failed with error: ${JSON.stringify(result.error)}`);\n  }\n  return result;\n}\n\n/* c8 ignore next 23 */\nasync function requestBatchTransactionWithStatus(rpcUrl, txHashes) {\n  if (txHashes.length === 0) {\n    return [];\n  }\n  const requestBody = txHashes.map((txHash, index) => {\n    return {\n      id: index,\n      jsonrpc: \"2.0\",\n      method: \"get_transaction\",\n      params: [txHash]\n    };\n  });\n  const res = await requestBatch(rpcUrl, requestBody);\n  return res.map(item => _rpc.ResultFormatter.toTransactionWithStatus(item.result));\n}\n//# sourceMappingURL=services.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CKBIndexerTransactionCollector = void 0;\nvar _base = require(\"@ckb-lumos/base\");\nvar _ckbIndexerFilter = require(\"./ckbIndexerFilter\");\nvar services = _interopRequireWildcard(require(\"./services\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nclass CKBIndexerTransactionCollector extends _base.indexer.TransactionCollector {\n  constructor(indexer, queries, CKBRpcUrl, options) {\n    super(indexer, queries, options);\n    this.indexer = indexer;\n    this.queries = queries;\n    this.CKBRpcUrl = CKBRpcUrl;\n    this.options = options;\n    const defaultOptions = {\n      skipMissing: false,\n      includeStatus: true\n    };\n    this.filterOptions = {\n      ...defaultOptions,\n      ...this.options\n    };\n  }\n\n  /**\n   * @deprecated\n   * @param CKBRpcUrl\n   */\n  static asBaseTransactionCollector(CKBRpcUrl) {\n    return class extends _base.indexer.TransactionCollector {\n      constructor(indexer, queries, options) {\n        super(indexer, queries, options);\n        return new CKBIndexerTransactionCollector(indexer, queries, CKBRpcUrl, options);\n      }\n    };\n  }\n  async fetchIndexerTransaction(queries, lastCursor) {\n    const searchKeyFilter = {\n      sizeLimit: queries.bufferSize,\n      order: queries.order\n    };\n    if (lastCursor) {\n      searchKeyFilter.lastCursor = lastCursor;\n    }\n    let indexerTransactionList = {\n      objects: [],\n      lastCursor: \"\"\n    };\n    /*\n     * if both lock and type exist,we need search them in independent and then get intersection\n     * cause ckb-indexer use searchKey script on each cell but native indexer use lock and type on transaction,\n     * and one transaction may have many cells both in input and output, more detail in test 'Test query transaction by both input lock and output type script'\n     */\n\n    //if both lock and type, search search them in independent and then get intersection, GetTransactionsResults.lastCursor change to `${lockLastCursor}-${typeLastCursor}`\n    if ((0, _ckbIndexerFilter.instanceOfScriptWrapper)(queries.lock) && (0, _ckbIndexerFilter.instanceOfScriptWrapper)(queries.type)) {\n      indexerTransactionList = await this.getTransactionByLockAndTypeIndependent(searchKeyFilter);\n      lastCursor = indexerTransactionList.lastCursor;\n    } else {\n      //query by ScriptWrapper.script,block_range,order\n      indexerTransactionList = await this.indexer.getTransactions(services.generateSearchKey(queries), searchKeyFilter);\n      lastCursor = indexerTransactionList.lastCursor;\n    }\n    // filter by ScriptWrapper.io_type\n    indexerTransactionList.objects = this.filterByTypeIoTypeAndLockIoType(indexerTransactionList.objects, queries);\n    return indexerTransactionList;\n  }\n  getResolvedTransactionRequestPayload(unresolvedTransactionList, indexerTransactionList) {\n    const requestPayload = [];\n    unresolvedTransactionList.forEach((unresolvedTransaction, index) => {\n      const indexerTransaction = indexerTransactionList.objects[index];\n      if (indexerTransaction.ioType === \"input\") {\n        const unresolvedOutPoint = unresolvedTransaction.transaction.inputs[Number(indexerTransaction.ioIndex)].previousOutput;\n        requestPayload.push(unresolvedOutPoint.txHash);\n      }\n    });\n    return requestPayload;\n  }\n  getResolvedCell(unresolvedTransaction, resolvedTransactionList, indexerTransaction) {\n    if (indexerTransaction.ioType !== \"input\") {\n      return unresolvedTransaction.transaction.outputs[Number(indexerTransaction.ioIndex)];\n    } else {\n      const unresolvedOutPoint = unresolvedTransaction.transaction.inputs[Number(indexerTransaction.ioIndex)].previousOutput;\n      const resolvedTransaction = resolvedTransactionList.find(tx => {\n        return tx.transaction.hash === unresolvedOutPoint.txHash;\n      });\n      if (!resolvedTransaction) {\n        throw new Error(`Impossible: can NOT find resolved transaction!`);\n      }\n      const resolvedCell = resolvedTransaction.transaction.outputs[Number(unresolvedOutPoint.index)];\n      return resolvedCell;\n    }\n  }\n\n  //filter by ScriptWrapper.argsLen\n  filterTransaction(unresolvedTransactionList, resolvedTransactionList, indexerTransactionList) {\n    const filteredTransactionList = unresolvedTransactionList.filter((unresolvedTransaction, index) => {\n      const resolvedCell = this.getResolvedCell(unresolvedTransaction, resolvedTransactionList, indexerTransactionList.objects[index]);\n      return this.isCellScriptArgsValid(resolvedCell);\n    });\n    const objects = filteredTransactionList.map(tx => ({\n      transaction: tx.transaction,\n      txStatus: tx.txStatus,\n      cycles: tx.cycles,\n      timeAddedToPool: tx.timeAddedToPool,\n      minReplaceFee: tx.minReplaceFee,\n      fee: tx.fee\n    }));\n    return objects;\n  }\n\n  /*\n   *lock?: ScriptWrapper.script query by ckb-indexer,ScriptWrapper.ioType filter after get transaction from indexer, ScriptWrapper.argsLen filter after get transaction from rpc;\n   *type?:  ScriptWrapper.script query by ckb-indexer,ScriptWrapper.ioType filter after get transaction from indexer, ScriptWrapper.argsLen filter after get transaction from rpc;\n   *data?: will not filter\n   *argsLen?: filter after get transaction detail;\n   *fromBlock?: query by ckb-indexer;\n   *toBlock?: query by ckb-indexer;\n   *skip?: filter after get transaction from ckb-indexer;;\n   *order?: query by ckb-indexer;\n   */\n  async getTransactions(lastCursor) {\n    const indexerTransactionList = await this.fetchIndexerTransaction(this.queries, lastCursor);\n    lastCursor = indexerTransactionList.lastCursor;\n\n    // return if transaction hash list if empty\n    if (indexerTransactionList.objects.length === 0) {\n      return {\n        objects: [],\n        lastCursor: lastCursor\n      };\n    }\n    const unresolvedTransactionList = await this.getTransactionListFromRpc(indexerTransactionList);\n    const requestPayload = this.getResolvedTransactionRequestPayload(unresolvedTransactionList, indexerTransactionList);\n    const resolvedTransactionList = await services.requestBatchTransactionWithStatus(this.CKBRpcUrl, requestPayload);\n    const objects = this.filterTransaction(unresolvedTransactionList, resolvedTransactionList, indexerTransactionList);\n    return {\n      objects: objects,\n      lastCursor: lastCursor\n    };\n  }\n  async getTransactionByLockAndTypeIndependent(searchKeyFilter) {\n    const queryWithTypeAdditionOptions = {\n      ...searchKeyFilter\n    };\n    const queryWithLockAdditionOptions = {\n      ...searchKeyFilter\n    };\n    if (searchKeyFilter.lastCursor) {\n      const [lockLastCursor, typeLastCursor] = searchKeyFilter.lastCursor.split(\"-\");\n      queryWithLockAdditionOptions.lastCursor = lockLastCursor;\n      queryWithTypeAdditionOptions.lastCursor = typeLastCursor;\n    }\n    const queriesWithoutType = {\n      ...this.queries,\n      type: undefined\n    };\n    const transactionByLock = await this.indexer.getTransactions(services.generateSearchKey(queriesWithoutType), queryWithTypeAdditionOptions);\n    const queriesWithoutLock = {\n      ...this.queries,\n      lock: undefined\n    };\n    const transactionByType = await this.indexer.getTransactions(services.generateSearchKey(queriesWithoutLock), queryWithLockAdditionOptions);\n    const intersection = (transactionList1, transactionList2) => {\n      const result = [];\n      transactionList1.forEach(tx1 => {\n        const tx2 = transactionList2.find(item => item.txHash === tx1.txHash);\n        if (tx2) {\n          // put the output io_type to intersection result, cause output have cells\n          const targetTx = tx1.ioType === \"output\" ? tx1 : tx2;\n          // change io_type to both cause targetTx exist both input and output\n          result.push({\n            ...targetTx,\n            ioType: \"both\"\n          });\n        }\n      });\n      return result;\n    };\n    const hashList = intersection(transactionByType.objects, transactionByLock.objects);\n    const lastCursor = transactionByLock.lastCursor + \"-\" + transactionByType.lastCursor;\n    const objects = hashList;\n    return {\n      objects,\n      lastCursor\n    };\n  }\n  getTransactionListFromRpc = async indexerTransactionList => {\n    const getDetailRequestData = indexerTransactionList.objects.map(hashItem => {\n      return hashItem.txHash;\n    });\n    const transactionList = await services.requestBatchTransactionWithStatus(this.CKBRpcUrl, getDetailRequestData).then(response => {\n      return response.map((item, index) => {\n        if (!this.filterOptions.skipMissing && !item.transaction) {\n          throw new Error(`Transaction ${indexerTransactionList.objects[index].txHash} is missing!`);\n        }\n        return item;\n      });\n    });\n    return transactionList;\n  };\n  isLockArgsLenMatched = (args, argsLen) => {\n    if (!argsLen) return true;\n    if (argsLen === \"any\") return true;\n    if (argsLen === -1) return true;\n    return services.getHexStringBytes(args) === argsLen;\n  };\n\n  // only valid after pass flow three validate\n  isCellScriptArgsValid = targetCell => {\n    if (this.queries.lock) {\n      const lockArgsLen = (0, _ckbIndexerFilter.instanceOfScriptWrapper)(this.queries.lock) ? this.queries.lock.argsLen : this.queries.argsLen;\n      if (!this.isLockArgsLenMatched(targetCell.lock.args, lockArgsLen)) {\n        return false;\n      }\n    }\n    if (this.queries.type && this.queries.type !== \"empty\") {\n      var _targetCell$type;\n      const typeArgsLen = (0, _ckbIndexerFilter.instanceOfScriptWrapper)(this.queries.type) ? this.queries.type.argsLen : this.queries.argsLen;\n      if (!this.isLockArgsLenMatched((_targetCell$type = targetCell.type) === null || _targetCell$type === void 0 ? void 0 : _targetCell$type.args, typeArgsLen)) {\n        return false;\n      }\n    }\n    if (this.queries.type && this.queries.type === \"empty\") {\n      if (targetCell.type) {\n        return false;\n      }\n    }\n    return true;\n  };\n  filterByIoType = (inputResult, ioType) => {\n    if (ioType === \"both\") {\n      return inputResult;\n    }\n    if (ioType === \"input\" || ioType === \"output\") {\n      return inputResult.filter(item => item.ioType === ioType || item.ioType === \"both\");\n    }\n    return inputResult;\n  };\n  filterByTypeIoTypeAndLockIoType = (inputResult, queries) => {\n    let result = inputResult;\n    if ((0, _ckbIndexerFilter.instanceOfScriptWrapper)(queries.lock) && queries.lock.ioType) {\n      result = this.filterByIoType(result, queries.lock.ioType);\n    }\n    if ((0, _ckbIndexerFilter.instanceOfScriptWrapper)(queries.type) && queries.type.ioType) {\n      result = this.filterByIoType(result, queries.type.ioType);\n    }\n    return result;\n  };\n  async count() {\n    let lastCursor = undefined;\n    const getTxWithCursor = async () => {\n      const result = await this.getTransactions(lastCursor);\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n    let counter = 0;\n    let txs = await getTxWithCursor();\n    if (txs.length === 0) {\n      return 0;\n    }\n    let buffer = getTxWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (this.queries.skip && skippedCount < this.queries.skip) {\n        skippedCount++;\n      } else {\n        counter += 1;\n      }\n      index++;\n      //reset index and exchange `txs` and `buffer` after count last tx\n      if (index === txs.length) {\n        index = 0;\n        txs = await buffer;\n        // break if can not get more txs\n        if (txs.length === 0) {\n          break;\n        }\n        buffer = getTxWithCursor();\n      }\n    }\n    return counter;\n  }\n  async getTransactionHashes() {\n    let lastCursor = undefined;\n    const getTxWithCursor = async () => {\n      const result = await this.getTransactions(lastCursor);\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n    const transactionHashes = [];\n    //skip query result in first query\n    let txs = await getTxWithCursor();\n    if (txs.length === 0) {\n      return [];\n    }\n    let buffer = getTxWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (this.queries.skip && skippedCount < this.queries.skip) {\n        skippedCount++;\n      } else {\n        if (txs[index].transaction.hash) {\n          transactionHashes.push(txs[index].transaction.hash);\n        }\n      }\n      index++;\n      //reset index and exchange `txs` and `buffer` after count last tx\n      if (index === txs.length) {\n        index = 0;\n        txs = await buffer;\n        // break if can not get more txs\n        if (txs.length === 0) {\n          break;\n        }\n        buffer = getTxWithCursor();\n      }\n    }\n    return transactionHashes;\n  }\n  async *collect() {\n    let lastCursor = undefined;\n    const getTxWithCursor = async () => {\n      const result = await this.getTransactions(lastCursor);\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n    //skip query result in first query\n    let txs = await getTxWithCursor();\n    if (txs.length === 0) {\n      return undefined;\n    }\n    let buffer = getTxWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (this.queries.skip && skippedCount < this.queries.skip) {\n        skippedCount++;\n      } else {\n        if (this.filterOptions.includeStatus) {\n          yield txs[index];\n        } else {\n          yield txs[index].transaction;\n        }\n      }\n      index++;\n      //reset index and exchange `txs` and `buffer` after count last tx\n      if (index === txs.length) {\n        index = 0;\n        txs = await buffer;\n        // break if can not get more txs\n        if (txs.length === 0) {\n          break;\n        }\n        buffer = getTxWithCursor();\n      }\n    }\n  }\n}\nexports.CKBIndexerTransactionCollector = CKBIndexerTransactionCollector;\n//# sourceMappingURL=transaction_collector.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexerEmitter = void 0;\nvar _events = require(\"events\");\nclass IndexerEmitter extends _events.EventEmitter {}\nexports.IndexerEmitter = IndexerEmitter;\n//# sourceMappingURL=type.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WitnessArgs = exports.BytesVec = exports.BytesOpt = exports.Bytes = exports.Byte32Vec = exports.Byte32 = void 0;\nexports.WitnessArgsOf = WitnessArgsOf;\nexports.createFixedHexBytesCodec = createFixedHexBytesCodec;\nvar _base = require(\"./base\");\nvar _bytes = require(\"./bytes\");\nvar _molecule = require(\"./molecule\");\nfunction createFixedHexBytesCodec(byteLength) {\n  return (0, _base.createFixedBytesCodec)({\n    byteLength,\n    pack: hex => (0, _bytes.bytify)(hex),\n    unpack: buf => (0, _bytes.hexify)(buf)\n  });\n}\n\n/**\n * placeholder codec, generally used as a placeholder\n * ```\n * // for example, when some BytesOpt is not used, it will be filled with this codec\n * // option BytesOpt (Bytes);\n * const UnusedBytesOpt = UnknownOpt\n * ```\n */\n// export const UnusedOpt = option(Unknown);\n\n// vector Bytes <byte>\nconst Bytes = exports.Bytes = (0, _molecule.byteVecOf)({\n  pack: _bytes.bytify,\n  unpack: _bytes.hexify\n});\nconst BytesOpt = exports.BytesOpt = (0, _molecule.option)(Bytes);\nconst BytesVec = exports.BytesVec = (0, _molecule.vector)(Bytes);\nconst Byte32 = exports.Byte32 = createFixedHexBytesCodec(32);\nconst Byte32Vec = exports.Byte32Vec = (0, _molecule.vector)(Byte32);\nfunction WitnessArgsOf(payload) {\n  return (0, _molecule.table)({\n    lock: (0, _molecule.option)((0, _molecule.byteVecOf)(payload.lock)),\n    input_type: (0, _molecule.option)((0, _molecule.byteVecOf)(payload.input_type)),\n    output_type: (0, _molecule.option)((0, _molecule.byteVecOf)(payload.output_type))\n  }, [\"lock\", \"input_type\", \"output_type\"]);\n}\nconst HexifyCodec = (0, _base.createBytesCodec)({\n  pack: _bytes.bytify,\n  unpack: _bytes.hexify\n});\n\n/**\n *\n * @example\n * ```ts\n * // secp256k1 lock witness\n * WitnessArgs.pack({ lock: '0x' + '00'.repeat(65) })\n * ```\n */\nconst WitnessArgs = exports.WitnessArgs = WitnessArgsOf({\n  lock: HexifyCodec,\n  input_type: HexifyCodec,\n  output_type: HexifyCodec\n});\n//# sourceMappingURL=blockchain.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CellCollector = void 0;\nexports.checkLimit = checkLimit;\nexports.default = void 0;\nexports.injectCapacity = injectCapacity;\nexports.prepareSigningEntries = prepareSigningEntries;\nexports.setupInputCell = setupInputCell;\nexports.setupOutputCell = setupOutputCell;\nexports.withdraw = withdraw;\nvar _base = require(\"@ckb-lumos/base\");\nvar _codec = require(\"@ckb-lumos/codec\");\nvar _configManager = require(\"@ckb-lumos/config-manager\");\nvar _helpers = require(\"@ckb-lumos/helpers\");\nvar _immutable = require(\"immutable\");\nvar _bi = require(\"@ckb-lumos/bi\");\nvar _from_info = require(\"./from_info\");\nvar _helper = require(\"./helper\");\nvar _sudt = require(\"./sudt\");\nconst {\n  ScriptValue\n} = _base.values;\nconst {\n  CKBHasher,\n  ckbHash\n} = _base.utils;\nconst CellCollector = exports.CellCollector = class CellCollector {\n  constructor(fromInfo, cellProvider, {\n    config = undefined,\n    queryOptions = {}\n  } = {}) {\n    if (!cellProvider) {\n      throw new Error(`Cell provider is missing!`);\n    }\n    config = config || (0, _configManager.getConfig)();\n    this.fromScript = (0, _from_info.parseFromInfo)(fromInfo, {\n      config\n    }).fromScript;\n    this.config = config;\n    queryOptions = {\n      ...queryOptions,\n      lock: this.fromScript,\n      type: queryOptions.type || \"empty\"\n    };\n    this.cellCollector = cellProvider.collector(queryOptions);\n  }\n  async *collect() {\n    if (!(0, _helper.isAcpScript)(this.fromScript, this.config)) {\n      return;\n    }\n    for await (const inputCell of this.cellCollector.collect()) {\n      yield inputCell;\n    }\n  }\n};\nasync function setupInputCell(txSkeleton, inputCell, _fromInfo, {\n  config = undefined,\n  defaultWitness = \"0x\",\n  since = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  const inputLock = inputCell.cellOutput.lock;\n  if (!(0, _helper.isAcpScript)(inputLock, config)) {\n    throw new Error(\"Not anyone-can-pay input!\");\n  }\n\n  // add inputCell to txSkeleton\n  txSkeleton = txSkeleton.update(\"inputs\", inputs => {\n    return inputs.push(inputCell);\n  });\n  if (since) {\n    txSkeleton = txSkeleton.update(\"inputSinces\", inputSinces => {\n      return inputSinces.set(txSkeleton.get(\"inputs\").size - 1, since);\n    });\n  }\n  txSkeleton = txSkeleton.update(\"witnesses\", witnesses => {\n    return witnesses.push(defaultWitness);\n  });\n  const outputCell = {\n    cellOutput: {\n      capacity: inputCell.cellOutput.capacity,\n      lock: inputCell.cellOutput.lock,\n      type: inputCell.cellOutput.type\n    },\n    data: inputCell.data\n  };\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.push(outputCell);\n  });\n  txSkeleton = txSkeleton.update(\"fixedEntries\", fixedEntries => {\n    return fixedEntries.push({\n      field: \"outputs\",\n      index: txSkeleton.get(\"outputs\").size - 1\n    });\n  });\n  const template = config.SCRIPTS.ANYONE_CAN_PAY;\n  if (!template) {\n    throw new Error(`ANYONE_CAN_PAY script not defined in config!`);\n  }\n  const scriptOutPoint = {\n    txHash: template.TX_HASH,\n    index: template.INDEX\n  };\n\n  // add cell_dep\n  txSkeleton = (0, _helper.addCellDep)(txSkeleton, {\n    outPoint: scriptOutPoint,\n    depType: template.DEP_TYPE\n  });\n\n  // add witness\n  const firstIndex = txSkeleton.get(\"inputs\").findIndex(input => {\n    return new ScriptValue(input.cellOutput.lock, {\n      validate: false\n    }).equals(new ScriptValue(inputLock, {\n      validate: false\n    }));\n  });\n  if (firstIndex !== -1) {\n    while (firstIndex >= txSkeleton.get(\"witnesses\").size) {\n      txSkeleton = txSkeleton.update(\"witnesses\", witnesses => {\n        return witnesses.push(\"0x\");\n      });\n    }\n    let witness = txSkeleton.get(\"witnesses\").get(firstIndex);\n    const newWitnessArgs = {\n      /* 65-byte zeros in hex */\n      lock: _helper.SECP_SIGNATURE_PLACEHOLDER\n    };\n    if (witness !== \"0x\") {\n      const witnessArgs = _base.blockchain.WitnessArgs.unpack(_codec.bytes.bytify(witness));\n      const lock = witnessArgs.lock;\n      if (!!lock && !!newWitnessArgs.lock && !_codec.bytes.equal(lock, newWitnessArgs.lock)) {\n        throw new Error(\"Lock field in first witness is set aside for signature!\");\n      }\n      const inputType = witnessArgs.inputType;\n      if (inputType) {\n        newWitnessArgs.inputType = inputType;\n      }\n      const outputType = witnessArgs.outputType;\n      if (outputType) {\n        newWitnessArgs.outputType = outputType;\n      }\n    }\n    witness = _codec.bytes.hexify(_base.blockchain.WitnessArgs.pack(newWitnessArgs));\n    txSkeleton = txSkeleton.update(\"witnesses\", witnesses => {\n      return witnesses.set(firstIndex, witness);\n    });\n  }\n  return txSkeleton;\n}\n\n// export for tests\nfunction checkLimit(acpArgs, capacity) {\n  const _capacity = _bi.BI.from(capacity);\n  let minimalAmount;\n  let minimalCapacity;\n  if (acpArgs.length >= 46) {\n    minimalAmount = _bi.BI.from(10).pow(\"0x\" + acpArgs.slice(44, 46));\n  }\n  if (acpArgs.length >= 44) {\n    // should convert to shannons\n    const multiplier = _bi.BI.from(10).pow(\"0x\" + acpArgs.slice(42, 44));\n    const multiplicand = _bi.BI.from(10).pow(8);\n    minimalCapacity = multiplier.mul(multiplicand);\n  }\n  // Both minimalAmount & minimalCapacity OR only minimalCapacity\n  if (minimalCapacity && minimalAmount) {\n    //check if undefined\n    if (_capacity.lt(minimalCapacity)) {\n      throw new Error(`capacity(${capacity}) less than toAddress minimal capacity limit(${minimalCapacity}), and amount less then toAddress minimal amount limit(${minimalAmount})! If you want to transfer sudt, maybe sudt.transfer can help you.`);\n    }\n  } else if (minimalCapacity) {\n    //check if undefined\n    if (_capacity.lt(minimalCapacity)) {\n      throw new Error(`capacity(${capacity}) less than toAddress minimal capacity limit(${minimalCapacity})!`);\n    }\n  }\n}\nasync function setupOutputCell(txSkeleton, outputCell, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  const toScript = outputCell.cellOutput.lock;\n  const capacity = _bi.BI.from(outputCell.cellOutput.capacity);\n  checkLimit(toScript.args, capacity.toString());\n  const cellProvider = txSkeleton.get(\"cellProvider\");\n  if (!cellProvider) {\n    throw new Error(`Cell Provider is missing!`);\n  }\n  const toAddress = (0, _helpers.generateAddress)(toScript, {\n    config\n  });\n  const toAddressCellCollector = new CellCollector(toAddress, cellProvider, {\n    config\n  });\n  const toAddressInput = (await toAddressCellCollector.collect().next()).value;\n  let outputCapacity = capacity;\n  if (toAddressInput) {\n    outputCapacity = capacity.add(toAddressInput.cellOutput.capacity);\n    txSkeleton = txSkeleton.update(\"inputs\", inputs => {\n      return inputs.push(toAddressInput);\n    });\n    txSkeleton = txSkeleton.update(\"witnesses\", witnesses => {\n      return witnesses.push(\"0x\");\n    });\n  }\n  outputCell.cellOutput.capacity = \"0x\" + outputCapacity.toString(16);\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.push(outputCell);\n  });\n  if (toAddressInput) {\n    const template = config.SCRIPTS.ANYONE_CAN_PAY;\n    if (!template) {\n      throw new Error(`ANYONE_CAN_PAY script not defined in config!`);\n    }\n    const scriptOutPoint = {\n      txHash: template.TX_HASH,\n      index: template.INDEX\n    };\n\n    // add cell_dep\n    txSkeleton = (0, _helper.addCellDep)(txSkeleton, {\n      outPoint: scriptOutPoint,\n      depType: template.DEP_TYPE\n    });\n  }\n  return txSkeleton;\n}\nasync function injectCapacity(cellCollector, txSkeleton, outputIndex, capacity, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  if (outputIndex >= txSkeleton.get(\"outputs\").size) {\n    throw new Error(`Invalid output index!`);\n  }\n  let _capacity = _bi.BI.from(capacity);\n  const template = config.SCRIPTS.ANYONE_CAN_PAY;\n  if (!template) {\n    throw new Error(`Provided config does not have ANYONE_CAN_PAY script setup!`);\n  }\n  const fromScript = cellCollector.fromScript;\n\n  /*\n   * First, check if there is any output cells that contains enough capacity\n   * for us to tinker with.\n   *\n   * TODO: the solution right now won't cover all cases, some outputs before the\n   * last output might still be tinkerable, right now we are working on the\n   * simple solution, later we can change this for more optimizations.\n   */\n  const lastFreezedOutput = txSkeleton.get(\"fixedEntries\").filter(({\n    field\n  }) => field === \"outputs\").maxBy(({\n    index\n  }) => index);\n  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;\n  for (; i < txSkeleton.get(\"outputs\").size && _capacity.gt(0); i++) {\n    const output = txSkeleton.get(\"outputs\").get(i);\n    if (new ScriptValue(output.cellOutput.lock, {\n      validate: false\n    }).equals(new ScriptValue(fromScript, {\n      validate: false\n    }))) {\n      const cellCapacity = _bi.BI.from(output.cellOutput.capacity);\n      const availableCapacity = cellCapacity.sub((0, _helpers.minimalCellCapacityCompatible)(output));\n      // should maintain minimal cell capcity in anyone-can-pay output\n      const deductCapacity = _capacity.gte(availableCapacity) ? availableCapacity : _capacity;\n      _capacity = _capacity.sub(deductCapacity);\n      output.cellOutput.capacity = \"0x\" + cellCapacity.sub(deductCapacity).toString(16);\n    }\n  }\n  // Remove all output cells with capacity equal to 0\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.filter(output => !_bi.BI.from(output.cellOutput.capacity).eq(0));\n  });\n  const getInputKey = input => `${input.outPoint.txHash}_${input.outPoint.index}`;\n  if (_capacity.gt(0)) {\n    const changeCell = {\n      cellOutput: {\n        capacity: \"0x0\",\n        lock: fromScript,\n        type: undefined\n      },\n      data: \"0x\",\n      outPoint: undefined,\n      blockHash: undefined\n    };\n    let changeCapacity = _bi.BI.from(0);\n    const minimalChangeCapacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(changeCell));\n    let previousInputs = (0, _immutable.Set)();\n    for (const input of txSkeleton.get(\"inputs\")) {\n      previousInputs = previousInputs.add(getInputKey(input));\n    }\n\n    // Are all from same lock script and type script, so only need one change cell\n    for await (const inputCell of cellCollector.collect()) {\n      if (previousInputs.has(getInputKey(inputCell))) {\n        continue;\n      }\n      txSkeleton = await setupInputCell(txSkeleton, inputCell, undefined, {\n        config\n      });\n      const lastOutputIndex = txSkeleton.get(\"outputs\").size - 1;\n      txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n        return outputs.remove(lastOutputIndex);\n      });\n      const fixedEntryIndex = txSkeleton.get(\"fixedEntries\").findIndex(fixedEntry => {\n        return fixedEntry.field === \"outputs\" && fixedEntry.index === lastOutputIndex;\n      });\n      if (fixedEntryIndex >= 0) {\n        txSkeleton = txSkeleton.update(\"fixedEntries\", fixedEntries => {\n          return fixedEntries.remove(fixedEntryIndex);\n        });\n      }\n      const inputCapacity = _bi.BI.from(inputCell.cellOutput.capacity);\n      let deductCapacity = inputCapacity;\n      if (deductCapacity.gt(_capacity)) {\n        deductCapacity = _capacity;\n      }\n      _capacity = _capacity.sub(deductCapacity);\n      changeCapacity = changeCapacity.add(inputCapacity.sub(deductCapacity));\n      if (_capacity.eq(0) && changeCapacity.gte(minimalChangeCapacity)) {\n        break;\n      }\n      changeCell.cellOutput.capacity = \"0x\" + changeCapacity.toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n        return outputs.push(changeCell);\n      });\n    }\n    if (_capacity.gt(0) || changeCapacity < minimalChangeCapacity) {\n      throw new Error(`Not enough capacity in from address!`);\n    }\n    changeCell.cellOutput.capacity = \"0x\" + changeCapacity.toString(16);\n    txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n      return outputs.push(changeCell);\n    });\n  }\n  return txSkeleton;\n}\nfunction prepareSigningEntries(txSkeleton, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  const scriptType = \"ANYONE_CAN_PAY\";\n  const template = config.SCRIPTS[scriptType];\n  if (!template) {\n    throw new Error(`Provided config does not have ${scriptType} script setup!`);\n  }\n  let processedArgs = (0, _immutable.Set)();\n  const tx = (0, _helpers.createTransactionFromSkeleton)(txSkeleton);\n  const txHash = ckbHash(_base.blockchain.RawTransaction.pack(tx));\n  const inputs = txSkeleton.get(\"inputs\");\n  const witnesses = txSkeleton.get(\"witnesses\");\n  let signingEntries = txSkeleton.get(\"signingEntries\");\n  for (let i = 0; i < inputs.size; i++) {\n    const input = inputs.get(i);\n    if (template.CODE_HASH === input.cellOutput.lock.codeHash && template.HASH_TYPE === input.cellOutput.lock.hashType && !processedArgs.has(input.cellOutput.lock.args)) {\n      processedArgs = processedArgs.add(input.cellOutput.lock.args);\n\n      // skip if input sum capcity <= output sum capacity\n      // and input sum amount <= output sum amount\n      const outputs = txSkeleton.get(\"outputs\").filter(output => {\n        return new ScriptValue(output.cellOutput.lock, {\n          validate: false\n        }).equals(new ScriptValue(input.cellOutput.lock, {\n          validate: false\n        }));\n      });\n      const sumOfOutputCapacity = outputs.map(output => _bi.BI.from(output.cellOutput.capacity)).reduce((result, c) => result.add(c), _bi.BI.from(0));\n      const sumOfOutputAmount = outputs.filter(output => output.data !== \"0x\").map(output => (0, _sudt.unpackAmount)(output.data)).reduce((result, c) => result.add(c), _bi.BI.from(0));\n      const fInputs = inputs.filter(i => {\n        return new ScriptValue(i.cellOutput.lock, {\n          validate: false\n        }).equals(new ScriptValue(input.cellOutput.lock, {\n          validate: false\n        }));\n      });\n      const sumOfInputCapacity = fInputs.map(i => _bi.BI.from(i.cellOutput.capacity)).reduce((result, c) => result.add(c), _bi.BI.from(0));\n      const sumOfInputAmount = fInputs.filter(i => i.data !== \"0x\").map(i => _bi.BI.from((0, _sudt.unpackAmount)(i.data))).reduce((result, c) => result.add(c), _bi.BI.from(0));\n      if (sumOfInputCapacity.lte(sumOfOutputCapacity) && sumOfInputAmount.lte(sumOfOutputAmount)) {\n        continue;\n      }\n      const lockValue = new _base.values.ScriptValue(input.cellOutput.lock, {\n        validate: false\n      });\n      const hasher = new CKBHasher();\n      hasher.update(txHash);\n      if (i >= witnesses.size) {\n        throw new Error(`The first witness in the script group starting at input index ${i} does not exist, maybe some other part has invalidly tampered the transaction?`);\n      }\n      (0, _helper.hashWitness)(hasher, witnesses.get(i));\n      for (let j = i + 1; j < inputs.size && j < witnesses.size; j++) {\n        const otherInput = inputs.get(j);\n        if (lockValue.equals(new _base.values.ScriptValue(otherInput.cellOutput.lock, {\n          validate: false\n        }))) {\n          (0, _helper.hashWitness)(hasher, witnesses.get(j));\n        }\n      }\n      for (let j = inputs.size; j < witnesses.size; j++) {\n        (0, _helper.hashWitness)(hasher, witnesses.get(j));\n      }\n      const signingEntry = {\n        type: \"witness_args_lock\",\n        index: i,\n        message: hasher.digestHex()\n      };\n      signingEntries = signingEntries.push(signingEntry);\n    }\n  }\n  txSkeleton = txSkeleton.set(\"signingEntries\", signingEntries);\n  return txSkeleton;\n}\nasync function withdraw(txSkeleton, fromInput, toAddress, capacity, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n\n  // from input must be a anyone-can-pay script\n  if (!(0, _helper.isAcpScript)(fromInput.cellOutput.lock, config)) {\n    throw new Error(`fromInput is not a ANYONE_CAN_PAY cell!`);\n  }\n\n  // check capacity\n  const _capacity = _bi.BI.from(capacity);\n  const fromInputCapacity = _bi.BI.from(fromInput.cellOutput.capacity);\n  const inputMinimalCellCapacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(fromInput));\n  if (!(_capacity.gte(0) && _capacity.lte(fromInputCapacity.sub(inputMinimalCellCapacity)) || _capacity.eq(fromInputCapacity))) {\n    throw new Error(`capacity must be in [0, ${fromInputCapacity.sub(inputMinimalCellCapacity)}] or ${fromInputCapacity} !`);\n  }\n  const toScript = (0, _helpers.parseAddress)(toAddress, {\n    config\n  });\n  const targetOutput = {\n    cellOutput: {\n      capacity: \"0x\" + capacity.toString(16),\n      lock: toScript,\n      type: undefined\n    },\n    data: \"0x\",\n    outPoint: undefined,\n    blockHash: undefined\n  };\n  if ((0, _helper.isAcpScript)(toScript, config)) {\n    checkLimit(toScript.args, capacity);\n    const cellProvider = txSkeleton.get(\"cellProvider\");\n    if (!cellProvider) {\n      throw new Error(`Cell Provider is missing!`);\n    }\n    const toAddressCellCollector = new CellCollector(toAddress, cellProvider, {\n      config\n    });\n    const toAddressInput = (await toAddressCellCollector.collect().next()).value;\n    if (!toAddressInput) {\n      throw new Error(`toAddress ANYONE_CAN_PAY input not found!`);\n    }\n    const outputCapacity = _capacity.add(toAddressInput.cellOutput.capacity);\n    targetOutput.cellOutput.capacity = \"0x\" + outputCapacity.toString(16);\n    txSkeleton = txSkeleton.update(\"inputs\", inputs => {\n      return inputs.push(toAddressInput);\n    });\n    txSkeleton = txSkeleton.update(\"witnesses\", witnesses => {\n      return witnesses.push(\"0x\");\n    });\n  }\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.push(targetOutput);\n  });\n  txSkeleton = await setupInputCell(txSkeleton, fromInput, (0, _helpers.generateAddress)(fromInput.cellOutput.lock, {\n    config\n  }), {\n    config\n  });\n  // remove output and fixedEntry added by `setupInputCell`\n  const lastOutputIndex = txSkeleton.get(\"outputs\").size - 1;\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.remove(lastOutputIndex);\n  });\n  const fixedEntryIndex = txSkeleton.get(\"fixedEntries\").findIndex(fixedEntry => {\n    return fixedEntry.field === \"outputs\" && fixedEntry.index === lastOutputIndex;\n  });\n  if (fixedEntryIndex >= 0) {\n    txSkeleton = txSkeleton.update(\"fixedEntries\", fixedEntries => {\n      return fixedEntries.remove(fixedEntryIndex);\n    });\n  }\n  if (!_capacity.eq(fromInputCapacity)) {\n    txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n      return outputs.push({\n        cellOutput: {\n          capacity: \"0x\" + fromInputCapacity.sub(capacity).toString(16),\n          lock: fromInput.cellOutput.lock,\n          type: fromInput.cellOutput.type\n        },\n        data: fromInput.data\n      });\n    });\n  }\n  return txSkeleton;\n}\nvar _default = exports.default = {\n  CellCollector,\n  setupInputCell,\n  setupOutputCell,\n  injectCapacity,\n  prepareSigningEntries,\n  withdraw\n};\n//# sourceMappingURL=anyone_can_pay.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.injectCapacity = injectCapacity;\nexports.payFee = payFee;\nexports.payFeeByFeeRate = payFeeByFeeRate;\nexports.prepareSigningEntries = prepareSigningEntries;\nexports.registerCustomLockScriptInfos = registerCustomLockScriptInfos;\nexports.setupInputCell = setupInputCell;\nexports.transfer = transfer;\nvar _helpers = require(\"@ckb-lumos/helpers\");\nvar _secp256k1_blake160_multisig = _interopRequireDefault(require(\"./secp256k1_blake160_multisig\"));\nvar _from_info = require(\"./from_info\");\nvar _secp256k1_blake = _interopRequireDefault(require(\"./secp256k1_blake160\"));\nvar _configManager = require(\"@ckb-lumos/config-manager\");\nvar _locktime_pool = _interopRequireWildcard(require(\"./locktime_pool\"));\nvar _base = require(\"@ckb-lumos/base\");\nvar _anyone_can_pay = _interopRequireDefault(require(\"./anyone_can_pay\"));\nvar _immutable = require(\"immutable\");\nvar _helper = require(\"./helper\");\nvar _bi = require(\"@ckb-lumos/bi\");\nvar _omnilock = _interopRequireDefault(require(\"./omnilock\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nconst {\n  ScriptValue\n} = _base.values;\nfunction defaultLogger(level, message) {\n  console.log(`[${level}] ${message}`);\n}\n\n/**\n * LockScriptInfo describes how to integrate a lock script in transaction building.\n *\n * Custom lock scripts must register their LockScriptInfo before using\n * `transfer`, `injectCapacity`, `payFee`, `payFeeByFeeRate` via\n * `registerCustomLockScriptInfos`.\n *\n * See an example in\n * [custom_lock_script_info.ts](https://github.com/ckb-js/lumos/blob/develop/packages/common-scripts/examples/custom_lock_script_info/custom_lock_script_info.ts).\n */\n\n/**\n * `infos` includes predefined and customized.\n */\nconst lockScriptInfos = {\n  configHashCode: 0,\n  _predefinedInfos: [],\n  _customInfos: [],\n  get infos() {\n    return [...this._predefinedInfos, ...this._customInfos];\n  }\n};\nfunction resetLockScriptInfos() {\n  lockScriptInfos.configHashCode = 0;\n  lockScriptInfos._predefinedInfos = [];\n  lockScriptInfos._customInfos = [];\n}\nfunction getLockScriptInfos() {\n  return lockScriptInfos;\n}\n\n/** Registers LockScriptInfo for custom scripts. */\nfunction registerCustomLockScriptInfos(infos) {\n  lockScriptInfos._customInfos = infos;\n}\nfunction generateLockScriptInfos({\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n\n  // lazy load\n  const getPredefinedInfos = () => {\n    var _config, _config2, _config3, _config4;\n    const secpTemplate = (_config = config) === null || _config === void 0 ? void 0 : _config.SCRIPTS.SECP256K1_BLAKE160;\n    const multisigTemplate = (_config2 = config) === null || _config2 === void 0 ? void 0 : _config2.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;\n    const acpTemplate = (_config3 = config) === null || _config3 === void 0 ? void 0 : _config3.SCRIPTS.ANYONE_CAN_PAY;\n    const omnilockTemplate = (_config4 = config) === null || _config4 === void 0 ? void 0 : _config4.SCRIPTS.OMNILOCK;\n    const predefinedInfos = [];\n    if (secpTemplate) {\n      predefinedInfos.push({\n        codeHash: secpTemplate.CODE_HASH,\n        hashType: secpTemplate.HASH_TYPE,\n        lockScriptInfo: _secp256k1_blake.default\n      });\n    } else {\n      defaultLogger(\"warn\", \"SECP256K1_BLAKE160 script info not found in config!\");\n    }\n    if (multisigTemplate) {\n      predefinedInfos.push({\n        codeHash: multisigTemplate.CODE_HASH,\n        hashType: multisigTemplate.HASH_TYPE,\n        lockScriptInfo: _secp256k1_blake160_multisig.default\n      });\n    } else {\n      defaultLogger(\"warn\", \"SECP256K1_BLAKE160_MULTISIG script info not found in config!\");\n    }\n    if (acpTemplate) {\n      predefinedInfos.push({\n        codeHash: acpTemplate.CODE_HASH,\n        hashType: acpTemplate.HASH_TYPE,\n        lockScriptInfo: _anyone_can_pay.default\n      });\n    } else {\n      defaultLogger(\"warn\", \"ANYONE_CAN_PAY script info not found in config!\");\n    }\n    if (omnilockTemplate) {\n      predefinedInfos.push({\n        codeHash: omnilockTemplate.CODE_HASH,\n        hashType: omnilockTemplate.HASH_TYPE,\n        lockScriptInfo: _omnilock.default\n      });\n    } else {\n      defaultLogger(\"warn\", \"OMNILOCK script info not found in config!\");\n    }\n    return predefinedInfos;\n  };\n  const configHashCode = _base.utils.hashCode(Buffer.from(JSON.stringify(config)));\n  if (lockScriptInfos.infos.length === 0) {\n    lockScriptInfos._predefinedInfos = getPredefinedInfos();\n    lockScriptInfos.configHashCode = configHashCode;\n  } else {\n    if (configHashCode !== lockScriptInfos.configHashCode) {\n      defaultLogger(`warn`, \"`config` changed, regenerate lockScriptInfos!\");\n      lockScriptInfos._predefinedInfos = getPredefinedInfos();\n      lockScriptInfos.configHashCode = configHashCode;\n    }\n  }\n}\n\n/**\n *\n * @param txSkeleton\n * @param fromInfos\n * @param toAddress\n * @param changeAddress\n * @param amount\n * @param tipHeader will not use locktime cells if tipHeader not provided\n * @param options\n */\nasync function transfer(txSkeleton, fromInfos, toAddress, amount, changeAddress, tipHeader, {\n  config = undefined,\n  useLocktimeCellsFirst = true,\n  LocktimePoolCellCollector = _locktime_pool.CellCollector\n} = {}) {\n  var _targetLockScriptInfo;\n  config = config || (0, _configManager.getConfig)();\n  const _amount = _bi.BI.from(amount);\n  if (!toAddress) {\n    throw new Error(\"You must provide a to address!\");\n  }\n  const toScript = (0, _helpers.parseAddress)(toAddress, {\n    config\n  });\n  const targetOutput = {\n    cellOutput: {\n      capacity: \"0x\" + _amount.toString(16),\n      lock: toScript,\n      type: undefined\n    },\n    data: \"0x\"\n  };\n  generateLockScriptInfos({\n    config\n  });\n  const targetLockScriptInfo = lockScriptInfos.infos.find(lockScriptInfo => {\n    return lockScriptInfo.codeHash === toScript.codeHash && lockScriptInfo.hashType === toScript.hashType;\n  });\n  if (targetLockScriptInfo && (_targetLockScriptInfo = targetLockScriptInfo.lockScriptInfo) !== null && _targetLockScriptInfo !== void 0 && _targetLockScriptInfo.setupOutputCell) {\n    txSkeleton = await targetLockScriptInfo.lockScriptInfo.setupOutputCell(txSkeleton, targetOutput, {\n      config\n    });\n  } else {\n    txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n      return outputs.push(targetOutput);\n    });\n  }\n  txSkeleton = await injectCapacity(txSkeleton, fromInfos, _amount.toString(), changeAddress, tipHeader, {\n    config,\n    useLocktimeCellsFirst,\n    LocktimePoolCellCollector\n  });\n  return txSkeleton;\n}\nasync function injectCapacity(txSkeleton, fromInfos, amount, changeAddress, tipHeader, {\n  config = undefined,\n  useLocktimeCellsFirst = true,\n  LocktimePoolCellCollector = _locktime_pool.CellCollector,\n  enableDeductCapacity = true\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  const _amount = _bi.BI.from(amount);\n  let deductAmount = _amount;\n  if (fromInfos.length === 0) {\n    throw new Error(\"No from info provided!\");\n  }\n  const changeLockScript = (0, _from_info.parseFromInfo)(changeAddress || fromInfos[0], {\n    config\n  }).fromScript;\n  const changeCell = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: changeLockScript,\n      type: undefined\n    },\n    data: \"0x\"\n  };\n  const minimalChangeCapacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(changeCell));\n  let changeCapacity = _bi.BI.from(0);\n  if (useLocktimeCellsFirst) {\n    if (tipHeader) {\n      const result = await _locktime_pool.default.injectCapacityWithoutChangeCompatible(txSkeleton, fromInfos, deductAmount.toString(), tipHeader, minimalChangeCapacity.toString(), {\n        config,\n        LocktimeCellCollector: LocktimePoolCellCollector,\n        enableDeductCapacity\n      });\n      txSkeleton = result.txSkeleton;\n      deductAmount = _bi.BI.from(result.capacity);\n      // if deductAmount > 0, changeCapacity must be 0\n      changeCapacity = _bi.BI.from(result.changeCapacity);\n    }\n    if (deductAmount.gt(0)) {\n      const result = await _commonTransferCompatible(txSkeleton, fromInfos, deductAmount, minimalChangeCapacity, {\n        config,\n        enableDeductCapacity\n      });\n      txSkeleton = result.txSkeleton;\n      deductAmount = result.capacity;\n      changeCapacity = result.changeCapacity;\n    } else if (deductAmount.eq(0) && changeCapacity.gt(0) && changeCapacity.lt(minimalChangeCapacity)) {\n      const result = await _commonTransferCompatible(txSkeleton, fromInfos, minimalChangeCapacity.sub(changeCapacity), _bi.BI.from(0), {\n        config,\n        enableDeductCapacity\n      });\n      txSkeleton = result.txSkeleton;\n      deductAmount = result.capacity;\n      changeCapacity = result.changeCapacity;\n    }\n  } else {\n    const result = await _commonTransferCompatible(txSkeleton, fromInfos, deductAmount, minimalChangeCapacity, {\n      config,\n      enableDeductCapacity\n    });\n    txSkeleton = result.txSkeleton;\n    deductAmount = result.capacity;\n    changeCapacity = result.changeCapacity;\n    if (tipHeader) {\n      if (deductAmount.gt(0)) {\n        const result = await _locktime_pool.default.injectCapacityWithoutChangeCompatible(txSkeleton, fromInfos, deductAmount.toString(), tipHeader, minimalChangeCapacity.toString(), {\n          config,\n          LocktimeCellCollector: LocktimePoolCellCollector,\n          enableDeductCapacity\n        });\n        txSkeleton = result.txSkeleton;\n        deductAmount = _bi.BI.from(result.capacity);\n        changeCapacity = _bi.BI.from(result.changeCapacity);\n      } else if (deductAmount.eq(0) && changeCapacity.gt(0) && changeCapacity.lt(minimalChangeCapacity)) {\n        const result = await _locktime_pool.default.injectCapacityWithoutChangeCompatible(txSkeleton, fromInfos, minimalChangeCapacity.sub(changeCapacity).toString(), tipHeader, 0, {\n          config,\n          LocktimeCellCollector: LocktimePoolCellCollector,\n          enableDeductCapacity\n        });\n        txSkeleton = result.txSkeleton;\n        deductAmount = _bi.BI.from(result.capacity);\n        changeCapacity = _bi.BI.from(result.changeCapacity);\n      }\n    }\n  }\n  if (deductAmount.gt(0)) {\n    throw new Error(\"Not enough capacity in from infos!\");\n  }\n  if (changeCapacity.gt(0) && changeCapacity.lt(minimalChangeCapacity)) {\n    throw new Error(\"Not enough capacity in from infos for change!\");\n  }\n  if (changeCapacity.gt(0)) {\n    changeCell.cellOutput.capacity = \"0x\" + changeCapacity.toString(16);\n    txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n      return outputs.push(changeCell);\n    });\n  }\n  return txSkeleton;\n}\nasync function payFee(txSkeleton, fromInfos, amount, tipHeader, {\n  config = undefined,\n  useLocktimeCellsFirst = true,\n  enableDeductCapacity = true\n} = {}) {\n  return injectCapacity(txSkeleton, fromInfos, amount, undefined, tipHeader, {\n    config,\n    useLocktimeCellsFirst,\n    enableDeductCapacity\n  });\n}\nfunction prepareSigningEntries(txSkeleton, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  generateLockScriptInfos({\n    config\n  });\n  for (const lockScriptInfo of lockScriptInfos.infos) {\n    txSkeleton = lockScriptInfo.lockScriptInfo.prepareSigningEntries(txSkeleton, {\n      config\n    });\n  }\n  return txSkeleton;\n}\nasync function _commonTransfer(txSkeleton, fromInfos, amount, minimalChangeCapacity, {\n  config = undefined,\n  enableDeductCapacity = true\n} = {}) {\n  const result = await _commonTransferCompatible(txSkeleton, fromInfos, amount, minimalChangeCapacity, {\n    config,\n    enableDeductCapacity\n  });\n  return {\n    txSkeleton: result.txSkeleton,\n    capacity: BigInt(result.capacity.toString()),\n    changeCapacity: BigInt(result.changeCapacity.toString())\n  };\n}\nasync function _commonTransferCompatible(txSkeleton, fromInfos, amount, minimalChangeCapacity, {\n  config = undefined,\n  enableDeductCapacity = true\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  let _amount = _bi.BI.from(amount);\n  const cellProvider = txSkeleton.get(\"cellProvider\");\n  if (!cellProvider) {\n    throw new Error(\"Cell Provider is missing!\");\n  }\n  const getInputKey = input => {\n    var _input$outPoint, _input$outPoint2;\n    return `${(_input$outPoint = input.outPoint) === null || _input$outPoint === void 0 ? void 0 : _input$outPoint.txHash}_${(_input$outPoint2 = input.outPoint) === null || _input$outPoint2 === void 0 ? void 0 : _input$outPoint2.index}`;\n  };\n  let previousInputs = (0, _immutable.Set)();\n  for (const input of txSkeleton.get(\"inputs\")) {\n    previousInputs = previousInputs.add(getInputKey(input));\n  }\n  const fromScripts = fromInfos.map(fromInfo => {\n    return (0, _from_info.parseFromInfo)(fromInfo, {\n      config\n    }).fromScript;\n  });\n  for (const fromScript of fromScripts) {\n    if (enableDeductCapacity && _amount.gt(0)) {\n      [txSkeleton, _amount] = _deductCapacityCompatible(txSkeleton, fromScript, _amount);\n    }\n  }\n  generateLockScriptInfos({\n    config\n  });\n  let changeCapacity = _bi.BI.from(0);\n  if (_amount.gt(0)) {\n    // collect cells\n    loop1: for (const fromInfo of fromInfos) {\n      const cellCollectors = lockScriptInfos.infos.map(lockScriptInfo => {\n        return new lockScriptInfo.lockScriptInfo.CellCollector(fromInfo, cellProvider, {\n          config\n        });\n      });\n      for (const cellCollector of cellCollectors) {\n        for await (const inputCell of cellCollector.collect()) {\n          const inputKey = getInputKey(inputCell);\n          if (previousInputs.has(inputKey)) {\n            continue;\n          }\n          previousInputs = previousInputs.add(inputKey);\n          const result = await collectInputCompatible(txSkeleton, inputCell, fromInfo, {\n            config,\n            needCapacity: _amount\n          });\n          txSkeleton = result.txSkeleton;\n          const inputCapacity = _bi.BI.from(result.availableCapacity);\n          let deductCapacity = inputCapacity;\n          if (deductCapacity.gt(_amount)) {\n            deductCapacity = _amount;\n          }\n          _amount = _amount.sub(deductCapacity);\n          changeCapacity = changeCapacity.add(inputCapacity.sub(deductCapacity));\n          if (_amount.eq(0) && (changeCapacity.eq(0) || changeCapacity.gt(minimalChangeCapacity))) {\n            break loop1;\n          }\n        }\n      }\n    }\n  }\n  return {\n    txSkeleton,\n    capacity: _amount,\n    changeCapacity\n  };\n}\nfunction _deductCapacityCompatible(txSkeleton, fromScript, capacity) {\n  /*\n   * First, check if there is any output cells that contains enough capacity\n   * for us to tinker with.\n   *\n   * TODO: the solution right now won't cover all cases, some outputs before the\n   * last output might still be tinkerable, right now we are working on the\n   * simple solution, later we can change this for more optimizations.\n   */\n  let _capacity = _bi.BI.from(capacity);\n  const lastFreezedOutput = txSkeleton.get(\"fixedEntries\").filter(({\n    field\n  }) => field === \"outputs\").maxBy(({\n    index\n  }) => index);\n  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;\n  for (; i < txSkeleton.get(\"outputs\").size && _capacity.gt(0); i++) {\n    const output = txSkeleton.get(\"outputs\").get(i);\n    if (output && new ScriptValue(output.cellOutput.lock, {\n      validate: false\n    }).equals(new ScriptValue(fromScript, {\n      validate: false\n    }))) {\n      const clonedOutput = JSON.parse(JSON.stringify(output));\n      const cellCapacity = _bi.BI.from(clonedOutput.cellOutput.capacity);\n      const availableCapacity = cellCapacity;\n      let deductCapacity;\n      if (_capacity.gte(availableCapacity)) {\n        deductCapacity = availableCapacity;\n      } else {\n        deductCapacity = cellCapacity.sub((0, _helpers.minimalCellCapacityCompatible)(clonedOutput));\n        if (deductCapacity.gt(capacity)) {\n          deductCapacity = capacity;\n        }\n      }\n      _capacity = _capacity.sub(deductCapacity);\n      clonedOutput.cellOutput.capacity = \"0x\" + cellCapacity.sub(deductCapacity).toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n        return outputs.update(i, () => clonedOutput);\n      });\n    }\n  }\n  // Remove all output cells with capacity equal to 0\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.filter(output => _bi.BI.from(output.cellOutput.capacity).toString() !== _bi.BI.from(0).toString());\n  });\n  return [txSkeleton, _capacity];\n}\n\n// Alter output generated by `setupInputCell`\nasync function collectInputCompatible(txSkeleton, inputCell, fromInfo, {\n  config = undefined,\n  since = undefined,\n  defaultWitness = \"0x\",\n  needCapacity = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  txSkeleton = await setupInputCell(txSkeleton, inputCell, fromInfo, {\n    config,\n    since,\n    defaultWitness\n  });\n  const lastOutputIndex = txSkeleton.get(\"outputs\").size - 1;\n  const lastOutput = txSkeleton.get(\"outputs\").get(lastOutputIndex);\n  /* c8 ignore next 3 */\n  if (!lastOutput) {\n    throw new Error(\"Impossible: can not find last output\");\n  }\n  const lastOutputCapacity = _bi.BI.from(lastOutput.cellOutput.capacity);\n  const lastOutputFixedEntryIndex = txSkeleton.get(\"fixedEntries\").findIndex(fixedEntry => {\n    return fixedEntry.field === \"outputs\" && fixedEntry.index === lastOutputIndex;\n  });\n  const fromScript = inputCell.cellOutput.lock;\n  let availableCapacity = _bi.BI.from(0);\n  if (config.SCRIPTS.ANYONE_CAN_PAY && (0, _helper.isAcpScript)(fromScript, config)) {\n    const destroyable = !!(fromInfo && typeof fromInfo === \"object\" && \"destroyable\" in fromInfo && fromInfo.destroyable);\n    const _needCapacity = needCapacity ? _bi.BI.from(needCapacity) : lastOutputCapacity;\n    if (destroyable) {\n      availableCapacity = lastOutputCapacity;\n      // remove output & fixedEntry added by `setupInputCell`\n      txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n        return outputs.remove(lastOutputIndex);\n      });\n      if (lastOutputFixedEntryIndex >= 0) {\n        txSkeleton = txSkeleton.update(\"fixedEntries\", fixedEntries => {\n          return fixedEntries.remove(lastOutputFixedEntryIndex);\n        });\n      }\n    } else {\n      // Ignore `fixedEntries` and update capacity of output which generated by `setupInputCell`\n      const minimalOutputCapacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(lastOutput));\n      const canUseCapacity = lastOutputCapacity.sub(minimalOutputCapacity);\n      const clonedLastOutput = JSON.parse(JSON.stringify(lastOutput));\n      let outputCapacity = minimalOutputCapacity;\n      availableCapacity = canUseCapacity;\n      if (_needCapacity.lt(canUseCapacity)) {\n        outputCapacity = lastOutputCapacity.sub(_needCapacity);\n        availableCapacity = _needCapacity;\n      }\n      clonedLastOutput.cellOutput.capacity = \"0x\" + outputCapacity.toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n        return outputs.update(lastOutputIndex, () => clonedLastOutput);\n      });\n    }\n  } else {\n    // Ignore if last output is fixed.\n    if (lastOutputFixedEntryIndex < 0) {\n      var _txSkeleton$get$get;\n      // Remove last output\n      availableCapacity = _bi.BI.from((_txSkeleton$get$get = txSkeleton.get(\"outputs\").get(lastOutputIndex)) === null || _txSkeleton$get$get === void 0 ? void 0 : _txSkeleton$get$get.cellOutput.capacity);\n      txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n        return outputs.remove(lastOutputIndex);\n      });\n    }\n  }\n  return {\n    txSkeleton,\n    availableCapacity\n  };\n}\n\n/**\n * A function to transfer input to output, and add input & output to txSkeleton.\n * And it will deal with cell deps and witnesses too. (Add the input required cell deps and witnesses.)\n * It should be noted that the output must be added to the end of txSkeleton.get(\"outputs\").\n *\n * @param txSkeleton\n * @param inputCell\n * @param fromInfo\n * @param options\n */\nasync function setupInputCell(txSkeleton, inputCell, fromInfo, {\n  config = undefined,\n  since = undefined,\n  defaultWitness = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  generateLockScriptInfos({\n    config\n  });\n  const inputLock = inputCell.cellOutput.lock;\n  const targetLockScriptInfo = lockScriptInfos.infos.find(lockScriptInfo => {\n    return lockScriptInfo.codeHash === inputLock.codeHash && lockScriptInfo.hashType === inputLock.hashType;\n  });\n  if (!targetLockScriptInfo) {\n    throw new Error(`No LockScriptInfo found for setupInputCell!`);\n  }\n  return targetLockScriptInfo.lockScriptInfo.setupInputCell(txSkeleton, inputCell, fromInfo, {\n    config,\n    since,\n    defaultWitness\n  });\n}\nasync function payFeeByFeeRate(txSkeleton, fromInfos, feeRate, tipHeader, {\n  config = undefined,\n  useLocktimeCellsFirst = true,\n  enableDeductCapacity = true\n} = {}) {\n  let size = 0;\n  let newTxSkeleton = txSkeleton;\n\n  /**\n   * Only one case `currentTransactionSize < size` :\n   * change output capacity equals current fee (feeA), so one output reduced,\n   * and if reduce the fee, change output will add again, fee will increase to feeA.\n   */\n  let currentTransactionSize = getTransactionSize(newTxSkeleton);\n  while (currentTransactionSize > size) {\n    size = currentTransactionSize;\n    const fee = calculateFeeCompatible(size, feeRate);\n    newTxSkeleton = await payFee(txSkeleton, fromInfos, fee, tipHeader, {\n      config,\n      useLocktimeCellsFirst,\n      enableDeductCapacity\n    });\n    currentTransactionSize = getTransactionSize(newTxSkeleton);\n  }\n  return newTxSkeleton;\n}\nfunction calculateFee(size, feeRate) {\n  const result = calculateFeeCompatible(size, feeRate);\n  return BigInt(result.toString());\n}\nfunction calculateFeeCompatible(size, feeRate) {\n  const ratio = _bi.BI.from(1000);\n  const base = _bi.BI.from(size).mul(feeRate);\n  const fee = base.div(ratio);\n  if (fee.mul(ratio).lt(base)) {\n    return fee.add(1);\n  }\n  return _bi.BI.from(fee);\n}\nfunction getTransactionSize(txSkeleton) {\n  const tx = (0, _helpers.createTransactionFromSkeleton)(txSkeleton);\n  return getTransactionSizeByTx(tx);\n}\nfunction getTransactionSizeByTx(tx) {\n  const serializedTx = _base.blockchain.Transaction.pack(tx);\n  // 4 is serialized offset bytesize\n  const size = serializedTx.byteLength + 4;\n  return size;\n}\nvar _default = exports.default = {\n  transfer,\n  payFee,\n  prepareSigningEntries,\n  injectCapacity,\n  setupInputCell,\n  registerCustomLockScriptInfos,\n  payFeeByFeeRate,\n  __tests__: {\n    _commonTransfer,\n    resetLockScriptInfos,\n    getLockScriptInfos,\n    generateLockScriptInfos,\n    getTransactionSizeByTx,\n    getTransactionSize,\n    calculateFee,\n    calculateFeeCompatible\n  }\n};\n//# sourceMappingURL=common.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CellCollector = void 0;\nexports.calculateDaoEarliestSince = calculateDaoEarliestSince;\nexports.calculateDaoEarliestSinceCompatible = calculateDaoEarliestSinceCompatible;\nexports.calculateMaximumWithdraw = calculateMaximumWithdraw;\nexports.calculateMaximumWithdrawCompatible = calculateMaximumWithdrawCompatible;\nexports.default = void 0;\nexports.deposit = deposit;\nexports.extractDaoDataCompatible = extractDaoDataCompatible;\nexports.listDaoCells = listDaoCells;\nexports.unlock = unlock;\nvar _helpers = require(\"@ckb-lumos/helpers\");\nvar _base = require(\"@ckb-lumos/base\");\nvar _codec = require(\"@ckb-lumos/codec\");\nvar _configManager = require(\"@ckb-lumos/config-manager\");\nvar _secp256k1_blake = _interopRequireDefault(require(\"./secp256k1_blake160\"));\nvar _secp256k1_blake160_multisig = _interopRequireDefault(require(\"./secp256k1_blake160_multisig\"));\nvar _from_info = require(\"./from_info\");\nvar _helper = require(\"./helper\");\nvar _bi = require(\"@ckb-lumos/bi\");\nvar _rpc = require(\"@ckb-lumos/rpc\");\nvar _common = _interopRequireDefault(require(\"./common\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/* eslint-disable import/no-named-as-default-member */\n\nconst {\n  parseSince\n} = _base.since;\nconst DEPOSIT_DAO_DATA = \"0x0000000000000000\";\nconst DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE = _bi.BI.from(180);\nclass CellCollector {\n  constructor(fromInfo, cellProvider, cellType, {\n    config = undefined\n  } = {}) {\n    if (!cellProvider) {\n      throw new Error(\"Cell Provider is missing!\");\n    }\n    config = config || (0, _configManager.getConfig)();\n    const fromScript = (0, _from_info.parseFromInfo)(fromInfo, {\n      config\n    }).fromScript;\n    const daoTypeScript = (0, _helper.generateDaoScript)(config);\n    const data = cellType === \"deposit\" ? DEPOSIT_DAO_DATA : \"any\";\n    this.cellType = cellType;\n    this.cellCollector = cellProvider.collector({\n      lock: fromScript,\n      type: daoTypeScript,\n      data\n    });\n  }\n  async *collect() {\n    for await (const inputCell of this.cellCollector.collect()) {\n      if (this.cellType === \"withdraw\" && inputCell.data === DEPOSIT_DAO_DATA) {\n        continue;\n      }\n      yield inputCell;\n    }\n  }\n}\n\n/**\n * list DAO cells,\n *\n * @param cellProvider\n * @param fromAddress\n * @param cellType\n * @param options\n */\nexports.CellCollector = CellCollector;\nasync function* listDaoCells(cellProvider, fromAddress, cellType, {\n  config = undefined\n} = {}) {\n  const collector = new CellCollector(fromAddress, cellProvider, cellType, {\n    config\n  });\n  for await (const cell of collector.collect()) {\n    yield cell;\n  }\n}\n// TODO: reject multisig with non absolute-epoch-number locktime lock\n/**\n * deposit a cell to DAO\n *\n * @param txSkeleton\n * @param fromInfo only system script is enabled by default, to enable non-system script as inputs, please set enableNonSystemScript to true in options\n * @param toAddress deposit cell lock address\n * @param amount capacity in shannon\n * @param options\n */\nasync function deposit(txSkeleton, fromInfo, toAddress, amount, {\n  config = undefined,\n  enableNonSystemScript = false\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  const DAO_SCRIPT = config.SCRIPTS.DAO;\n  if (!DAO_SCRIPT) {\n    throw new Error(\"Provided config does not have DAO script setup!\");\n  }\n  _checkFromInfoSince(fromInfo, config);\n\n  // check and add cellDep if not exists\n  txSkeleton = _addDaoCellDep(txSkeleton, config);\n  if (!toAddress) {\n    throw new Error(\"You must provide a to address!\");\n  }\n  const toScript = (0, _helpers.parseAddress)(toAddress, {\n    config\n  });\n  const daoTypeScript = {\n    codeHash: DAO_SCRIPT.CODE_HASH,\n    hashType: DAO_SCRIPT.HASH_TYPE,\n    args: \"0x\"\n  };\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.push({\n      cellOutput: {\n        capacity: \"0x\" + _bi.BI.from(amount).toString(16),\n        lock: toScript,\n        type: daoTypeScript\n      },\n      data: DEPOSIT_DAO_DATA,\n      outPoint: undefined,\n      blockHash: undefined\n    });\n  });\n  const outputIndex = txSkeleton.get(\"outputs\").size - 1;\n\n  // fix entry\n  txSkeleton = txSkeleton.update(\"fixedEntries\", fixedEntries => {\n    return fixedEntries.push({\n      field: \"outputs\",\n      index: outputIndex\n    });\n  });\n  if (typeof fromInfo === \"string\") {\n    const fromScript = (0, _helpers.parseAddress)(fromInfo, {\n      config\n    });\n    // address\n    if ((0, _helper.isSecp256k1Blake160Script)(fromScript, config)) {\n      txSkeleton = await _secp256k1_blake.default.injectCapacity(txSkeleton, outputIndex, fromInfo, {\n        config\n      });\n    } else if ((0, _helper.isSecp256k1Blake160MultisigScript)(fromScript, config)) {\n      txSkeleton = await _secp256k1_blake160_multisig.default.injectCapacity(txSkeleton, outputIndex, fromInfo, {\n        config\n      });\n    } else if (enableNonSystemScript) {\n      txSkeleton = await _common.default.injectCapacity(txSkeleton, [fromInfo], amount, (0, _helpers.encodeToAddress)((0, _from_info.parseFromInfo)(fromInfo).fromScript, {\n        config\n      }), undefined, {\n        config\n      });\n    }\n  } else if (fromInfo) {\n    if ((0, _from_info.isMultisigFromInfo)(fromInfo)) {\n      txSkeleton = await _secp256k1_blake160_multisig.default.injectCapacity(txSkeleton, outputIndex, fromInfo, {\n        config\n      });\n    } else if (enableNonSystemScript) {\n      txSkeleton = await _common.default.injectCapacity(txSkeleton, [fromInfo], amount, (0, _helpers.encodeToAddress)((0, _from_info.parseFromInfo)(fromInfo).fromScript, {\n        config\n      }), undefined, {\n        config\n      });\n    }\n  }\n  return txSkeleton;\n}\nfunction _checkFromInfoSince(fromInfo, config) {\n  let since;\n  if (typeof fromInfo === \"string\") {\n    // fromInfo is an address\n    const fromScript = (0, _helpers.parseAddress)(fromInfo, {\n      config\n    });\n    const args = fromScript.args;\n    if (args.length === 58) {\n      since = _codec.number.Uint64LE.unpack(\"0x\" + args.slice(42)).toHexString();\n    }\n  } else if (\"R\" in fromInfo) {\n    since = fromInfo.since;\n  }\n  if (since != null) {\n    const {\n      relative,\n      type\n    } = parseSince(since);\n    if (!(!relative && type === \"epochNumber\")) {\n      throw new Error(\"Can't deposit a dao cell with multisig locktime which not using absolute-epoch-number format!\");\n    }\n  }\n}\n/**\n * withdraw an deposited DAO cell\n *\n * @param txSkeleton\n * @param fromInput deposited DAO cell\n * @param fromInfo\n * @param options\n */\nasync function withdraw(txSkeleton, fromInput, fromInfo, {\n  config = undefined,\n  enableNonSystemScript = false\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  _checkDaoScript(config);\n  txSkeleton = _addDaoCellDep(txSkeleton, config);\n\n  // check inputs.size == outputs.size\n  if (txSkeleton.get(\"inputs\").size !== txSkeleton.get(\"outputs\").size) {\n    throw new Error(\"Input size must equals to output size in txSkeleton!\");\n  }\n  if (!config.SCRIPTS.DAO) {\n    throw new Error(\"Provided config does not have DAO script setup!\");\n  }\n\n  // TODO: check fromInput\n\n  const cellProvider = txSkeleton.get(\"cellProvider\");\n  if (!cellProvider) {\n    throw new Error(\"Cell provider is missing!\");\n  }\n  const typeScript = fromInput.cellOutput.type;\n  const DAO_SCRIPT = config.SCRIPTS.DAO;\n  if (!typeScript || typeScript.codeHash !== DAO_SCRIPT.CODE_HASH || typeScript.hashType !== DAO_SCRIPT.HASH_TYPE || fromInput.data !== DEPOSIT_DAO_DATA) {\n    throw new Error(\"fromInput is not a DAO deposit cell.\");\n  }\n\n  // setup input cell\n  const fromLockScript = fromInput.cellOutput.lock;\n  if ((0, _helper.isSecp256k1Blake160Script)(fromLockScript, config)) {\n    txSkeleton = await _secp256k1_blake.default.setupInputCell(txSkeleton, fromInput, undefined, {\n      config\n    });\n  } else if ((0, _helper.isSecp256k1Blake160MultisigScript)(fromLockScript, config)) {\n    txSkeleton = await _secp256k1_blake160_multisig.default.setupInputCell(txSkeleton, fromInput, fromInfo || (0, _helpers.generateAddress)(fromLockScript, {\n      config\n    }), {\n      config\n    });\n  } else if (enableNonSystemScript) {\n    txSkeleton = await _common.default.setupInputCell(txSkeleton, fromInput, fromInfo || (0, _helpers.encodeToAddress)(fromLockScript, {\n      config\n    }), {\n      config\n    });\n  }\n  const targetOutputIndex = txSkeleton.get(\"outputs\").size - 1;\n  const targetOutput = txSkeleton.get(\"outputs\").get(targetOutputIndex);\n  const clonedTargetOutput = JSON.parse(JSON.stringify(targetOutput));\n  if (!fromInput.blockNumber) {\n    throw new Error(\"fromInput has no blockNumber!\");\n  } else {\n    clonedTargetOutput.data = _codec.bytes.hexify(_codec.number.Uint64.pack(fromInput.blockNumber));\n  }\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.update(targetOutputIndex, () => clonedTargetOutput);\n  });\n\n  // add header deps\n  txSkeleton = txSkeleton.update(\"headerDeps\", headerDeps => {\n    return headerDeps.push(fromInput.blockHash);\n  });\n\n  // fix inputs / outputs / witnesses\n  txSkeleton = txSkeleton.update(\"fixedEntries\", fixedEntries => {\n    return fixedEntries.push({\n      field: \"inputs\",\n      index: txSkeleton.get(\"inputs\").size - 1\n    }, {\n      field: \"outputs\",\n      index: txSkeleton.get(\"outputs\").size - 1\n    });\n  });\n  return txSkeleton;\n}\nfunction parseEpochCompatible(epoch) {\n  const _epoch = _bi.BI.from(epoch);\n  return {\n    length: _epoch.shr(40).and(0xfff),\n    index: _epoch.shr(24).and(0xfff),\n    number: _epoch.and(0xffffff)\n  };\n}\nfunction epochSinceCompatible({\n  length,\n  index,\n  number\n}) {\n  const _length = _bi.BI.from(length);\n  const _index = _bi.BI.from(index);\n  const _number = _bi.BI.from(number);\n  return _bi.BI.from(0x20).shl(56).add(_length.shl(40)).add(_index.shl(24)).add(_number);\n}\n\n/**\n * Unlock a withdrew DAO cell\n *\n * @param txSkeleton\n * @param depositInput deposited DAO cell\n * @param withdrawInput withdrew DAO cell\n * @param toAddress\n * @param fromInfo\n * @param options\n */\nasync function unlock(txSkeleton, depositInput, withdrawInput, toAddress, fromInfo, {\n  config = undefined,\n  RpcClient = _rpc.RPC\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  _checkDaoScript(config);\n  txSkeleton = _addDaoCellDep(txSkeleton, config);\n  if (!config.SCRIPTS.DAO) {\n    throw new Error(\"Provided config does not have DAO script setup!\");\n  }\n  const cellProvider = txSkeleton.get(\"cellProvider\");\n  if (!cellProvider) {\n    throw new Error(\"Cell provider is missing!\");\n  }\n  const rpc = new RpcClient(cellProvider.uri);\n  const typeScript = depositInput.cellOutput.type;\n  const DAO_SCRIPT = config.SCRIPTS.DAO;\n  if (!typeScript || typeScript.codeHash !== DAO_SCRIPT.CODE_HASH || typeScript.hashType !== DAO_SCRIPT.HASH_TYPE || depositInput.data !== DEPOSIT_DAO_DATA) {\n    throw new Error(\"depositInput is not a DAO deposit cell.\");\n  }\n  const withdrawTypeScript = withdrawInput.cellOutput.type;\n  if (!withdrawTypeScript || withdrawTypeScript.codeHash !== DAO_SCRIPT.CODE_HASH || withdrawTypeScript.hashType !== DAO_SCRIPT.HASH_TYPE || withdrawInput.data === DEPOSIT_DAO_DATA) {\n    throw new Error(\"withdrawInput is not a DAO withdraw cell.\");\n  }\n\n  // calculate since & capacity (interest)\n  const depositBlockHeader = await rpc.getHeader(depositInput.blockHash);\n  const depositEpoch = parseEpochCompatible(depositBlockHeader.epoch);\n  // const depositCapacity = BigInt(depositInput.cellOutput.capacity)\n\n  const withdrawBlockHeader = await rpc.getHeader(withdrawInput.blockHash);\n  const withdrawEpoch = parseEpochCompatible(withdrawBlockHeader.epoch);\n  const withdrawFraction = withdrawEpoch.index.mul(depositEpoch.length);\n  const depositFraction = depositEpoch.index.mul(withdrawEpoch.length);\n  let depositedEpochs = withdrawEpoch.number.sub(depositEpoch.number);\n  if (withdrawFraction.gt(depositFraction)) {\n    depositedEpochs = depositedEpochs.add(1);\n  }\n  const lockEpochs = depositedEpochs.add(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE).sub(1).div(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE).mul(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE);\n  const minimalSinceEpoch = {\n    number: _bi.BI.from(depositEpoch.number.add(lockEpochs)),\n    index: _bi.BI.from(depositEpoch.index),\n    length: _bi.BI.from(depositEpoch.length)\n  };\n  const minimalSince = epochSinceCompatible(minimalSinceEpoch);\n  const outputCapacity = \"0x\" + calculateMaximumWithdrawCompatible(withdrawInput, depositBlockHeader.dao, withdrawBlockHeader.dao).toString(16);\n  const toScript = (0, _helpers.parseAddress)(toAddress, {\n    config\n  });\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.push({\n      cellOutput: {\n        capacity: outputCapacity,\n        lock: toScript,\n        type: undefined\n      },\n      data: \"0x\",\n      outPoint: undefined,\n      blockHash: undefined\n    });\n  });\n  const since = \"0x\" + minimalSince.toString(16);\n  while (txSkeleton.get(\"witnesses\").size < txSkeleton.get(\"inputs\").size - 1) {\n    txSkeleton = txSkeleton.update(\"witnesses\", witnesses => witnesses.push(\"0x\"));\n  }\n\n  // add header deps\n  txSkeleton = txSkeleton.update(\"headerDeps\", headerDeps => {\n    return headerDeps.push(depositInput.blockHash, withdrawInput.blockHash);\n  });\n  const depositHeaderDepIndex = txSkeleton.get(\"headerDeps\").size - 2;\n\n  // setup input cell\n  const defaultWitnessArgs = {\n    inputType: _codec.bytes.hexify(_codec.number.Uint64LE.pack(depositHeaderDepIndex))\n  };\n  const defaultWitness = _codec.bytes.hexify(_base.blockchain.WitnessArgs.pack(defaultWitnessArgs));\n  const fromLockScript = withdrawInput.cellOutput.lock;\n  if ((0, _helper.isSecp256k1Blake160Script)(fromLockScript, config)) {\n    txSkeleton = await _secp256k1_blake.default.setupInputCell(txSkeleton, withdrawInput, undefined, {\n      config,\n      since,\n      defaultWitness\n    });\n  } else if ((0, _helper.isSecp256k1Blake160MultisigScript)(fromLockScript, config)) {\n    txSkeleton = await _secp256k1_blake160_multisig.default.setupInputCell(txSkeleton, withdrawInput, fromInfo || (0, _helpers.generateAddress)(fromLockScript, {\n      config\n    }), {\n      config,\n      since,\n      defaultWitness\n    });\n  }\n  // remove change output by setupInputCell\n  const lastOutputIndex = txSkeleton.get(\"outputs\").size - 1;\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.remove(lastOutputIndex);\n  });\n\n  // fix inputs / outputs / witnesses\n  txSkeleton = txSkeleton.update(\"fixedEntries\", fixedEntries => {\n    return fixedEntries.push({\n      field: \"inputs\",\n      index: txSkeleton.get(\"inputs\").size - 1\n    }, {\n      field: \"outputs\",\n      index: txSkeleton.get(\"outputs\").size - 1\n    }, {\n      field: \"witnesses\",\n      index: txSkeleton.get(\"witnesses\").size - 1\n    }, {\n      field: \"headerDeps\",\n      index: txSkeleton.get(\"headerDeps\").size - 2\n    });\n  });\n  return txSkeleton;\n}\n\n/**\n * calculate a withdraw dao cell minimal unlock since\n *\n * @param depositBlockHeaderEpoch depositBlockHeader.epoch\n * @param withdrawBlockHeaderEpoch withdrawBlockHeader.epoch\n */\nfunction calculateDaoEarliestSince(depositBlockHeaderEpoch, withdrawBlockHeaderEpoch) {\n  const result = calculateDaoEarliestSinceCompatible(depositBlockHeaderEpoch, withdrawBlockHeaderEpoch);\n  return BigInt(result.toString());\n}\n\n/**\n * calculate a withdraw dao cell minimal unlock since\n *\n * @param depositBlockHeaderEpoch depositBlockHeader.epoch\n * @param withdrawBlockHeaderEpoch withdrawBlockHeader.epoch\n */\nfunction calculateDaoEarliestSinceCompatible(depositBlockHeaderEpoch, withdrawBlockHeaderEpoch) {\n  const depositEpoch = parseEpochCompatible(depositBlockHeaderEpoch);\n  const withdrawEpoch = parseEpochCompatible(withdrawBlockHeaderEpoch);\n  const withdrawFraction = withdrawEpoch.index.mul(depositEpoch.length);\n  const depositFraction = depositEpoch.index.mul(withdrawEpoch.length);\n  let depositedEpochs = withdrawEpoch.number.sub(depositEpoch.number);\n  if (withdrawFraction.gt(depositFraction)) {\n    depositedEpochs = depositedEpochs.add(1);\n  }\n  const lockEpochs = depositedEpochs.add(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE).sub(1).div(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE).mul(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE);\n  const minimalSinceEpoch = {\n    number: _bi.BI.from(depositEpoch.number.add(lockEpochs)),\n    index: _bi.BI.from(depositEpoch.index),\n    length: _bi.BI.from(depositEpoch.length)\n  };\n  return epochSinceCompatible(minimalSinceEpoch);\n}\nfunction _checkDaoScript(config) {\n  const DAO_SCRIPT = config.SCRIPTS.DAO;\n  if (!DAO_SCRIPT) {\n    throw new Error(\"Provided config does not have DAO script setup!\");\n  }\n}\n\n/**\n *\n * @param {TransactionSkeleton} txSkeleton\n * @param {any} config\n * @returns {TransactionSkeleton} txSkeleton\n */\nfunction _addDaoCellDep(txSkeleton, config) {\n  const template = config.SCRIPTS.DAO;\n  return (0, _helper.addCellDep)(txSkeleton, {\n    outPoint: {\n      txHash: template.TX_HASH,\n      index: template.INDEX\n    },\n    depType: template.DEP_TYPE\n  });\n}\nfunction extractDaoDataCompatible(dao) {\n  if (!/^(0x)?([0-9a-fA-F]){64}$/.test(dao)) {\n    throw new Error(\"Invalid dao format!\");\n  }\n  const len = 8 * 2;\n  const hex = dao.startsWith(\"0x\") ? dao.slice(2) : dao;\n  return [\"c\", \"ar\", \"s\", \"u\"].map((key, i) => {\n    return {\n      [key]: _codec.number.Uint64LE.unpack(\"0x\" + hex.slice(len * i, len * (i + 1)))\n    };\n  }).reduce((result, c) => ({\n    ...result,\n    ...c\n  }), {});\n}\n\n/**\n * calculate maximum withdraw capacity when unlock\n *\n * @param withdrawCell withdrawCell or depositCell\n * @param depositDao depositBlockHeader.dao\n * @param withdrawDao withdrawBlockHeader.dao\n */\nfunction calculateMaximumWithdraw(withdrawCell, depositDao, withdrawDao) {\n  return calculateMaximumWithdrawCompatible(withdrawCell, depositDao, withdrawDao).toBigInt();\n}\n\n/**\n * calculate maximum withdraw capacity when unlock\n *\n * @param withdrawCell withdrawCell or depositCell\n * @param depositDao depositBlockHeader.dao\n * @param withdrawDao withdrawBlockHeader.dao\n */\nfunction calculateMaximumWithdrawCompatible(withdrawCell, depositDao, withdrawDao) {\n  const depositAR = _bi.BI.from(extractDaoDataCompatible(depositDao).ar);\n  const withdrawAR = _bi.BI.from(extractDaoDataCompatible(withdrawDao).ar);\n  const occupiedCapacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(withdrawCell));\n  const outputCapacity = _bi.BI.from(withdrawCell.cellOutput.capacity);\n  const countedCapacity = outputCapacity.sub(occupiedCapacity);\n  const withdrawCountedCapacity = countedCapacity.mul(withdrawAR).div(depositAR);\n  return withdrawCountedCapacity.add(occupiedCapacity);\n}\nvar _default = exports.default = {\n  deposit,\n  withdraw,\n  unlock,\n  calculateMaximumWithdraw,\n  calculateMaximumWithdrawCompatible,\n  calculateDaoEarliestSince,\n  calculateDaoEarliestSinceCompatible,\n  CellCollector,\n  listDaoCells\n};\n//# sourceMappingURL=dao.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compareScriptBinaryWithOnChainData = compareScriptBinaryWithOnChainData;\nexports.default = void 0;\nexports.generateDeployWithDataTx = generateDeployWithDataTx;\nexports.generateDeployWithTypeIdTx = generateDeployWithTypeIdTx;\nexports.generateUpgradeTypeIdDataTx = generateUpgradeTypeIdDataTx;\nvar _base = require(\"@ckb-lumos/base\");\nvar _codec = require(\"@ckb-lumos/codec\");\nvar _configManager = require(\"@ckb-lumos/config-manager\");\nvar _helpers = require(\"@ckb-lumos/helpers\");\nvar _immutable = require(\"immutable\");\nvar _from_info = require(\"./from_info\");\nvar _bi = require(\"@ckb-lumos/bi\");\nconst {\n  ScriptValue\n} = _base.values;\nfunction bytesToHex(bytes) {\n  let res = \"0x\";\n  for (let i = 0; i < bytes.length; i++) {\n    res += bytes[i].toString(16).padStart(2, \"0\");\n  }\n  return res;\n}\nasync function findCellsByLock(lockScript, cellProvider) {\n  const collector = cellProvider.collector({\n    lock: lockScript,\n    type: \"empty\",\n    data: \"0x\"\n  });\n  const cells = [];\n  for await (const cell of collector.collect()) {\n    cells.push(cell);\n  }\n  return cells;\n}\nfunction updateOutputs(txSkeleton, output) {\n  const cellCapacity = (0, _helpers.minimalCellCapacityCompatible)(output);\n  output.cellOutput.capacity = `0x${cellCapacity.toString(16)}`;\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.push(output);\n  });\n  return txSkeleton;\n}\nfunction updateCellDeps(txSkeleton, config) {\n  txSkeleton = txSkeleton.update(\"cellDeps\", cellDeps => {\n    return cellDeps.clear();\n  });\n  config = config || (0, _configManager.getConfig)();\n  const secp256k1Config = config.SCRIPTS.SECP256K1_BLAKE160;\n  const secp256k1MultiSigConfig = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;\n  if (!secp256k1Config || !secp256k1MultiSigConfig) {\n    throw new Error(\"Provided config does not have SECP256K1_BLAKE160 or SECP256K1_BLAKE160_MULTISIG script setup!\");\n  }\n  txSkeleton = txSkeleton.update(\"cellDeps\", cellDeps => {\n    return cellDeps.push({\n      outPoint: {\n        txHash: secp256k1Config.TX_HASH,\n        index: secp256k1Config.INDEX\n      },\n      depType: secp256k1Config.DEP_TYPE\n    },\n    // TODO: optimize me, push dep directly without checking actual locks used would cause bigger tx\n    {\n      outPoint: {\n        txHash: secp256k1MultiSigConfig.TX_HASH,\n        index: secp256k1MultiSigConfig.INDEX\n      },\n      depType: secp256k1MultiSigConfig.DEP_TYPE\n    });\n  });\n  return txSkeleton;\n}\nasync function completeTx(txSkeleton, fromInfo, config, feeRate) {\n  const inputCapacity = txSkeleton.get(\"inputs\").map(c => _bi.BI.from(c.cellOutput.capacity)).reduce((a, b) => a.add(b), _bi.BI.from(0));\n  const outputCapacity = txSkeleton.get(\"outputs\").map(c => _bi.BI.from(c.cellOutput.capacity)).reduce((a, b) => a.add(b), _bi.BI.from(0));\n  const needCapacity = outputCapacity.sub(inputCapacity);\n  txSkeleton = await injectCapacity(txSkeleton, fromInfo, _bi.BI.from(needCapacity), {\n    config: config,\n    feeRate: feeRate\n  });\n  return txSkeleton;\n}\nasync function injectCapacity(txSkeleton, fromInfo, amount, {\n  config = undefined,\n  feeRate = undefined\n}) {\n  config = config || (0, _configManager.getConfig)();\n  const _feeRate = feeRate || 1000;\n  let _amount = _bi.BI.from(amount);\n  const {\n    fromScript,\n    multisigScript\n  } = (0, _from_info.parseFromInfo)(fromInfo, {\n    config\n  });\n  _amount = _amount.add(_bi.BI.from(10).pow(8));\n  let changeCapacity = _bi.BI.from(10).pow(8);\n  const changeCell = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: fromScript,\n      type: undefined\n    },\n    data: \"0x\"\n  };\n  const minimalChangeCapacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(changeCell)).add(_bi.BI.from(10).pow(8));\n  if (_amount.lt(0)) {\n    changeCapacity = changeCapacity.sub(_amount);\n    _amount = _bi.BI.from(0);\n  }\n  if (_amount.gt(0) || changeCapacity.lt(minimalChangeCapacity)) {\n    const cellProvider = txSkeleton.get(\"cellProvider\");\n    if (!cellProvider) throw new Error(\"Cell provider is missing!\");\n    const cellCollector = cellProvider.collector({\n      lock: fromScript,\n      type: \"empty\",\n      data: \"0x\"\n    });\n    let previousInputs = (0, _immutable.Set)();\n    for (const input of txSkeleton.get(\"inputs\")) {\n      previousInputs = previousInputs.add(`${input.outPoint.txHash}_${input.outPoint.index}`);\n    }\n    for await (const inputCell of cellCollector.collect()) {\n      if (previousInputs.has(`${inputCell.outPoint.txHash}_${inputCell.outPoint.index}`)) continue;\n      txSkeleton = txSkeleton.update(\"inputs\", inputs => inputs.push(inputCell));\n      txSkeleton = txSkeleton.update(\"witnesses\", witnesses => witnesses.push(\"0x\"));\n      const inputCapacity = _bi.BI.from(inputCell.cellOutput.capacity);\n      let deductCapacity = inputCapacity;\n      if (deductCapacity.gt(_amount)) {\n        deductCapacity = _amount;\n      }\n      _amount = _amount.sub(deductCapacity);\n      changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);\n      if (_amount.eq(0) && (changeCapacity.eq(0) || changeCapacity.gte(minimalChangeCapacity))) break;\n    }\n  }\n  if (changeCapacity.gt(0)) {\n    changeCell.cellOutput.capacity = \"0x\" + changeCapacity.toString(16);\n    txSkeleton = txSkeleton.update(\"outputs\", outputs => outputs.push(changeCell));\n  }\n  if (_amount.gt(0) || changeCapacity.lt(minimalChangeCapacity)) throw new Error(\"Not enough capacity in from address!\");\n\n  /*\n   * Modify the skeleton, so the first witness of the fromAddress script group\n   * has a WitnessArgs construct with 65-byte zero filled values. While this\n   * is not required, it helps in transaction fee estimation.\n   */\n  const firstIndex = txSkeleton.get(\"inputs\").findIndex(input => new ScriptValue(input.cellOutput.lock, {\n    validate: false\n  }).equals(new ScriptValue(fromScript, {\n    validate: false\n  })));\n  if (firstIndex !== -1) {\n    while (firstIndex >= txSkeleton.get(\"witnesses\").size) {\n      txSkeleton = txSkeleton.update(\"witnesses\", witnesses => witnesses.push(\"0x\"));\n    }\n    let witness = txSkeleton.get(\"witnesses\").get(firstIndex);\n    let newWitnessArgs;\n    const SECP_SIGNATURE_PLACEHOLDER = \"0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n    if (typeof fromInfo !== \"string\") {\n      newWitnessArgs = {\n        lock: \"0x\" + multisigScript.slice(2) + SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(fromInfo.M)\n      };\n    } else {\n      newWitnessArgs = {\n        lock: SECP_SIGNATURE_PLACEHOLDER\n      };\n    }\n    if (witness !== \"0x\") {\n      const witnessArgs = _base.blockchain.WitnessArgs.unpack(_codec.bytes.bytify(witness));\n      const lock = witnessArgs.lock;\n      if (!!lock && !!newWitnessArgs.lock && !_codec.bytes.equal(lock, newWitnessArgs.lock)) {\n        throw new Error(\"Lock field in first witness is set aside for signature!\");\n      }\n      const inputType = witnessArgs.inputType;\n      if (inputType) {\n        newWitnessArgs.inputType = inputType;\n      }\n      const outputType = witnessArgs.outputType;\n      if (outputType) {\n        newWitnessArgs.outputType = outputType;\n      }\n    }\n    witness = _codec.bytes.hexify(_base.blockchain.WitnessArgs.pack(newWitnessArgs));\n    txSkeleton = txSkeleton.update(\"witnesses\", witnesses => witnesses.set(firstIndex, witness));\n  }\n  const txFee = calculateTxFee(txSkeleton, _feeRate);\n  changeCapacity = changeCapacity.sub(txFee);\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.pop();\n  });\n  if (changeCapacity.gt(0)) {\n    changeCell.cellOutput.capacity = \"0x\" + changeCapacity.toString(16);\n    txSkeleton = txSkeleton.update(\"outputs\", outputs => outputs.push(changeCell));\n  }\n  return txSkeleton;\n}\nfunction getTransactionSize(txSkeleton) {\n  const tx = (0, _helpers.createTransactionFromSkeleton)(txSkeleton);\n  return getTransactionSizeByTx(tx);\n}\nfunction getTransactionSizeByTx(tx) {\n  const serializedTx = _base.blockchain.Transaction.pack(tx);\n  // 4 is serialized offset bytesize\n  const size = serializedTx.byteLength + 4;\n  return size;\n}\nfunction calculateFee(size, feeRate) {\n  const ratio = _bi.BI.from(1000);\n  const base = _bi.BI.from(size).mul(feeRate);\n  const fee = base.div(ratio);\n  if (fee.mul(ratio).lt(base)) {\n    return fee.add(1);\n  }\n  return _bi.BI.from(fee);\n}\nfunction calculateTxFee(txSkeleton, feeRate) {\n  const txSize = getTransactionSize(txSkeleton);\n  return _bi.BI.from(calculateFee(txSize, feeRate));\n}\nfunction calculateCodeHashByBin(scriptBin) {\n  const bin = scriptBin.valueOf();\n  return new _base.utils.CKBHasher().update(bin.buffer.slice(bin.byteOffset, bin.byteLength + bin.byteOffset)).digestHex();\n}\nasync function getDataHash(outPoint, rpc) {\n  const txHash = outPoint.txHash;\n  const index = parseInt(outPoint.index, 10);\n  const tx = await rpc.getTransaction(txHash);\n  if (!tx) throw new Error(`TxHash(${txHash}) is not found`);\n  const outputData = tx.transaction.outputsData[index];\n  if (!outputData) throw new Error(`cannot find output data`);\n  return new _base.utils.CKBHasher().update(_codec.bytes.bytify(outputData)).digestHex();\n}\nfunction calculateTxHash(txSkeleton) {\n  const tx = (0, _helpers.createTransactionFromSkeleton)(txSkeleton);\n  const txHash = _base.utils.ckbHash(_base.blockchain.RawTransaction.pack(tx));\n  return txHash;\n}\nfunction getScriptConfigByDataHash(txSkeleton, outputIndex) {\n  const data = txSkeleton.outputs.get(outputIndex).data;\n  const codeHash = _base.utils.ckbHash(_codec.bytes.bytify(data));\n  const txHash = calculateTxHash(txSkeleton);\n  const scriptConfig = {\n    CODE_HASH: codeHash,\n    HASH_TYPE: \"data2\",\n    TX_HASH: txHash,\n    INDEX: \"0x0\",\n    DEP_TYPE: \"code\"\n  };\n  return scriptConfig;\n}\nfunction getScriptConfigByTypeHash(txSkeleton, outputIndex) {\n  const typeScript = txSkeleton.outputs.get(outputIndex).cellOutput.type;\n  const codeHash = _base.utils.computeScriptHash(typeScript);\n  const txHash = calculateTxHash(txSkeleton);\n  const scriptConfig = {\n    CODE_HASH: codeHash,\n    HASH_TYPE: \"type\",\n    TX_HASH: txHash,\n    INDEX: \"0x0\",\n    DEP_TYPE: \"code\"\n  };\n  return scriptConfig;\n}\nfunction getScriptConfig(txSkeleton, outputIndex) {\n  const outputCell = txSkeleton.outputs.get(outputIndex);\n  if (outputCell == undefined) throw new Error(\"Invalid txSkeleton or outputIndex\");\n  const type = outputCell.cellOutput.type;\n  if (type !== undefined) return getScriptConfigByTypeHash(txSkeleton, outputIndex);\n  return getScriptConfigByDataHash(txSkeleton, outputIndex);\n}\nfunction isMultisigFromInfo(fromInfo) {\n  if (typeof fromInfo !== \"object\") return false;\n  return \"M\" in fromInfo && \"R\" in fromInfo && Array.isArray(fromInfo.publicKeyHashes);\n}\nfunction verifyFromInfo(fromInfo, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  if (typeof fromInfo === \"string\") {\n    if (_configManager.helpers.nameOfScript((0, _helpers.parseAddress)(fromInfo, {\n      config\n    }), config.SCRIPTS) !== \"SECP256K1_BLAKE160\") throw new Error(\"only SECP256K1_BLAKE160 or SECP256K1_MULTISIG is supported\");\n  } else if (!isMultisigFromInfo(fromInfo)) {\n    throw new Error(\"only SECP256K1_BLAKE160 or SECP256K1_MULTISIG is supported\");\n  }\n}\n/**\n * Generate txSkeleton for writing binary data to CKB, usually for deploying contracts.\n * This generator only supports `SECP256K1_BLAKE160` and `SECP256K1_BLAKE160_MULTISIG` currently.\n *\n * @param options\n */\nasync function generateDeployWithDataTx(options) {\n  verifyFromInfo(options.fromInfo, {\n    config: options.config\n  });\n  let txSkeleton = (0, _helpers.TransactionSkeleton)({\n    cellProvider: options.cellProvider\n  });\n  const {\n    fromScript\n  } = (0, _from_info.parseFromInfo)(options.fromInfo, {\n    config: options.config\n  });\n  const output = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: fromScript\n    },\n    data: bytesToHex(options.scriptBinary)\n  };\n  txSkeleton = updateOutputs(txSkeleton, output);\n  txSkeleton = updateCellDeps(txSkeleton, options.config);\n  txSkeleton = await completeTx(txSkeleton, options.fromInfo, options.config, options.feeRate);\n  const scriptConfig = getScriptConfig(txSkeleton, 0);\n  return {\n    txSkeleton,\n    scriptConfig\n  };\n}\n\n/**\n * Generate txSkeleton for writing binary data to CKB via Type ID, usually for deploying contracts.\n * Deploying via Type ID makes it possible to upgrade contract, for more information about Type ID, please check: https://xuejie.space/2020_02_03_introduction_to_ckb_script_programming_type_id/\n * This generator only supports `SECP256K1_BLAKE160` and `SECP256K1_BLAKE160_MULTISIG` currently.\n *\n * @param options\n */\nasync function generateDeployWithTypeIdTx(options) {\n  verifyFromInfo(options.fromInfo, {\n    config: options.config\n  });\n  let txSkeleton = (0, _helpers.TransactionSkeleton)({\n    cellProvider: options.cellProvider\n  });\n  const {\n    fromScript\n  } = (0, _from_info.parseFromInfo)(options.fromInfo, {\n    config: options.config\n  });\n  const [resolved] = await findCellsByLock(fromScript, options.cellProvider);\n  if (!resolved) throw new Error(`fromAddress has no live ckb`);\n  const typeId = _base.utils.generateTypeIdScript({\n    previousOutput: resolved.outPoint,\n    since: \"0x0\"\n  }, \"0x0\");\n  const output = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: fromScript,\n      type: typeId\n    },\n    data: bytesToHex(options.scriptBinary)\n  };\n  txSkeleton = updateOutputs(txSkeleton, output);\n  txSkeleton = updateCellDeps(txSkeleton, options.config);\n  txSkeleton = await completeTx(txSkeleton, options.fromInfo, options.config, options.feeRate);\n  const scriptConfig = getScriptConfig(txSkeleton, 0);\n  return {\n    txSkeleton,\n    scriptConfig,\n    typeId\n  };\n}\nasync function generateUpgradeTypeIdDataTx(options) {\n  verifyFromInfo(options.fromInfo, {\n    config: options.config\n  });\n  let txSkeleton = (0, _helpers.TransactionSkeleton)({\n    cellProvider: options.cellProvider\n  });\n  const {\n    fromScript\n  } = (0, _from_info.parseFromInfo)(options.fromInfo, {\n    config: options.config\n  });\n  const collector = options.cellProvider.collector({\n    type: options.typeId\n  });\n  const cells = [];\n  for await (const cell of collector.collect()) {\n    cells.push(cell);\n  }\n  if (cells.length !== 1) throw new Error(\"the typeid maybe wrong\");\n  const deployedCell = cells[0];\n  txSkeleton = txSkeleton.update(\"inputs\", inputs => {\n    return inputs.push(deployedCell);\n  });\n  const output = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: fromScript,\n      type: options.typeId\n    },\n    data: bytesToHex(options.scriptBinary)\n  };\n  txSkeleton = updateOutputs(txSkeleton, output);\n  txSkeleton = updateCellDeps(txSkeleton, options.config);\n  txSkeleton = await completeTx(txSkeleton, options.fromInfo, options.config, options.feeRate);\n  const scriptConfig = getScriptConfig(txSkeleton, 0);\n  return {\n    txSkeleton,\n    scriptConfig\n  };\n}\nasync function compareScriptBinaryWithOnChainData(scriptBinary, outPoint, rpc) {\n  const localHash = calculateCodeHashByBin(scriptBinary);\n  const onChainHash = await getDataHash(outPoint, rpc);\n  return localHash === onChainHash;\n}\nvar _default = exports.default = {\n  generateDeployWithDataTx,\n  generateDeployWithTypeIdTx,\n  generateUpgradeTypeIdDataTx,\n  compareScriptBinaryWithOnChainData,\n  __tests__: {\n    calculateTxFee\n  }\n};\n//# sourceMappingURL=deploy.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isMultisigFromInfo = isMultisigFromInfo;\nexports.multisigArgs = multisigArgs;\nexports.parseFromInfo = parseFromInfo;\nexports.serializeMultisigScript = serializeMultisigScript;\nvar _base = require(\"@ckb-lumos/base\");\nvar _helpers = require(\"@ckb-lumos/helpers\");\nvar _configManager = require(\"@ckb-lumos/config-manager\");\nvar _codec = require(\"@ckb-lumos/codec\");\nconst {\n  CKBHasher\n} = _base.utils;\n\n/**\n * secp256k1_blake160_multisig script requires S, R, M, N and public key hashes\n * S must be zero now\n * and N equals to publicKeyHashes size\n * so only need to provide R, M and public key hashes\n */\n\nfunction isMultisigFromInfo(obj) {\n  if (!obj || typeof obj !== \"object\") return false;\n  const maybeMultisig = obj;\n  return typeof (maybeMultisig === null || maybeMultisig === void 0 ? void 0 : maybeMultisig.R) === \"number\" && typeof (maybeMultisig === null || maybeMultisig === void 0 ? void 0 : maybeMultisig.M) === \"number\" && Array.isArray(maybeMultisig === null || maybeMultisig === void 0 ? void 0 : maybeMultisig.publicKeyHashes);\n}\n/**\n *\n * @param params multisig script params\n * @returns serialized multisig script\n */\nfunction serializeMultisigScript({\n  R,\n  M,\n  publicKeyHashes\n}) {\n  if (R < 0 || R > 255) {\n    throw new Error(\"`R` should be less than 256!\");\n  }\n  if (M < 0 || M > 255) {\n    throw new Error(\"`M` should be less than 256!\");\n  }\n  // TODO: validate publicKeyHashes\n  return \"0x00\" + (\"00\" + R.toString(16)).slice(-2) + (\"00\" + M.toString(16)).slice(-2) + (\"00\" + publicKeyHashes.length.toString(16)).slice(-2) + publicKeyHashes.map(h => h.slice(2)).join(\"\");\n}\n\n/**\n *\n * @param serializedMultisigScript\n * @param since\n * @returns lock script args\n */\nfunction multisigArgs(serializedMultisigScript, since) {\n  let sinceLE = \"0x\";\n  if (since != null) {\n    sinceLE = _codec.bytes.hexify(_codec.number.Uint64LE.pack(since));\n  }\n  return new CKBHasher().update(serializedMultisigScript).digestHex().slice(0, 42) + sinceLE.slice(2);\n}\nfunction parseFromInfo(fromInfo, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  let fromScript;\n  let multisigScript;\n  let destroyable;\n  let customData;\n  if (typeof fromInfo === \"string\") {\n    // fromInfo is an address\n    fromScript = (0, _helpers.parseAddress)(fromInfo, {\n      config\n    });\n  } else {\n    if (\"R\" in fromInfo) {\n      const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;\n      if (!template) {\n        throw new Error(\"Provided config does not have SECP256K1_BLAKE16_MULTISIG script setup!\");\n      }\n      multisigScript = serializeMultisigScript(fromInfo);\n      const fromScriptArgs = multisigArgs(multisigScript, fromInfo.since);\n      fromScript = {\n        codeHash: template.CODE_HASH,\n        hashType: template.HASH_TYPE,\n        args: fromScriptArgs\n      };\n    } else if (\"address\" in fromInfo) {\n      const template = config.SCRIPTS.ANYONE_CAN_PAY;\n      if (!template) {\n        throw new Error(\"Provided config does not have ANYONE_CAN_PAY script setup!\");\n      }\n      const address = fromInfo.address;\n      fromScript = (0, _helpers.parseAddress)(address, {\n        config\n      });\n      destroyable = fromInfo.destroyable;\n      if (fromScript.codeHash !== template.CODE_HASH || fromScript.hashType !== template.HASH_TYPE) {\n        throw new Error(`fromInfo.address is not ANYONE_CAN_PAY address!`);\n      }\n    } else if (\"script\" in fromInfo) {\n      fromScript = fromInfo.script;\n      customData = fromInfo.customData;\n    } else {\n      throw new Error(\"Invalid fromInfo format!\");\n    }\n  }\n  return {\n    fromScript,\n    multisigScript,\n    destroyable,\n    customData\n  };\n}\n//# sourceMappingURL=from_info.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SECP_SIGNATURE_PLACEHOLDER = void 0;\nexports.addCellDep = addCellDep;\nexports.default = void 0;\nexports.ensureScript = ensureScript;\nexports.generateDaoScript = generateDaoScript;\nexports.hashWitness = hashWitness;\nexports.isAcpAddress = isAcpAddress;\nexports.isAcpScript = isAcpScript;\nexports.isDaoScript = isDaoScript;\nexports.isOmnilockAddress = isOmnilockAddress;\nexports.isOmnilockScript = isOmnilockScript;\nexports.isSecp256k1Blake160Address = isSecp256k1Blake160Address;\nexports.isSecp256k1Blake160MultisigAddress = isSecp256k1Blake160MultisigAddress;\nexports.isSecp256k1Blake160MultisigScript = isSecp256k1Blake160MultisigScript;\nexports.isSecp256k1Blake160Script = isSecp256k1Blake160Script;\nexports.isSudtScript = isSudtScript;\nexports.prepareSigningEntries = prepareSigningEntries;\nvar _immutable = require(\"immutable\");\nvar _helpers = require(\"@ckb-lumos/helpers\");\nvar _codec = require(\"@ckb-lumos/codec\");\nvar _base = require(\"@ckb-lumos/base\");\nvar _number = require(\"@ckb-lumos/codec/lib/number\");\n/* eslint-disable @typescript-eslint/no-non-null-assertion, @typescript-eslint/explicit-module-boundary-types */\n\nconst {\n  CKBHasher,\n  ckbHash\n} = _base.utils;\nfunction addCellDep(txSkeleton, newCellDep) {\n  const cellDep = txSkeleton.get(\"cellDeps\").find(cellDep => {\n    return cellDep.depType === newCellDep.depType && new _base.values.OutPointValue(cellDep.outPoint, {\n      validate: false\n    }).equals(new _base.values.OutPointValue(newCellDep.outPoint, {\n      validate: false\n    }));\n  });\n  if (!cellDep) {\n    txSkeleton = txSkeleton.update(\"cellDeps\", cellDeps => {\n      return cellDeps.push({\n        outPoint: newCellDep.outPoint,\n        depType: newCellDep.depType\n      });\n    });\n  }\n  return txSkeleton;\n}\nfunction generateDaoScript(config) {\n  const template = config.SCRIPTS.DAO;\n  return {\n    codeHash: template.CODE_HASH,\n    hashType: template.HASH_TYPE,\n    args: \"0x\"\n  };\n}\nfunction isSecp256k1Blake160Script(script, config) {\n  const template = config.SCRIPTS.SECP256K1_BLAKE160;\n  return script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;\n}\nfunction isSecp256k1Blake160Address(address, config) {\n  const script = (0, _helpers.parseAddress)(address, {\n    config\n  });\n  return isSecp256k1Blake160Script(script, config);\n}\nfunction isOmnilockScript(script, config) {\n  const template = config.SCRIPTS.OMNILOCK;\n  return script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;\n}\nfunction isOmnilockAddress(address, config) {\n  const script = (0, _helpers.parseAddress)(address, {\n    config\n  });\n  return isOmnilockScript(script, config);\n}\nfunction isSecp256k1Blake160MultisigScript(script, config) {\n  const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;\n  return script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;\n}\nfunction isSecp256k1Blake160MultisigAddress(address, config) {\n  const script = (0, _helpers.parseAddress)(address, {\n    config\n  });\n  return isSecp256k1Blake160MultisigScript(script, config);\n}\nfunction isDaoScript(script, config) {\n  const template = config.SCRIPTS.DAO;\n  return !!script && script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;\n}\nfunction isSudtScript(script, config) {\n  const template = config.SCRIPTS.SUDT;\n  if (!template) {\n    throw new Error(`SUDT script not defined in config!`);\n  }\n  return !!script && script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;\n}\nfunction isAcpScript(script, config) {\n  const template = config.SCRIPTS.ANYONE_CAN_PAY;\n  if (!template) {\n    throw new Error(`ANYONE_CAN_PAY script not defined in config!`);\n  }\n  return !!script && script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;\n}\nfunction isAcpAddress(address, config) {\n  const script = (0, _helpers.parseAddress)(address, {\n    config\n  });\n  return isAcpScript(script, config);\n}\n\n/**\n * Hash a witness in a hasher\n * @param hasher The hasher object which should have a `update` method.\n * @param witness witness data, the inputs to hasher will derived from it\n */\nfunction hashWitness(hasher, witness) {\n  // https://github.com/nervosnetwork/ckb-system-scripts/blob/a7b7c75662ed950c9bd024e15f83ce702a54996e/c/secp256k1_blake160_sighash_all.c#L81\n  const len = _codec.bytes.hexify(_number.Uint64.pack(_codec.bytes.bytify(witness).length));\n  // https://github.com/nervosnetwork/ckb-system-scripts/blob/a7b7c75662ed950c9bd024e15f83ce702a54996e/c/secp256k1_blake160_sighash_all.c#L214-L215\n  hasher.update(len);\n  hasher.update(witness);\n}\n/* eslint-enable camelcase, @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */\n\nfunction prepareSigningEntries(txSkeleton, config, scriptType) {\n  const template = config.SCRIPTS[scriptType];\n  if (!template) {\n    throw new Error(`Provided config does not have ${scriptType} script setup!`);\n  }\n  let processedArgs = (0, _immutable.Set)();\n  const tx = (0, _helpers.createTransactionFromSkeleton)(txSkeleton);\n  const txHash = ckbHash(_base.blockchain.RawTransaction.pack(tx));\n  const inputs = txSkeleton.get(\"inputs\");\n  const witnesses = txSkeleton.get(\"witnesses\");\n  let signingEntries = txSkeleton.get(\"signingEntries\");\n  for (let i = 0; i < inputs.size; i++) {\n    const input = inputs.get(i);\n    if (template.CODE_HASH === input.cellOutput.lock.codeHash && template.HASH_TYPE === input.cellOutput.lock.hashType && !processedArgs.has(input.cellOutput.lock.args)) {\n      processedArgs = processedArgs.add(input.cellOutput.lock.args);\n      const lockValue = new _base.values.ScriptValue(input.cellOutput.lock, {\n        validate: false\n      });\n      const hasher = new CKBHasher();\n      hasher.update(txHash);\n      if (i >= witnesses.size) {\n        throw new Error(`The first witness in the script group starting at input index ${i} does not exist, maybe some other part has invalidly tampered the transaction?`);\n      }\n      hashWitness(hasher, witnesses.get(i));\n      for (let j = i + 1; j < inputs.size && j < witnesses.size; j++) {\n        const otherInput = inputs.get(j);\n        if (lockValue.equals(new _base.values.ScriptValue(otherInput.cellOutput.lock, {\n          validate: false\n        }))) {\n          hashWitness(hasher, witnesses.get(j));\n        }\n      }\n      for (let j = inputs.size; j < witnesses.size; j++) {\n        hashWitness(hasher, witnesses.get(j));\n      }\n      const signingEntry = {\n        type: \"witness_args_lock\",\n        index: i,\n        message: hasher.digestHex()\n      };\n      signingEntries = signingEntries.push(signingEntry);\n    }\n  }\n  txSkeleton = txSkeleton.set(\"signingEntries\", signingEntries);\n  return txSkeleton;\n}\nfunction ensureScript(script, config, scriptType) {\n  const template = config.SCRIPTS[scriptType];\n  if (!template) {\n    throw new Error(`Provided config does not have ${scriptType} script setup!`);\n  }\n  if (template.CODE_HASH !== script.codeHash || template.HASH_TYPE !== script.hashType) {\n    throw new Error(`Provided script is not ${scriptType} script!`);\n  }\n}\n\n/* 65-byte zeros in hex */\nconst SECP_SIGNATURE_PLACEHOLDER = exports.SECP_SIGNATURE_PLACEHOLDER = \"0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\nvar _default = exports.default = {\n  addCellDep,\n  generateDaoScript,\n  isSecp256k1Blake160Script,\n  isSecp256k1Blake160MultisigScript,\n  isDaoScript,\n  isSudtScript,\n  prepareSigningEntries,\n  isSecp256k1Blake160Address,\n  isSecp256k1Blake160MultisigAddress,\n  ensureScript,\n  isAcpScript,\n  isAcpAddress\n};\n//# sourceMappingURL=helper.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"anyoneCanPay\", {\n  enumerable: true,\n  get: function () {\n    return _anyone_can_pay.default;\n  }\n});\nObject.defineProperty(exports, \"common\", {\n  enumerable: true,\n  get: function () {\n    return _common.default;\n  }\n});\nObject.defineProperty(exports, \"createP2PKHMessageGroup\", {\n  enumerable: true,\n  get: function () {\n    return _p2pkh.createP2PKHMessageGroup;\n  }\n});\nObject.defineProperty(exports, \"dao\", {\n  enumerable: true,\n  get: function () {\n    return _dao.default;\n  }\n});\nexports.default = void 0;\nObject.defineProperty(exports, \"deploy\", {\n  enumerable: true,\n  get: function () {\n    return _deploy.default;\n  }\n});\nObject.defineProperty(exports, \"locktimePool\", {\n  enumerable: true,\n  get: function () {\n    return _locktime_pool.default;\n  }\n});\nObject.defineProperty(exports, \"omnilock\", {\n  enumerable: true,\n  get: function () {\n    return _omnilock.default;\n  }\n});\nObject.defineProperty(exports, \"parseFromInfo\", {\n  enumerable: true,\n  get: function () {\n    return _from_info.parseFromInfo;\n  }\n});\nObject.defineProperty(exports, \"secp256k1Blake160\", {\n  enumerable: true,\n  get: function () {\n    return _secp256k1_blake.default;\n  }\n});\nObject.defineProperty(exports, \"secp256k1Blake160Multisig\", {\n  enumerable: true,\n  get: function () {\n    return _secp256k1_blake160_multisig.default;\n  }\n});\nObject.defineProperty(exports, \"sudt\", {\n  enumerable: true,\n  get: function () {\n    return _sudt.default;\n  }\n});\nvar _secp256k1_blake = _interopRequireDefault(require(\"./secp256k1_blake160\"));\nvar _secp256k1_blake160_multisig = _interopRequireDefault(require(\"./secp256k1_blake160_multisig\"));\nvar _from_info = require(\"./from_info\");\nvar _dao = _interopRequireDefault(require(\"./dao\"));\nvar _locktime_pool = _interopRequireDefault(require(\"./locktime_pool\"));\nvar _common = _interopRequireDefault(require(\"./common\"));\nvar _sudt = _interopRequireDefault(require(\"./sudt\"));\nvar _anyone_can_pay = _interopRequireDefault(require(\"./anyone_can_pay\"));\nvar _p2pkh = require(\"./p2pkh\");\nvar _deploy = _interopRequireDefault(require(\"./deploy\"));\nvar _omnilock = _interopRequireDefault(require(\"./omnilock\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar _default = exports.default = {\n  secp256k1Blake160: _secp256k1_blake.default,\n  secp256k1Blake160Multisig: _secp256k1_blake160_multisig.default,\n  dao: _dao.default,\n  locktimePool: _locktime_pool.default,\n  common: _common.default,\n  sudt: _sudt.default,\n  anyoneCanPay: _anyone_can_pay.default\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.CellCollector = void 0;\nexports.injectCapacity = injectCapacity;\nexports.payFee = payFee;\nexports.prepareSigningEntries = prepareSigningEntries;\nexports.setupInputCell = setupInputCell;\nexports.transfer = transfer;\nexports.transferCompatible = transferCompatible;\nvar _helpers = require(\"@ckb-lumos/helpers\");\nvar _codec = require(\"@ckb-lumos/codec\");\nvar _from_info = require(\"./from_info\");\nvar _secp256k1_blake = _interopRequireDefault(require(\"./secp256k1_blake160\"));\nvar _dao = require(\"./dao\");\nvar _base = require(\"@ckb-lumos/base\");\nvar _helper = require(\"./helper\");\nvar _immutable = require(\"immutable\");\nvar _configManager = require(\"@ckb-lumos/config-manager\");\nvar _ = require(\".\");\nvar _since = require(\"@ckb-lumos/base/lib/since\");\nvar _bi = require(\"@ckb-lumos/bi\");\nvar _rpc = require(\"@ckb-lumos/rpc\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nconst {\n  ScriptValue\n} = _base.values;\nconst {\n  parseEpoch,\n  maximumAbsoluteEpochSince,\n  generateAbsoluteEpochSince,\n  validateSince\n} = _base.since;\nconst CellCollector = exports.CellCollector = class CellCollector {\n  constructor(fromInfo, cellProvider, {\n    config = undefined,\n    queryOptions = {},\n    tipHeader = undefined,\n    NodeRPC = _rpc.RPC\n  } = {}) {\n    if (!cellProvider) {\n      throw new Error(`Cell provider is missing!`);\n    }\n    config = config || (0, _configManager.getConfig)();\n    const result = (0, _from_info.parseFromInfo)(fromInfo, {\n      config\n    });\n    const fromScript = result.fromScript;\n    this.multisigScript = result.multisigScript;\n    this.fromScript = fromScript;\n    this.config = config;\n    this.tipHeader = tipHeader;\n    if (tipHeader) {\n      // TODO: `median_timestamp` is not provided now!\n      this.tipSinceValidationInfo = {\n        blockNumber: tipHeader.number,\n        epoch: tipHeader.epoch,\n        median_timestamp: \"\"\n      };\n    }\n    this.rpc = new NodeRPC(cellProvider.uri);\n    queryOptions = {\n      ...queryOptions,\n      lock: this.fromScript\n    };\n    let cellCollectors = (0, _immutable.List)([]);\n    if ((0, _helper.isSecp256k1Blake160MultisigScript)(fromScript, config)) {\n      const lock = {\n        codeHash: fromScript.codeHash,\n        hashType: fromScript.hashType,\n        args: fromScript.args.slice(0, 42)\n      };\n      // multisig with locktime, not dao\n      cellCollectors = cellCollectors.push(cellProvider.collector({\n        lock,\n        argsLen: queryOptions.argsLen || 28,\n        type: queryOptions.type || \"empty\",\n        data: queryOptions.data || \"0x\"\n      }));\n      // multisig without locktime, dao\n      if (!queryOptions.type && (!queryOptions.data || queryOptions.data === \"any\")) {\n        cellCollectors = cellCollectors.push(cellProvider.collector({\n          lock,\n          type: (0, _helper.generateDaoScript)(config),\n          data: \"any\"\n        }));\n        // multisig with locktime, dao\n        cellCollectors = cellCollectors.push(cellProvider.collector({\n          lock,\n          argsLen: 28,\n          type: (0, _helper.generateDaoScript)(config),\n          data: \"any\"\n        }));\n      }\n    } else if ((0, _helper.isSecp256k1Blake160Script)(fromScript, config)) {\n      // secp256k1_blake160, dao\n      if (!queryOptions.type && (!queryOptions.data || queryOptions.data === \"any\")) {\n        cellCollectors = cellCollectors.push(cellProvider.collector({\n          lock: fromScript,\n          type: (0, _helper.generateDaoScript)(config),\n          data: \"any\"\n        }));\n      }\n    }\n    this.cellCollectors = cellCollectors;\n  }\n  async *collect() {\n    for (const cellCollector of this.cellCollectors) {\n      for await (const inputCell of cellCollector.collect()) {\n        const lock = inputCell.cellOutput.lock;\n        let since;\n        let maximumCapacity;\n        let depositBlockHash;\n        let withdrawBlockHash;\n        let sinceValidationInfo;\n\n        // multisig\n        if (lock.args.length === 58) {\n          const header = await this.rpc.getHeader(inputCell.blockHash);\n          since = \"0x\" + _parseMultisigArgsSinceCompatible(lock.args).toString(16);\n          // TODO: `median_timestamp` not provided now!\n          sinceValidationInfo = {\n            epoch: header.epoch,\n            blockNumber: header.number,\n            median_timestamp: \"\"\n          };\n        }\n\n        // dao\n        if ((0, _helper.isDaoScript)(inputCell.cellOutput.type, this.config)) {\n          if (inputCell.data === \"0x0000000000000000\") {\n            continue;\n          }\n          const transactionWithStatus = await this.rpc.getTransaction(inputCell.outPoint.txHash);\n          withdrawBlockHash = transactionWithStatus.txStatus.blockHash;\n          const transaction = transactionWithStatus.transaction;\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const depositOutPoint = transaction.inputs[+inputCell.outPoint.index].previousOutput;\n          depositBlockHash = (await this.rpc.getTransaction(depositOutPoint.txHash)).txStatus.blockHash;\n          const depositBlockHeader = await this.rpc.getHeader(depositBlockHash);\n          const withdrawBlockHeader = await this.rpc.getHeader(withdrawBlockHash);\n          let daoSince = \"0x\" + (0, _dao.calculateDaoEarliestSinceCompatible)(depositBlockHeader.epoch, withdrawBlockHeader.epoch).toString(16);\n          maximumCapacity = (0, _dao.calculateMaximumWithdrawCompatible)(inputCell, depositBlockHeader.dao, withdrawBlockHeader.dao);\n          const withdrawEpochValue = parseEpoch(withdrawBlockHeader.epoch);\n          const fourEpochsLater = {\n            number: withdrawEpochValue.number + 4,\n            length: withdrawEpochValue.length,\n            index: withdrawEpochValue.index\n          };\n          daoSince = maximumAbsoluteEpochSince(daoSince, generateAbsoluteEpochSince(fourEpochsLater));\n\n          // if multisig with locktime\n          if (since) {\n            const multisigSince = (0, _since.parseSinceCompatible)(since);\n            if (!(multisigSince.relative === false && multisigSince.type === \"epochNumber\")) {\n              // throw new Error(\n              //   \"Multisig since not an absolute-epoch-number since format!\"\n              // );\n              // skip multisig with locktime in non-absolute-epoch-number format, can't unlock it\n              continue;\n            }\n            try {\n              since = maximumAbsoluteEpochSince(daoSince, since);\n            } catch {\n              since = daoSince;\n            }\n          } else {\n            since = daoSince;\n          }\n        }\n        if ((0, _since.parseSinceCompatible)(since).type === \"blockTimestamp\" || this.tipHeader && !validateSince(since, this.tipSinceValidationInfo,\n        // TODO: modify the parameter type of `validateSince`\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        sinceValidationInfo)) {\n          continue;\n        }\n        const result = {\n          ...inputCell,\n          since: since,\n          depositBlockHash: depositBlockHash,\n          withdrawBlockHash: withdrawBlockHash,\n          sinceValidationInfo\n        };\n        result.cellOutput.capacity = \"0x\" + (maximumCapacity || _bi.BI.from(inputCell.cellOutput.capacity)).toString(16);\n        yield result;\n      }\n    }\n  }\n};\nasync function transfer(txSkeleton, fromInfos, toAddress, amount, tipHeader, {\n  config = undefined,\n  requireToAddress = true,\n  assertAmountEnough = true,\n  LocktimeCellCollector = CellCollector\n} = {}) {\n  const result = await transferCompatible(txSkeleton, fromInfos, toAddress, amount, tipHeader, {\n    config,\n    requireToAddress,\n    assertAmountEnough: assertAmountEnough,\n    LocktimeCellCollector\n  });\n  let _txSkeleton;\n  let _amount;\n  if (result instanceof Array) {\n    _txSkeleton = result[0];\n    _amount = BigInt(result[1].toString());\n    return [_txSkeleton, _amount];\n  } else {\n    _txSkeleton = result;\n    return _txSkeleton;\n  }\n}\nasync function transferCompatible(txSkeleton, fromInfos, toAddress, amount, tipHeader, {\n  config = undefined,\n  requireToAddress = true,\n  assertAmountEnough = true,\n  LocktimeCellCollector = CellCollector\n} = {}) {\n  let _amount = _bi.BI.from(amount);\n  for (const [index, fromInfo] of fromInfos.entries()) {\n    const value = await _transferCompatible(txSkeleton, fromInfo, index === 0 ? toAddress : undefined, _amount, tipHeader, {\n      config,\n      requireToAddress: index === 0 ? requireToAddress : false,\n      assertAmountEnough: false,\n      LocktimeCellCollector\n    });\n    // [txSkeleton, amount] = value\n    txSkeleton = value[0];\n    _amount = value[1];\n    if (_amount.eq(0)) {\n      if (assertAmountEnough) {\n        return txSkeleton;\n      }\n      return [txSkeleton, _bi.BI.from(_amount)];\n    }\n  }\n  if (assertAmountEnough) {\n    throw new Error(\"Not enough capacity in from addresses!\");\n  }\n  return [txSkeleton, _bi.BI.from(_amount)];\n}\nasync function _transferCompatible(txSkeleton, fromInfo, toAddress, amount, tipHeader, {\n  config = undefined,\n  requireToAddress = true,\n  assertAmountEnough = true,\n  LocktimeCellCollector = CellCollector,\n  changeAddress = undefined\n}) {\n  config = config || (0, _configManager.getConfig)();\n  // fromScript can be secp256k1_blake160 / secp256k1_blake160_multisig\n  const {\n    fromScript\n  } = (0, _from_info.parseFromInfo)(fromInfo, {\n    config\n  });\n\n  // validate fromScript\n  if (!(0, _helper.isSecp256k1Blake160MultisigScript)(fromScript, config) && !(0, _helper.isSecp256k1Blake160Script)(fromScript, config)) {\n    throw new Error(\"fromInfo not supported!\");\n  }\n  if (requireToAddress && !toAddress) {\n    throw new Error(\"You must provide a to address!\");\n  }\n  let _amount = _bi.BI.from(amount || 0);\n  if (toAddress) {\n    const toScript = (0, _helpers.parseAddress)(toAddress, {\n      config\n    });\n    txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n      return outputs.push({\n        cellOutput: {\n          capacity: \"0x\" + _amount.toString(16),\n          lock: toScript,\n          type: undefined\n        },\n        data: \"0x\",\n        outPoint: undefined,\n        blockHash: undefined\n      });\n    });\n  }\n  const lastFreezedOutput = txSkeleton.get(\"fixedEntries\").filter(({\n    field\n  }) => field === \"outputs\").maxBy(({\n    index\n  }) => index);\n  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;\n  for (; i < txSkeleton.get(\"outputs\").size && _amount.gt(0); ++i) {\n    const output = txSkeleton.get(\"outputs\").get(i);\n    if (new ScriptValue(output.cellOutput.lock, {\n      validate: false\n    }).equals(new ScriptValue(fromScript, {\n      validate: false\n    }))) {\n      const cellCapacity = _bi.BI.from(output.cellOutput.capacity);\n      let deductCapacity;\n      if (_amount.gte(cellCapacity)) {\n        deductCapacity = cellCapacity;\n      } else {\n        deductCapacity = cellCapacity.sub((0, _helpers.minimalCellCapacityCompatible)(output));\n        if (deductCapacity.gt(_amount)) {\n          deductCapacity = _amount;\n        }\n      }\n      _amount = _amount.sub(deductCapacity);\n      const clonedOutput = JSON.parse(JSON.stringify(output));\n      clonedOutput.cellOutput.capacity = \"0x\" + cellCapacity.sub(deductCapacity).toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n        return outputs.update(i, () => clonedOutput);\n      });\n    }\n  }\n  // remove all output cells with capacity equal to 0\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.filter(output => !_bi.BI.from(output.cellOutput.capacity).eq(0));\n  });\n  /*\n   * Collect and add new input cells so as to prepare remaining capacities.\n   */\n  if (_amount.gt(0)) {\n    const cellProvider = txSkeleton.get(\"cellProvider\");\n    if (!cellProvider) {\n      throw new Error(\"cell provider is missing!\");\n    }\n    const changeLockScript = changeAddress ? (0, _helpers.parseAddress)(changeAddress, {\n      config\n    }) : fromScript;\n    const changeCell = {\n      cellOutput: {\n        capacity: \"0x0\",\n        lock: changeLockScript,\n        type: undefined\n      },\n      data: \"0x\",\n      outPoint: undefined,\n      blockHash: undefined\n    };\n    let changeCapacity = _bi.BI.from(0);\n    let previousInputs = (0, _immutable.Set)();\n    for (const input of txSkeleton.get(\"inputs\")) {\n      previousInputs = previousInputs.add(`${input.outPoint.txHash}_${input.outPoint.index}`);\n    }\n    const cellCollector = new LocktimeCellCollector(fromInfo, cellProvider, {\n      config,\n      tipHeader\n    });\n    for await (const cell of cellCollector.collect()) {\n      const inputCell = cell;\n      // skip inputs already exists in txSkeleton.inputs\n      if (previousInputs.has(`${inputCell.outPoint.txHash}_${inputCell.outPoint.index}`)) {\n        continue;\n      }\n      let multisigSince;\n      if ((0, _helper.isSecp256k1Blake160MultisigScript)(fromScript, config)) {\n        const lockArgs = inputCell.cellOutput.lock.args;\n        multisigSince = lockArgs.length === 58 ? _bi.BI.from(_parseMultisigArgsSinceCompatible(lockArgs)) : undefined;\n      }\n      let witness = \"0x\";\n      if ((0, _helper.isDaoScript)(inputCell.cellOutput.type, config)) {\n        const template = config.SCRIPTS.DAO;\n        txSkeleton = (0, _helper.addCellDep)(txSkeleton, {\n          depType: template.DEP_TYPE,\n          outPoint: {\n            txHash: template.TX_HASH,\n            index: template.INDEX\n          }\n        });\n        txSkeleton = txSkeleton.update(\"headerDeps\", headerDeps => {\n          return headerDeps.push(inputCell.depositBlockHash, inputCell.withdrawBlockHash);\n        });\n        const depositHeaderDepIndex = txSkeleton.get(\"headerDeps\").size - 2;\n        const witnessArgs = {\n          inputType: _codec.bytes.hexify(_codec.number.Uint64.pack(depositHeaderDepIndex))\n        };\n        witness = _codec.bytes.hexify(_base.blockchain.WitnessArgs.pack(witnessArgs));\n      }\n      txSkeleton = await collectInput(txSkeleton, inputCell, (0, _helper.isSecp256k1Blake160MultisigScript)(fromScript, config) ? Object.assign({}, fromInfo, {\n        since: multisigSince\n      }) : fromInfo, {\n        config,\n        defaultWitness: witness,\n        since: inputCell.since\n      });\n      const inputCapacity = _bi.BI.from(inputCell.cellOutput.capacity);\n      let deductCapacity = inputCapacity;\n      if (deductCapacity.gt(_amount)) {\n        deductCapacity = _amount;\n      }\n      _amount = _amount.sub(deductCapacity);\n      changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);\n      if ((0, _helper.isDaoScript)(inputCell.cellOutput.type, config)) {\n        // fix inputs / outputs / witnesses\n        txSkeleton = txSkeleton.update(\"fixedEntries\", fixedEntries => {\n          return fixedEntries.push({\n            field: \"inputs\",\n            index: txSkeleton.get(\"inputs\").size - 1\n          }, {\n            field: \"witnesses\",\n            index: txSkeleton.get(\"witnesses\").size - 1\n          }, {\n            field: \"headerDeps\",\n            index: txSkeleton.get(\"headerDeps\").size - 2\n          });\n        });\n      }\n      if (_amount.eq(0) && (changeCapacity.eq(0) || changeCapacity.gt((0, _helpers.minimalCellCapacityCompatible)(changeCell)))) {\n        break;\n      }\n    }\n    if (changeCapacity.gt(0)) {\n      changeCell.cellOutput.capacity = \"0x\" + changeCapacity.toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", outputs => outputs.push(changeCell));\n    }\n  }\n  if (!assertAmountEnough) {\n    return [txSkeleton, _amount];\n  }\n  if (_amount.gt(0)) {\n    throw new Error(\"Not enough capacity in from address!\");\n  }\n  return txSkeleton;\n}\nasync function injectCapacityWithoutChangeCompatible(txSkeleton, fromInfos, amount, tipHeader, minimalChangeCapacity, {\n  config = undefined,\n  LocktimeCellCollector = CellCollector,\n  enableDeductCapacity = true\n}) {\n  config = config || (0, _configManager.getConfig)();\n  // fromScript can be secp256k1_blake160 / secp256k1_blake160_multisig\n\n  let _amount = _bi.BI.from(amount);\n  const _minimalChangeCapacity = _bi.BI.from(minimalChangeCapacity);\n  if (enableDeductCapacity) {\n    for (const fromInfo of fromInfos) {\n      const fromScript = (0, _from_info.parseFromInfo)(fromInfo, {\n        config\n      }).fromScript;\n      // validate fromScript\n      if (!(0, _helper.isSecp256k1Blake160MultisigScript)(fromScript, config) && !(0, _helper.isSecp256k1Blake160Script)(fromScript, config)) {\n        // Skip if not support.\n        continue;\n      }\n      const lastFreezedOutput = txSkeleton.get(\"fixedEntries\").filter(({\n        field\n      }) => field === \"outputs\").maxBy(({\n        index\n      }) => index);\n      let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;\n      for (; i < txSkeleton.get(\"outputs\").size && _amount.gt(0); ++i) {\n        const output = txSkeleton.get(\"outputs\").get(i);\n        if (new ScriptValue(output.cellOutput.lock, {\n          validate: false\n        }).equals(new ScriptValue(fromScript, {\n          validate: false\n        }))) {\n          const clonedOutput = JSON.parse(JSON.stringify(output));\n          const cellCapacity = _bi.BI.from(clonedOutput.cellOutput.capacity);\n          let deductCapacity;\n          if (_amount.gte(cellCapacity)) {\n            deductCapacity = cellCapacity;\n          } else {\n            deductCapacity = cellCapacity.sub((0, _helpers.minimalCellCapacityCompatible)(clonedOutput));\n            if (deductCapacity.gt(_amount)) {\n              deductCapacity = _amount;\n            }\n          }\n          _amount = _amount.sub(deductCapacity);\n          clonedOutput.cellOutput.capacity = \"0x\" + cellCapacity.sub(deductCapacity).toString(16);\n          txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n            return outputs.update(i, () => clonedOutput);\n          });\n        }\n      }\n      // remove all output cells with capacity equal to 0\n      txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n        return outputs.filter(output => !_bi.BI.from(output.cellOutput.capacity).eq(0));\n      });\n    }\n  }\n\n  /*\n   * Collect and add new input cells so as to prepare remaining capacities.\n   */\n  let changeCapacity = _bi.BI.from(0);\n  if (_amount.gt(0)) {\n    const cellProvider = txSkeleton.get(\"cellProvider\");\n    if (!cellProvider) {\n      throw new Error(\"cell provider is missing!\");\n    }\n    const getInputKey = input => `${input.outPoint.txHash}_${input.outPoint.index}`;\n    let previousInputs = (0, _immutable.Set)();\n    for (const input of txSkeleton.get(\"inputs\")) {\n      previousInputs = previousInputs.add(getInputKey(input));\n    }\n    for (const fromInfo of fromInfos) {\n      const fromScript = (0, _from_info.parseFromInfo)(fromInfo, {\n        config\n      }).fromScript;\n      const cellCollector = new LocktimeCellCollector(fromInfo, cellProvider, {\n        config,\n        tipHeader\n      });\n      for await (const cell of cellCollector.collect()) {\n        const inputCell = cell;\n        // skip inputs already exists in txSkeleton.inputs\n        if (previousInputs.has(getInputKey(inputCell))) {\n          continue;\n        }\n        let witness = \"0x\";\n        if ((0, _helper.isDaoScript)(inputCell.cellOutput.type, config)) {\n          const template = config.SCRIPTS.DAO;\n          txSkeleton = (0, _helper.addCellDep)(txSkeleton, {\n            depType: template.DEP_TYPE,\n            outPoint: {\n              txHash: template.TX_HASH,\n              index: template.INDEX\n            }\n          });\n          txSkeleton = txSkeleton.update(\"headerDeps\", headerDeps => {\n            return headerDeps.push(inputCell.depositBlockHash, inputCell.withdrawBlockHash);\n          });\n          const depositHeaderDepIndex = txSkeleton.get(\"headerDeps\").size - 2;\n          const witnessArgs = {\n            inputType: _codec.bytes.hexify(_codec.number.Uint64.pack(depositHeaderDepIndex))\n          };\n          witness = _codec.bytes.hexify(_base.blockchain.WitnessArgs.pack(witnessArgs));\n        }\n        let multisigSince;\n        if ((0, _helper.isSecp256k1Blake160MultisigScript)(fromScript, config)) {\n          // multisig\n          const lockArgs = inputCell.cellOutput.lock.args;\n          multisigSince = lockArgs.length === 58 ? _bi.BI.from(_parseMultisigArgsSinceCompatible(lockArgs)) : undefined;\n        }\n        txSkeleton = await collectInput(txSkeleton, inputCell, Object.assign({}, fromInfo, {\n          since: multisigSince\n        }), {\n          config,\n          defaultWitness: witness,\n          since: inputCell.since\n        });\n        const inputCapacity = _bi.BI.from(inputCell.cellOutput.capacity);\n        let deductCapacity = inputCapacity;\n        if (deductCapacity.gt(_amount)) {\n          deductCapacity = _amount;\n        }\n        _amount = _amount.sub(deductCapacity);\n        changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);\n        if ((0, _helper.isDaoScript)(inputCell.cellOutput.type, config)) {\n          // fix inputs / outputs / witnesses\n          txSkeleton = txSkeleton.update(\"fixedEntries\", fixedEntries => {\n            return fixedEntries.push({\n              field: \"inputs\",\n              index: txSkeleton.get(\"inputs\").size - 1\n            }, {\n              field: \"witnesses\",\n              index: txSkeleton.get(\"witnesses\").size - 1\n            }, {\n              field: \"headerDeps\",\n              index: txSkeleton.get(\"headerDeps\").size - 2\n            });\n          });\n        }\n        if (_amount.eq(0) && (changeCapacity.eq(0) || changeCapacity.gt(_minimalChangeCapacity))) {\n          break;\n        }\n      }\n    }\n  }\n  return {\n    txSkeleton,\n    capacity: _bi.BI.from(_amount.toString()),\n    changeCapacity: _bi.BI.from(changeCapacity.toString())\n  };\n}\nasync function injectCapacityWithoutChange(txSkeleton, fromInfos, amount, tipHeader, minimalChangeCapacity, {\n  config = undefined,\n  LocktimeCellCollector = CellCollector,\n  enableDeductCapacity = true\n}) {\n  const result = await injectCapacityWithoutChangeCompatible(txSkeleton, fromInfos, amount, tipHeader, minimalChangeCapacity, {\n    config,\n    LocktimeCellCollector,\n    enableDeductCapacity\n  });\n  return {\n    txSkeleton: result.txSkeleton,\n    capacity: result.capacity.toBigInt(),\n    changeCapacity: result.changeCapacity.toBigInt()\n  };\n}\nasync function payFee(txSkeleton, fromInfos, amount, tipHeader, {\n  config = undefined,\n  LocktimeCellCollector = CellCollector\n} = {}) {\n  return transferCompatible(txSkeleton, fromInfos, undefined, amount, tipHeader, {\n    config,\n    requireToAddress: false,\n    LocktimeCellCollector\n  });\n}\nfunction prepareSigningEntries(txSkeleton, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  txSkeleton = (0, _helper.prepareSigningEntries)(txSkeleton, config, \"SECP256K1_BLAKE160\");\n  txSkeleton = (0, _helper.prepareSigningEntries)(txSkeleton, config, \"SECP256K1_BLAKE160_MULTISIG\");\n  return txSkeleton;\n}\nasync function injectCapacity(txSkeleton, outputIndex, fromInfos, tipHeader, {\n  config = undefined,\n  LocktimeCellCollector = CellCollector\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  if (outputIndex >= txSkeleton.get(\"outputs\").size) {\n    throw new Error(\"Invalid output index!\");\n  }\n  const capacity = _bi.BI.from(txSkeleton.get(\"outputs\").get(outputIndex).cellOutput.capacity);\n  return transferCompatible(txSkeleton, fromInfos, undefined, _bi.BI.from(capacity), tipHeader, {\n    config,\n    requireToAddress: false,\n    LocktimeCellCollector\n  });\n}\nasync function collectInput(txSkeleton, inputCell, fromInfo, {\n  config = undefined,\n  since = undefined,\n  defaultWitness = \"0x\"\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  txSkeleton = await setupInputCell(txSkeleton, inputCell, fromInfo, {\n    config,\n    since,\n    defaultWitness\n  });\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.remove(outputs.size - 1);\n  });\n  return txSkeleton;\n}\nasync function setupInputCell(txSkeleton, inputCell, fromInfo, {\n  config = undefined,\n  since = undefined,\n  defaultWitness = \"0x\"\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  const inputLock = inputCell.cellOutput.lock;\n  if ((0, _helper.isSecp256k1Blake160Script)(inputLock, config)) {\n    return _secp256k1_blake.default.setupInputCell(txSkeleton, inputCell, fromInfo, {\n      config,\n      defaultWitness,\n      since\n    });\n  } else if ((0, _helper.isSecp256k1Blake160MultisigScript)(inputLock, config)) {\n    return _.secp256k1Blake160Multisig.setupInputCell(txSkeleton, inputCell, fromInfo, {\n      config,\n      defaultWitness,\n      since\n    });\n  } else {\n    throw new Error(`Not supported input lock!`);\n  }\n}\nfunction _parseMultisigArgsSinceCompatible(args) {\n  if (args.length !== 58) {\n    throw new Error(\"Invalid multisig with since args!\");\n  }\n  return _codec.number.Uint64LE.unpack(\"0x\" + args.slice(42));\n}\nvar _default = exports.default = {\n  CellCollector,\n  transfer,\n  transferCompatible,\n  payFee,\n  prepareSigningEntries,\n  injectCapacity,\n  setupInputCell,\n  injectCapacityWithoutChange,\n  injectCapacityWithoutChangeCompatible\n};\n//# sourceMappingURL=locktime_pool.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAddress = decodeAddress;\nexports.signMessage = signMessage;\nvar _codec = require(\"@ckb-lumos/codec\");\nvar _bech = require(\"bech32\");\nvar _bs = _interopRequireDefault(require(\"bs58\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n// TODO the magic number eslint will be resolved in 0.24 by recovering https://github.com/ckb-js/lumos/pull/682\n/*eslint-disable @typescript-eslint/no-magic-numbers*/\n\n// https://github.com/cryptape/omnilock/blob/9419b7795641da0ade25a04127e25d8a0b709077/c/ckb_identity.h#L28\nconst BTC_PREFIX = \"CKB (Bitcoin Layer) transaction: 0x\";\n\n/**\n * Decode bitcoin address to public key hash in bytes\n * @see https://en.bitcoin.it/wiki/List_of_address_prefixes\n * @param address\n */\nfunction decodeAddress(address) {\n  try {\n    // Bech32\n    if (address.startsWith(\"bc1q\")) {\n      return _bech.bech32.fromWords(_bech.bech32.decode(address).words.slice(1));\n    }\n\n    // P2PKH\n    if (address.startsWith(\"1\")) {\n      return _bs.default.decode(address).slice(1, 21);\n    }\n\n    // P2SH\n    if (address.startsWith(\"3\")) {\n      return _bs.default.decode(address).slice(1, 21);\n    }\n  } catch {\n    // https://bitcoin.design/guide/glossary/address/#taproot-address---p2tr\n    if (address.startsWith(\"bc1p\")) {\n      throw new Error(\"Taproot address is not supported yet.\");\n    }\n  }\n  throw new Error(`Unsupported bitcoin address ${address}, only 1...(P2PKH) 3...(P2SH), and bc1...(Bech32) are supported.`);\n}\nasync function signMessage(digest, type, provider) {\n  const internal = (() => {\n    if (provider) return provider;\n\n    /* c8 ignore next 15*/\n    if (typeof window !== \"undefined\") {\n      if (\"unisat\" in window) {\n        return window.unisat;\n      }\n      if (\"okxwallet\" in window && \"bitcoin\" in window.okxwallet) {\n        return window.okxwallet.bitcoin;\n      }\n    }\n    throw new Error(\"No provider found, make sure you have installed UniSat Wallet\");\n  })();\n  const accounts = await internal.requestAccounts();\n  const digestWithout0x = _codec.bytes.hexify(digest).slice(2);\n  const signatureBase64 = await internal.signMessage(`${BTC_PREFIX}${digestWithout0x}`, type);\n  const signature = _codec.bytes.bytify(base64ToHex(signatureBase64));\n  const address = accounts[0];\n  // a secp256k1 private key can be used to sign various types of messages\n  // the first byte of signature used as a recovery id to identify the type of message\n  // https://github.com/XuJiandong/omnilock/blob/4e9fdb6ca78637651c8145bb7c5b82b4591332fb/c/ckb_identity.h#L249-L266\n  if (address.startsWith(\"bc1q\")) {\n    signature[0] = 39 + (signature[0] - 27) % 4;\n  } else if (address.startsWith(\"3\")) {\n    signature[0] = 35 + (signature[0] - 27) % 4;\n  } else if (address.startsWith(\"1\")) {\n    signature[0] = 31 + (signature[0] - 27) % 4;\n  } else {\n    throw new Error(`Unsupported bitcoin address ${address}, only 1...(P2PKH) 3...(P2SH), and bc1...(Bech32) are supported.`);\n  }\n  return _codec.bytes.hexify(signature);\n}\nfunction base64ToHex(str) {\n  const raw = atob(str);\n  let result = \"\";\n  for (let i = 0; i < raw.length; i++) {\n    const hex = raw.charCodeAt(i).toString(16);\n    result += hex.length === 2 ? hex : \"0\" + hex;\n  }\n  return \"0x\" + result;\n}\n//# sourceMappingURL=omnilock-bitcoin.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.signMessage = signMessage;\nvar _codec = require(\"@ckb-lumos/codec\");\n// https://github.com/XuJiandong/omnilock/blob/5c25d6a1a48f7d5984170aa501d5567281ba1a4c/c/ckb_identity.h#L36\nconst COMMON_PREFIX = \"CKB transaction: 0x\";\nasync function signMessage(digest, provider) {\n  const internal = (() => {\n    if (provider) return provider;\n\n    /* c8 ignore start */\n    if (typeof window !== \"undefined\" && \"phantom\" in window && window.phantom && \"solana\" in window.phantom) {\n      return window.phantom.solana;\n    }\n    throw new Error(\"No provider found, make sure you have installed Phantom or other Solana wallet\");\n    /* c8 ignore stop */\n  })();\n\n  // '0x'.length\n  const hexPrefixLength = 2;\n  const digestWithout0x = _codec.bytes.hexify(digest).slice(hexPrefixLength);\n  const signed = await internal.signMessage(new TextEncoder().encode(`${COMMON_PREFIX}${digestWithout0x}`));\n  return _codec.bytes.hexify(_codec.bytes.concat(signed.signature, signed.publicKey.toBytes()));\n}\n//# sourceMappingURL=omnilock-solana.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bitcoin = exports.OmnilockWitnessLock = exports.CellCollector = void 0;\nexports.createOmnilockScript = createOmnilockScript;\nexports.default = void 0;\nexports.prepareSigningEntries = prepareSigningEntries;\nexports.setupInputCell = setupInputCell;\nexports.solana = void 0;\nvar _codec = require(\"@ckb-lumos/codec\");\nvar _base = require(\"@ckb-lumos/base\");\nvar _configManager = require(\"@ckb-lumos/config-manager\");\nvar _helper = require(\"./helper\");\nvar _from_info = require(\"./from_info\");\nvar _molecule = require(\"@ckb-lumos/codec/lib/molecule\");\nvar _blockchain = require(\"@ckb-lumos/codec/lib/blockchain\");\nvar _bytes = require(\"@ckb-lumos/codec/lib/bytes\");\nvar bitcoin = _interopRequireWildcard(require(\"./omnilock-bitcoin\"));\nexports.bitcoin = bitcoin;\nvar solana = _interopRequireWildcard(require(\"./omnilock-solana\"));\nexports.solana = solana;\nvar _bs = require(\"bs58\");\nvar _utils = require(\"@ckb-lumos/base/lib/utils\");\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nconst {\n  ScriptValue\n} = _base.values;\n// https://github.com/XuJiandong/omnilock/blob/4e9fdb6ca78637651c8145bb7c5b82b4591332fb/c/ckb_identity.h#L62-L76\nvar IdentityFlagsType = /*#__PURE__*/function (IdentityFlagsType) {\n  IdentityFlagsType[IdentityFlagsType[\"IdentityFlagsCkb\"] = 0] = \"IdentityFlagsCkb\";\n  IdentityFlagsType[IdentityFlagsType[\"IdentityFlagsEthereum\"] = 1] = \"IdentityFlagsEthereum\";\n  IdentityFlagsType[IdentityFlagsType[\"IdentityFlagsEos\"] = 2] = \"IdentityFlagsEos\";\n  IdentityFlagsType[IdentityFlagsType[\"IdentityFlagsTron\"] = 3] = \"IdentityFlagsTron\";\n  IdentityFlagsType[IdentityFlagsType[\"IdentityFlagsBitcoin\"] = 4] = \"IdentityFlagsBitcoin\";\n  IdentityFlagsType[IdentityFlagsType[\"IdentityFlagsDogecoin\"] = 5] = \"IdentityFlagsDogecoin\";\n  IdentityFlagsType[IdentityFlagsType[\"IdentityCkbMultisig\"] = 6] = \"IdentityCkbMultisig\";\n  IdentityFlagsType[IdentityFlagsType[\"IdentityFlagsEthereumDisplaying\"] = 18] = \"IdentityFlagsEthereumDisplaying\";\n  IdentityFlagsType[IdentityFlagsType[\"IdentityFlagsSolana\"] = 19] = \"IdentityFlagsSolana\";\n  IdentityFlagsType[IdentityFlagsType[\"IdentityFlagsOwnerLock\"] = 252] = \"IdentityFlagsOwnerLock\";\n  IdentityFlagsType[IdentityFlagsType[\"IdentityFlagsExec\"] = 253] = \"IdentityFlagsExec\";\n  IdentityFlagsType[IdentityFlagsType[\"IdentityFlagsDl\"] = 254] = \"IdentityFlagsDl\";\n  return IdentityFlagsType;\n}(IdentityFlagsType || {}); // https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0042-omnilock/0042-omnilock.md#authentication\nconst OMNILOCK_AUTH_CONTENT_LENGTH = 20;\nconst SECP256K1_SIGNATURE_PLACEHOLDER_LENGTH = 65;\n\n//  https://datatracker.ietf.org/doc/html/rfc8032#section-7.1\n// 64 bytes for ED25519 signature\n// 32 bytes for Ed25519 pubkey public key\nconst ED25519_SIGNATURE_PLACEHOLDER_LENGTH = 96;\n\n/**\n * only support ETHEREUM and SECP256K1_BLAKE160 mode currently\n * refer to: @link https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0042-omnilock/0042-omnilock.md omnilock\n * @param omnilockInfo\n * @param options\n * @returns\n * @example\n * // create an omnilock to work with MetaMask wallet\n * createOmnilockScript({\n *   auth: {\n *     flag: \"ETHEREUM\",\n *     content: \"an ethereum address here\",\n *   }, { config })\n * // or we can create an omnilock to work with UniSat wallet\n * createOmnilockScript({\n *   auth: {\n *     flag: \"BITCOIN\",\n *     content: \"a bitcoin address here\",\n *   }\n * }, {config})\n */\nfunction createOmnilockScript(omnilockInfo, options) {\n  const config = (options === null || options === void 0 ? void 0 : options.config) || (0, _configManager.getConfig)();\n  const omnilockConfig = config.SCRIPTS.OMNILOCK;\n  if (!omnilockConfig) {\n    throw new Error(\"OMNILOCK script config not found.\");\n  }\n\n  // TODO The advanced feature will be supported in the future.\n  // https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0042-omnilock/0042-omnilock.md\n  /**\n   * |Name                 |Flags     |Affected Args              |Affected Args Size (byte)|Affected Witness|\n   * |---------------------|----------|---------------------------|-------------------------|----------------|\n   * |administrator mode   |0b00000001|AdminList cell Type ID     |32                       |omni_identity/signature in OmniLockWitnessLock|\n   * |anyone-can-pay mode  |0b00000010|minimum ckb/udt in ACP     |2                        |N/A             |\n   * |time-lock mode       |0b00000100|since for timelock         |8                        |N/A             |\n   * |supply mode          |0b00001000|type script hash for supply|32                       |N/A             |\n   */\n  const defaultOmnilockArgs = 0b00000000;\n  const omnilockArgs = [defaultOmnilockArgs];\n  const args = (() => {\n    const flag = omnilockInfo.auth.flag;\n    switch (flag) {\n      case \"ETHEREUM\":\n        return _codec.bytes.hexify(_codec.bytes.concat([IdentityFlagsType.IdentityFlagsEthereum], omnilockInfo.auth.content, omnilockArgs));\n      case \"SECP256K1_BLAKE160\":\n        return _codec.bytes.hexify(_codec.bytes.concat([IdentityFlagsType.IdentityFlagsCkb], omnilockInfo.auth.content, omnilockArgs));\n      case \"BITCOIN\":\n        return _codec.bytes.hexify(_codec.bytes.concat([IdentityFlagsType.IdentityFlagsBitcoin], bitcoin.decodeAddress(omnilockInfo.auth.content), omnilockArgs));\n      case \"SOLANA\":\n        {\n          const authContent = _codec.bytes.bytify((0, _utils.ckbHash)((0, _bs.decode)(omnilockInfo.auth.content))).slice(0, OMNILOCK_AUTH_CONTENT_LENGTH);\n          return _codec.bytes.hexify(_codec.bytes.concat([IdentityFlagsType.IdentityFlagsSolana], authContent, omnilockArgs));\n        }\n      default:\n        throw new Error(`Not supported flag: ${flag}.`);\n    }\n  })();\n  return {\n    codeHash: omnilockConfig.CODE_HASH,\n    hashType: omnilockConfig.HASH_TYPE,\n    args\n  };\n}\nconst Hexify = {\n  pack: _bytes.bytify,\n  unpack: _bytes.hexify\n};\n\n// https://github.com/cryptape/omnilock/blob/cd764d7133ec4e6b192fac4b93fc0596ef5b71f6/c/omni_lock.mol#L3\n// array Auth[byte; 21];\nconst IDENTITY_LENGTH = 21;\nconst Auth = (0, _blockchain.createFixedHexBytesCodec)(IDENTITY_LENGTH);\nconst SmtProof = (0, _molecule.byteVecOf)(Hexify);\nconst SmtProofEntry = (0, _molecule.table)({\n  mask: (0, _molecule.byteOf)(Hexify),\n  proof: SmtProof\n}, [\"mask\", \"proof\"]);\nconst SmtProofEntryVec = (0, _molecule.vector)(SmtProofEntry);\nconst OmniIdentity = (0, _molecule.table)({\n  identity: Auth,\n  proofs: SmtProofEntryVec\n}, [\"identity\", \"proofs\"]);\nconst OmniIdentityOpt = (0, _molecule.option)(OmniIdentity);\nconst OmnilockWitnessLock = exports.OmnilockWitnessLock = (0, _molecule.table)({\n  signature: _blockchain.BytesOpt,\n  omni_identity: OmniIdentityOpt,\n  preimage: _blockchain.BytesOpt\n}, [\"signature\", \"omni_identity\", \"preimage\"]);\nconst CellCollector = exports.CellCollector = class CellCollector {\n  constructor(fromInfo, cellProvider, {\n    config = undefined,\n    queryOptions = {}\n  } = {}) {\n    if (!cellProvider) {\n      throw new Error(`Cell provider is missing!`);\n    }\n    config = config || (0, _configManager.getConfig)();\n    this.fromScript = (0, _from_info.parseFromInfo)(fromInfo, {\n      config\n    }).fromScript;\n    this.config = config;\n    queryOptions = {\n      ...queryOptions,\n      lock: this.fromScript,\n      type: queryOptions.type || \"empty\"\n    };\n    this.cellCollector = cellProvider.collector(queryOptions);\n  }\n  async *collect() {\n    if (!(0, _helper.isOmnilockScript)(this.fromScript, this.config)) {\n      return;\n    }\n    for await (const inputCell of this.cellCollector.collect()) {\n      yield inputCell;\n    }\n  }\n};\n\n/**\n * Setup input cell infos, such as cell deps and witnesses.\n *\n * @param txSkeleton\n * @param inputCell\n * @param _fromInfo\n * @param options\n */\nasync function setupInputCell(txSkeleton, inputCell, _fromInfo, {\n  config = undefined,\n  defaultWitness = \"0x\",\n  since = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  const fromScript = inputCell.cellOutput.lock;\n  if (!(0, _helper.isOmnilockScript)(fromScript, config)) {\n    throw new Error(`Not OMNILOCK input!`);\n  }\n\n  // add inputCell to txSkeleton\n  txSkeleton = txSkeleton.update(\"inputs\", inputs => {\n    return inputs.push(inputCell);\n  });\n  const output = {\n    cellOutput: {\n      capacity: inputCell.cellOutput.capacity,\n      lock: inputCell.cellOutput.lock,\n      type: inputCell.cellOutput.type\n    },\n    data: inputCell.data\n  };\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.push(output);\n  });\n  if (since) {\n    txSkeleton = txSkeleton.update(\"inputSinces\", inputSinces => {\n      return inputSinces.set(txSkeleton.get(\"inputs\").size - 1, since);\n    });\n  }\n  txSkeleton = txSkeleton.update(\"witnesses\", witnesses => {\n    return witnesses.push(defaultWitness);\n  });\n  const template = config.SCRIPTS.OMNILOCK;\n  const secp256k1Template = config.SCRIPTS.SECP256K1_BLAKE160;\n  if (!template) {\n    throw new Error(`OMNILOCK script not defined in config!`);\n  }\n  if (!secp256k1Template) {\n    throw new Error(`SECP256K1_BLAKE160 script not defined in config!`);\n  }\n  const omnilockOutPoint = {\n    txHash: template.TX_HASH,\n    index: template.INDEX\n  };\n  const secp256k1OutPoint = {\n    txHash: secp256k1Template.TX_HASH,\n    index: secp256k1Template.INDEX\n  };\n\n  // add cell dep\n  txSkeleton = (0, _helper.addCellDep)(txSkeleton, {\n    outPoint: omnilockOutPoint,\n    depType: template.DEP_TYPE\n  });\n  txSkeleton = (0, _helper.addCellDep)(txSkeleton, {\n    outPoint: secp256k1OutPoint,\n    depType: secp256k1Template.DEP_TYPE\n  });\n\n  // add witness\n  /*\n   * Modify the skeleton, so the first witness of the fromAddress script group\n   * has a WitnessArgs construct with 85-byte zero filled values. While this\n   * is not required, it helps in transaction fee estimation.\n   */\n  const firstIndex = txSkeleton.get(\"inputs\").findIndex(input => new ScriptValue(input.cellOutput.lock, {\n    validate: false\n  }).equals(new ScriptValue(fromScript, {\n    validate: false\n  })));\n  if (firstIndex !== -1) {\n    while (firstIndex >= txSkeleton.get(\"witnesses\").size) {\n      txSkeleton = txSkeleton.update(\"witnesses\", witnesses => witnesses.push(\"0x\"));\n    }\n    let witness = txSkeleton.get(\"witnesses\").get(firstIndex);\n    const placeholderLength = (() => {\n      const identityFlag = _codec.bytes.bytify(inputCell.cellOutput.lock.args)[0];\n      switch (identityFlag) {\n        case IdentityFlagsType.IdentityFlagsSolana:\n          {\n            return ED25519_SIGNATURE_PLACEHOLDER_LENGTH;\n          }\n        case IdentityFlagsType.IdentityFlagsCkb:\n        case IdentityFlagsType.IdentityFlagsEthereum:\n        case IdentityFlagsType.IdentityFlagsBitcoin:\n          {\n            return SECP256K1_SIGNATURE_PLACEHOLDER_LENGTH;\n          }\n        default:\n          {\n            throw new Error(`Unsupported flag: ${identityFlag}, please check if the script.args is expected`);\n          }\n      }\n    })();\n    const newWitnessArgs = {\n      lock: createWitnessLockPlaceholder(placeholderLength)\n    };\n    witness = _codec.bytes.hexify(_base.blockchain.WitnessArgs.pack(newWitnessArgs));\n    txSkeleton = txSkeleton.update(\"witnesses\", witnesses => witnesses.set(firstIndex, witness));\n  }\n  return txSkeleton;\n}\nfunction createWitnessLockPlaceholder(signatureLength) {\n  const serializedLength = OmnilockWitnessLock.pack({\n    signature: new Uint8Array(signatureLength)\n  }).byteLength;\n  return _codec.bytes.hexify(new Uint8Array(serializedLength));\n}\n\n/**\n * prepare for txSkeleton signingEntries, will update txSkeleton.get(\"signingEntries\")\n *\n * @param txSkeleton\n * @param options\n */\nfunction prepareSigningEntries(txSkeleton, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  return (0, _helper.prepareSigningEntries)(txSkeleton, config, \"OMNILOCK\");\n}\nvar _default = exports.default = {\n  prepareSigningEntries,\n  setupInputCell,\n  CellCollector,\n  OmnilockWitnessLock,\n  createOmnilockScript\n};\n//# sourceMappingURL=omnilock.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createP2PKHMessageGroup = createP2PKHMessageGroup;\nvar _base = require(\"@ckb-lumos/base\");\nvar _helpers = require(\"@ckb-lumos/helpers\");\nvar _codec = require(\"@ckb-lumos/codec\");\nvar _bi = require(\"@ckb-lumos/bi\");\nfunction groupInputs(inputs, locks) {\n  const lockSet = new Set();\n  for (const lock of locks) {\n    const scriptHash = _base.utils.ckbHash(_base.blockchain.Script.pack(lock));\n    lockSet.add(scriptHash);\n  }\n  const groups = new Map();\n  for (let i = 0; i < inputs.length; i++) {\n    const scriptHash = _base.utils.ckbHash(_base.blockchain.Script.pack(inputs[i].cellOutput.lock));\n    if (lockSet.has(scriptHash)) {\n      if (groups.get(scriptHash) === undefined) groups.set(scriptHash, []);\n      groups.get(scriptHash).push(i);\n    }\n  }\n  return groups;\n}\nfunction calcRawTxHash(tx) {\n  const createdTx = (0, _helpers.createTransactionFromSkeleton)(tx);\n  const rawTx = {\n    cellDeps: createdTx.cellDeps,\n    headerDeps: createdTx.headerDeps,\n    inputs: createdTx.inputs,\n    outputs: createdTx.outputs,\n    outputsData: createdTx.outputsData,\n    version: createdTx.version\n  };\n  return _base.utils.ckbHash(_base.blockchain.RawTransaction.pack(rawTx));\n}\nconst defaultCkbHasher = () => {\n  const hasher = new _base.utils.CKBHasher();\n  return {\n    update: message => hasher.update(message.buffer),\n    digest: () => _codec.bytes.bytify(hasher.digestHex())\n  };\n};\nfunction resolveThunk(thunkOrValue) {\n  if (thunkOrValue instanceof Function) return thunkOrValue();\n  return thunkOrValue;\n}\n\n/**\n * Return an array of messages as well as their corresponding position indexes and locks for signing a P2PKH transaction.\n * For more details, please see:\n * https://github.com/nervosnetwork/ckb-system-scripts/wiki/How-to-sign-transaction\n *\n * @param tx TxSkeleton with all input cells' witnessArgs.lock filled with 0.\n * @param locks Locks you want to sign, e.g. you don't need to sign ACP cells.\n * @param hasher Message hasher, defaults to CKB blake2b hasher. Check\n * https://github.com/nervosnetwork/ckb-system-scripts/blob/e975e8b7d5231fdb1c537b830dd934b305492417/c/secp256k1_blake160_sighash_all.c#L22-L28 for more.\n * @returns An array of Group containing: lock of the input cell you need to sign, message for signing, witness index of this message (first index of the input cell with this lock).\n */\nfunction createP2PKHMessageGroup(tx, locks, {\n  hasher: thunkableHasher = defaultCkbHasher\n} = {}) {\n  const groups = groupInputs(tx.inputs.toArray(), locks);\n  const rawTxHash = calcRawTxHash(tx);\n  if (locks.length > 1 && !(thunkableHasher instanceof Function)) {\n    // If we have multiple locks to group, we need the hasher to be thunk so that in the second group we can get another new hasher.\n    throw new Error(\"Must provide hasher producer when you have multiple locks to group.\");\n  }\n  const messageGroup = [];\n  for (const group of groups.keys()) {\n    const messageHasher = resolveThunk(thunkableHasher);\n    const indexes = groups.get(group);\n    const firstIndex = indexes[0];\n    const firstWitness = tx.witnesses.get(firstIndex);\n    if (firstWitness === undefined) {\n      throw new Error(\"Please fill witnesses with 0 first!\");\n    }\n    messageHasher.update(_codec.bytes.bytify(rawTxHash));\n    const lengthBuffer = new ArrayBuffer(8);\n    const view = new DataView(lengthBuffer);\n    const witnessHexString = _bi.BI.from(_codec.bytes.bytify(firstWitness).length).toString(16);\n    if (witnessHexString.length <= 8) {\n      view.setUint32(0, Number(\"0x\" + witnessHexString), true);\n      view.setUint32(4, Number(\"0x\" + \"00000000\"), true);\n    }\n    if (witnessHexString.length > 8 && witnessHexString.length <= 16) {\n      view.setUint32(0, Number(\"0x\" + witnessHexString.slice(-8)), true);\n      view.setUint32(4, Number(\"0x\" + witnessHexString.slice(0, -8)), true);\n    }\n    messageHasher.update(new Uint8Array(lengthBuffer));\n    messageHasher.update(_codec.bytes.bytify(firstWitness));\n    for (let i = 1; i < indexes.length; i++) {\n      const witness = tx.witnesses.get(indexes[i]);\n      messageHasher.update(new Uint8Array(lengthBuffer));\n      messageHasher.update(_codec.bytes.bytify(witness));\n    }\n    for (let i = tx.inputs.toArray().length; i < tx.witnesses.toArray().length; i++) {\n      const witness = tx.witnesses.get(i);\n      messageHasher.update(new Uint8Array(lengthBuffer));\n      messageHasher.update(_codec.bytes.bytify(witness));\n    }\n    const digested = messageHasher.digest();\n    const g = {\n      index: firstIndex,\n      lock: tx.inputs.get(firstIndex).cellOutput.lock,\n      message: \"0x\" + Array.prototype.map.call(digested, x => (\"00\" + x.toString(16)).slice(-2)).join(\"\")\n    };\n    messageGroup.push(g);\n  }\n  return messageGroup;\n}\n//# sourceMappingURL=p2pkh.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.CellCollector = void 0;\nexports.injectCapacity = injectCapacity;\nexports.payFee = payFee;\nexports.prepareSigningEntries = prepareSigningEntries;\nexports.setupInputCell = setupInputCell;\nexports.transfer = transfer;\nexports.transferCompatible = transferCompatible;\nvar _immutable = require(\"immutable\");\nvar _helpers = require(\"@ckb-lumos/helpers\");\nvar _codec = require(\"@ckb-lumos/codec\");\nvar _base = require(\"@ckb-lumos/base\");\nvar _configManager = require(\"@ckb-lumos/config-manager\");\nvar _helper = require(\"./helper\");\nvar _from_info = require(\"./from_info\");\nvar _bi = require(\"@ckb-lumos/bi\");\nconst {\n  ScriptValue\n} = _base.values;\nconst CellCollector = exports.CellCollector = class CellCollector {\n  constructor(fromInfo, cellProvider, {\n    config = undefined,\n    queryOptions = {}\n  } = {}) {\n    if (!cellProvider) {\n      throw new Error(`Cell provider is missing!`);\n    }\n    config = config || (0, _configManager.getConfig)();\n    this.fromScript = (0, _from_info.parseFromInfo)(fromInfo, {\n      config\n    }).fromScript;\n    this.config = config;\n    queryOptions = {\n      ...queryOptions,\n      lock: this.fromScript,\n      type: queryOptions.type || \"empty\"\n    };\n    this.cellCollector = cellProvider.collector(queryOptions);\n  }\n  async *collect() {\n    if (!(0, _helper.isSecp256k1Blake160Script)(this.fromScript, this.config)) {\n      return;\n    }\n    for await (const inputCell of this.cellCollector.collect()) {\n      yield inputCell;\n    }\n  }\n};\n\n/**\n * Setup input cell infos, such as cell deps and witnesses.\n *\n * @param txSkeleton\n * @param inputCell\n * @param _fromInfo\n * @param options\n */\nasync function setupInputCell(txSkeleton, inputCell, _fromInfo, {\n  config = undefined,\n  defaultWitness = \"0x\",\n  since = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  const fromScript = inputCell.cellOutput.lock;\n  if (!(0, _helper.isSecp256k1Blake160Script)(fromScript, config)) {\n    throw new Error(`Not SECP256K1_BLAKE160 input!`);\n  }\n\n  // add inputCell to txSkeleton\n  txSkeleton = txSkeleton.update(\"inputs\", inputs => {\n    return inputs.push(inputCell);\n  });\n  const output = {\n    cellOutput: {\n      capacity: inputCell.cellOutput.capacity,\n      lock: inputCell.cellOutput.lock,\n      type: inputCell.cellOutput.type\n    },\n    data: inputCell.data\n  };\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.push(output);\n  });\n  if (since) {\n    txSkeleton = txSkeleton.update(\"inputSinces\", inputSinces => {\n      return inputSinces.set(txSkeleton.get(\"inputs\").size - 1, since);\n    });\n  }\n  txSkeleton = txSkeleton.update(\"witnesses\", witnesses => {\n    return witnesses.push(defaultWitness);\n  });\n  const template = config.SCRIPTS.SECP256K1_BLAKE160;\n  if (!template) {\n    throw new Error(`SECP256K1_BLAKE160 script not defined in config!`);\n  }\n  const scriptOutPoint = {\n    txHash: template.TX_HASH,\n    index: template.INDEX\n  };\n\n  // add cell dep\n  txSkeleton = (0, _helper.addCellDep)(txSkeleton, {\n    outPoint: scriptOutPoint,\n    depType: template.DEP_TYPE\n  });\n\n  // add witness\n  /*\n   * Modify the skeleton, so the first witness of the fromAddress script group\n   * has a WitnessArgs construct with 65-byte zero filled values. While this\n   * is not required, it helps in transaction fee estimation.\n   */\n  const firstIndex = txSkeleton.get(\"inputs\").findIndex(input => new ScriptValue(input.cellOutput.lock, {\n    validate: false\n  }).equals(new ScriptValue(fromScript, {\n    validate: false\n  })));\n  if (firstIndex !== -1) {\n    while (firstIndex >= txSkeleton.get(\"witnesses\").size) {\n      txSkeleton = txSkeleton.update(\"witnesses\", witnesses => witnesses.push(\"0x\"));\n    }\n    let witness = txSkeleton.get(\"witnesses\").get(firstIndex);\n    const newWitnessArgs = {\n      /* 65-byte zeros in hex */\n      lock: _helper.SECP_SIGNATURE_PLACEHOLDER\n    };\n    if (witness !== \"0x\") {\n      const witnessArgs = _base.blockchain.WitnessArgs.unpack(_codec.bytes.bytify(witness));\n      const lock = witnessArgs.lock;\n      if (!!lock && !!newWitnessArgs.lock && !_codec.bytes.equal(lock, newWitnessArgs.lock)) {\n        throw new Error(\"Lock field in first witness is set aside for signature!\");\n      }\n      const inputType = witnessArgs.inputType;\n      if (inputType) {\n        newWitnessArgs.inputType = inputType;\n      }\n      const outputType = witnessArgs.outputType;\n      if (outputType) {\n        newWitnessArgs.outputType = outputType;\n      }\n    }\n    witness = _codec.bytes.hexify(_base.blockchain.WitnessArgs.pack(newWitnessArgs));\n    txSkeleton = txSkeleton.update(\"witnesses\", witnesses => witnesses.set(firstIndex, witness));\n  }\n  return txSkeleton;\n}\n/**\n * transfer capacity from secp256k1_blake160 script cells\n *\n * @param txSkeleton\n * @param fromAddress\n * @param toAddress\n * @param amount\n * @param options\n */\nasync function transfer(txSkeleton, fromAddress, toAddress, amount, {\n  config = undefined,\n  requireToAddress = true,\n  assertAmountEnough = true\n} = {}) {\n  const result = await transferCompatible(txSkeleton, fromAddress, toAddress, amount, {\n    config,\n    requireToAddress,\n    assertAmountEnough: assertAmountEnough\n  });\n  let _txSkeleton;\n  let _amount;\n  if (result instanceof Array) {\n    _txSkeleton = result[0];\n    _amount = BigInt(result[1].toString());\n    return [_txSkeleton, _amount];\n  } else {\n    _txSkeleton = result;\n    return _txSkeleton;\n  }\n}\n/**\n * transfer capacity from secp256k1_blake160 script cells\n *\n * @param txSkeleton\n * @param fromAddress\n * @param toAddress\n * @param amount\n * @param options\n */\nasync function transferCompatible(txSkeleton, fromAddress, toAddress, amount, {\n  config = undefined,\n  requireToAddress = true,\n  assertAmountEnough = true\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  const template = config.SCRIPTS.SECP256K1_BLAKE160;\n  if (!template) {\n    throw new Error(\"Provided config does not have SECP256K1_BLAKE160 script setup!\");\n  }\n  const scriptOutPoint = {\n    txHash: template.TX_HASH,\n    index: template.INDEX\n  };\n  txSkeleton = (0, _helper.addCellDep)(txSkeleton, {\n    outPoint: scriptOutPoint,\n    depType: template.DEP_TYPE\n  });\n  const fromScript = (0, _helpers.parseAddress)(fromAddress, {\n    config\n  });\n  (0, _helper.ensureScript)(fromScript, config, \"SECP256K1_BLAKE160\");\n  if (requireToAddress && !toAddress) {\n    throw new Error(\"You must provide a to address!\");\n  }\n  let _amount = _bi.BI.from(amount);\n  if (toAddress) {\n    const toScript = (0, _helpers.parseAddress)(toAddress, {\n      config\n    });\n    txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n      return outputs.push({\n        cellOutput: {\n          capacity: \"0x\" + _amount.toString(16),\n          lock: toScript,\n          type: undefined\n        },\n        data: \"0x\",\n        outPoint: undefined,\n        blockHash: undefined\n      });\n    });\n  }\n\n  /*\n   * First, check if there is any output cells that contains enough capacity\n   * for us to tinker with.\n   *\n   * TODO: the solution right now won't cover all cases, some outputs before the\n   * last output might still be tinkerable, right now we are working on the\n   * simple solution, later we can change this for more optimizations.\n   */\n  const lastFreezedOutput = txSkeleton.get(\"fixedEntries\").filter(({\n    field\n  }) => field === \"outputs\").maxBy(({\n    index\n  }) => index);\n  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;\n  for (; i < txSkeleton.get(\"outputs\").size && _amount.gt(0); i++) {\n    const output = txSkeleton.get(\"outputs\").get(i);\n    if (new ScriptValue(output.cellOutput.lock, {\n      validate: false\n    }).equals(new ScriptValue(fromScript, {\n      validate: false\n    }))) {\n      const cellCapacity = _bi.BI.from(output.cellOutput.capacity);\n      let deductCapacity;\n      if (_amount.gte(cellCapacity)) {\n        deductCapacity = cellCapacity;\n      } else {\n        deductCapacity = cellCapacity.sub((0, _helpers.minimalCellCapacityCompatible)(output));\n        if (deductCapacity.gt(_amount)) {\n          deductCapacity = _amount;\n        }\n      }\n      _amount = _amount.sub(deductCapacity);\n      output.cellOutput.capacity = \"0x\" + cellCapacity.sub(deductCapacity).toString(16);\n    }\n  }\n  // Remove all output cells with capacity equal to 0\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.filter(output => !_bi.BI.from(output.cellOutput.capacity).eq(0));\n  });\n  /*\n   * Collect and add new input cells so as to prepare remaining capacities.\n   */\n  if (_amount.gt(0)) {\n    const cellProvider = txSkeleton.get(\"cellProvider\");\n    if (!cellProvider) {\n      throw new Error(\"Cell provider is missing!\");\n    }\n    const cellCollector = cellProvider.collector({\n      lock: fromScript\n    });\n    const changeCell = {\n      cellOutput: {\n        capacity: \"0x0\",\n        lock: fromScript,\n        type: undefined\n      },\n      data: \"0x\",\n      outPoint: undefined,\n      blockHash: undefined\n    };\n    let changeCapacity = _bi.BI.from(0);\n    let previousInputs = (0, _immutable.Set)();\n    for (const input of txSkeleton.get(\"inputs\")) {\n      previousInputs = previousInputs.add(`${input.outPoint.txHash}_${input.outPoint.index}`);\n    }\n    for await (const inputCell of cellCollector.collect()) {\n      // skip inputs already exists in txSkeleton.inputs\n      if (previousInputs.has(`${inputCell.outPoint.txHash}_${inputCell.outPoint.index}`)) {\n        continue;\n      }\n      txSkeleton = txSkeleton.update(\"inputs\", inputs => inputs.push(inputCell));\n      txSkeleton = txSkeleton.update(\"witnesses\", witnesses => witnesses.push(\"0x\"));\n      const inputCapacity = _bi.BI.from(inputCell.cellOutput.capacity);\n      let deductCapacity = inputCapacity;\n      if (deductCapacity.gt(_amount)) {\n        deductCapacity = _amount;\n      }\n      _amount = _amount.sub(deductCapacity);\n      changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);\n      if (_amount.eq(0) && (changeCapacity.eq(0) || changeCapacity.gt((0, _helpers.minimalCellCapacityCompatible)(changeCell)))) {\n        break;\n      }\n    }\n    if (changeCapacity.gt(0)) {\n      changeCell.cellOutput.capacity = \"0x\" + changeCapacity.toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", outputs => outputs.push(changeCell));\n    }\n  }\n  if (_amount.gt(0) && assertAmountEnough) {\n    throw new Error(\"Not enough capacity in from address!\");\n  }\n  /*\n   * Modify the skeleton, so the first witness of the fromAddress script group\n   * has a WitnessArgs construct with 65-byte zero filled values. While this\n   * is not required, it helps in transaction fee estimation.\n   */\n  const firstIndex = txSkeleton.get(\"inputs\").findIndex(input => new ScriptValue(input.cellOutput.lock, {\n    validate: false\n  }).equals(new ScriptValue(fromScript, {\n    validate: false\n  })));\n  if (firstIndex !== -1) {\n    while (firstIndex >= txSkeleton.get(\"witnesses\").size) {\n      txSkeleton = txSkeleton.update(\"witnesses\", witnesses => witnesses.push(\"0x\"));\n    }\n    let witness = txSkeleton.get(\"witnesses\").get(firstIndex);\n    const newWitnessArgs = {\n      /* 65-byte zeros in hex */\n      lock: _helper.SECP_SIGNATURE_PLACEHOLDER\n    };\n    if (witness !== \"0x\") {\n      const witnessArgs = _base.blockchain.WitnessArgs.unpack(_codec.bytes.bytify(witness));\n      const lock = witnessArgs.lock;\n      if (!!lock && !!newWitnessArgs.lock && !_codec.bytes.equal(lock, newWitnessArgs.lock)) {\n        throw new Error(\"Lock field in first witness is set aside for signature!\");\n      }\n      const inputType = witnessArgs.inputType;\n      if (inputType) {\n        newWitnessArgs.inputType = inputType;\n      }\n      const outputType = witnessArgs.outputType;\n      if (outputType) {\n        newWitnessArgs.outputType = outputType;\n      }\n    }\n    witness = _codec.bytes.hexify(_base.blockchain.WitnessArgs.pack(newWitnessArgs));\n    txSkeleton = txSkeleton.update(\"witnesses\", witnesses => witnesses.set(firstIndex, witness));\n  }\n  if (!assertAmountEnough) {\n    return [txSkeleton, _bi.BI.from(_amount)];\n  }\n  return txSkeleton;\n}\n\n/**\n * pay fee by secp256k1_blake160 script cells\n *\n * @param txSkeleton\n * @param fromAddress\n * @param amount fee in shannon\n * @param options\n */\nasync function payFee(txSkeleton, fromAddress, amount, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  return await transferCompatible(txSkeleton, fromAddress, null, amount, {\n    config,\n    requireToAddress: false\n  });\n}\n\n/**\n * Inject capacity from `fromAddress` to target output.\n *\n * @param txSkeleton\n * @param outputIndex\n * @param fromAddress\n * @param options\n */\nasync function injectCapacity(txSkeleton, outputIndex, fromAddress, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  if (outputIndex >= txSkeleton.get(\"outputs\").size) {\n    throw new Error(\"Invalid output index!\");\n  }\n  const capacity = _bi.BI.from(txSkeleton.get(\"outputs\").get(outputIndex).cellOutput.capacity);\n  return await transferCompatible(txSkeleton, fromAddress, null, _bi.BI.from(capacity), {\n    config,\n    requireToAddress: false\n  });\n}\n\n/**\n * prepare for txSkeleton signingEntries, will update txSkeleton.get(\"signingEntries\")\n *\n * @param txSkeleton\n * @param options\n */\nfunction prepareSigningEntries(txSkeleton, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  return (0, _helper.prepareSigningEntries)(txSkeleton, config, \"SECP256K1_BLAKE160\");\n}\nvar _default = exports.default = {\n  transfer,\n  transferCompatible,\n  payFee,\n  prepareSigningEntries,\n  injectCapacity,\n  setupInputCell,\n  CellCollector\n};\n//# sourceMappingURL=secp256k1_blake160.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.CellCollector = void 0;\nexports.injectCapacity = injectCapacity;\nObject.defineProperty(exports, \"multisigArgs\", {\n  enumerable: true,\n  get: function () {\n    return _from_info.multisigArgs;\n  }\n});\nexports.payFee = payFee;\nexports.prepareSigningEntries = prepareSigningEntries;\nObject.defineProperty(exports, \"serializeMultisigScript\", {\n  enumerable: true,\n  get: function () {\n    return _from_info.serializeMultisigScript;\n  }\n});\nexports.setupInputCell = setupInputCell;\nexports.transfer = transfer;\nexports.transferCompatible = transferCompatible;\nvar _helpers = require(\"@ckb-lumos/helpers\");\nvar _codec = require(\"@ckb-lumos/codec\");\nvar _base = require(\"@ckb-lumos/base\");\nvar _configManager = require(\"@ckb-lumos/config-manager\");\nvar _immutable = require(\"immutable\");\nvar _helper = require(\"./helper\");\nvar _from_info = require(\"./from_info\");\nvar _bi = require(\"@ckb-lumos/bi\");\nconst {\n  ScriptValue\n} = _base.values;\nconst CellCollector = exports.CellCollector = class CellCollector {\n  constructor(fromInfo, cellProvider, {\n    config = undefined,\n    queryOptions = {}\n  } = {}) {\n    if (!cellProvider) {\n      throw new Error(`Cell provider is missing!`);\n    }\n    config = config || (0, _configManager.getConfig)();\n    const result = (0, _from_info.parseFromInfo)(fromInfo, {\n      config\n    });\n    this.fromScript = result.fromScript;\n    this.multisigScript = result.multisigScript;\n    this.config = config;\n    queryOptions = {\n      ...queryOptions,\n      lock: this.fromScript,\n      type: queryOptions.type || \"empty\"\n    };\n    this.cellCollector = cellProvider.collector(queryOptions);\n  }\n  async *collect() {\n    if (!(0, _helper.isSecp256k1Blake160MultisigScript)(this.fromScript, this.config)) {\n      return;\n    }\n    for await (const inputCell of this.cellCollector.collect()) {\n      yield inputCell;\n    }\n  }\n};\n\n/**\n * Setup input cell infos, such as cell deps and witnesses.\n *\n * @param txSkeleton\n * @param inputCell\n * @param fromInfo\n * @param options\n */\nasync function setupInputCell(txSkeleton, inputCell, fromInfo, {\n  config = undefined,\n  defaultWitness = \"0x\",\n  since = undefined,\n  requireMultisigScript = true\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  if (requireMultisigScript && typeof fromInfo !== \"object\") {\n    throw new Error(\"`fromInfo` must be MultisigScript format!\");\n  }\n  const fromScript = inputCell.cellOutput.lock;\n  if (fromInfo) {\n    const parsedFromScript = (0, _from_info.parseFromInfo)(fromInfo, {\n      config\n    }).fromScript;\n    if (!new ScriptValue(parsedFromScript, {\n      validate: false\n    }).equals(new ScriptValue(fromScript, {\n      validate: false\n    }))) {\n      throw new Error(\"`fromInfo` not match to input lock!\");\n    }\n  }\n  if (!(0, _helper.isSecp256k1Blake160MultisigScript)(fromScript, config)) {\n    throw new Error(`Not SECP256K1_BLAKE160_MULTISIG input!`);\n  }\n\n  // add inputCell to txSkeleton\n  txSkeleton = txSkeleton.update(\"inputs\", inputs => {\n    return inputs.push(inputCell);\n  });\n  if (since) {\n    txSkeleton = txSkeleton.update(\"inputSinces\", inputSinces => {\n      return inputSinces.set(txSkeleton.get(\"inputs\").size - 1, since);\n    });\n  }\n  txSkeleton = txSkeleton.update(\"witnesses\", witnesses => {\n    return witnesses.push(defaultWitness);\n  });\n  const outputCell = {\n    cellOutput: {\n      capacity: inputCell.cellOutput.capacity,\n      lock: inputCell.cellOutput.lock,\n      type: inputCell.cellOutput.type\n    },\n    data: inputCell.data\n  };\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.push(outputCell);\n  });\n  const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;\n  if (!template) {\n    throw new Error(`SECP256K1_BLAKE160_MULTISIG script not defined in config!`);\n  }\n  const scriptOutPoint = {\n    txHash: template.TX_HASH,\n    index: template.INDEX\n  };\n\n  // add cell dep\n  txSkeleton = (0, _helper.addCellDep)(txSkeleton, {\n    outPoint: scriptOutPoint,\n    depType: template.DEP_TYPE\n  });\n\n  // add witness\n  const firstIndex = txSkeleton.get(\"inputs\").findIndex(input => new ScriptValue(input.cellOutput.lock, {\n    validate: false\n  }).equals(new ScriptValue(fromScript, {\n    validate: false\n  })));\n  if (firstIndex !== -1) {\n    while (firstIndex >= txSkeleton.get(\"witnesses\").size) {\n      txSkeleton = txSkeleton.update(\"witnesses\", witnesses => witnesses.push(\"0x\"));\n    }\n    const firstIndexWitness = txSkeleton.get(\"witnesses\").get(firstIndex);\n    // If never prepared witness of this lock script before, should using fromInfo(MultisigScript) to update witness\n    if (firstIndexWitness === \"0x\" && typeof fromInfo !== \"object\") {\n      throw new Error(\"`fromInfo` must be MultisigScript format!\");\n    }\n\n    // if using MultisigScript, check witnesses\n    if (typeof fromInfo === \"object\") {\n      const multisigScript = (0, _from_info.parseFromInfo)(fromInfo, {\n        config\n      }).multisigScript;\n      let witness = txSkeleton.get(\"witnesses\").get(firstIndex);\n      const newWitnessArgs = {\n        lock: \"0x\" + multisigScript.slice(2) + _helper.SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(fromInfo.M)\n      };\n      if (witness !== \"0x\") {\n        const witnessArgs = _base.blockchain.WitnessArgs.unpack(_codec.bytes.bytify(witness));\n        const lock = witnessArgs.lock;\n        if (!!lock && !!newWitnessArgs.lock && !_codec.bytes.equal(lock, newWitnessArgs.lock)) {\n          throw new Error(\"Lock field in first witness is set aside for signature!\");\n        }\n        const inputType = witnessArgs.inputType;\n        if (inputType) {\n          newWitnessArgs.inputType = inputType;\n        }\n        const outputType = witnessArgs.outputType;\n        if (outputType) {\n          newWitnessArgs.outputType = outputType;\n        }\n      }\n      witness = _codec.bytes.hexify(_base.blockchain.WitnessArgs.pack(newWitnessArgs));\n      txSkeleton = txSkeleton.update(\"witnesses\", witnesses => witnesses.set(firstIndex, witness));\n    }\n  }\n  return txSkeleton;\n}\n/**\n * transfer capacity from multisig script cells\n *\n * @param txSkeleton\n * @param fromInfo fromAddress or fromMultisigScript, if this address new to txSkeleton inputs, must use fromMultisigScript\n * @param toAddress\n * @param amount transfer CKB capacity in shannon.\n * @param options\n */\nasync function transfer(txSkeleton, fromInfo, toAddress, amount, {\n  config = undefined,\n  requireToAddress = true,\n  assertAmountEnough = true\n} = {}) {\n  const result = await transferCompatible(txSkeleton, fromInfo, toAddress, amount, {\n    config,\n    requireToAddress,\n    assertAmountEnough: assertAmountEnough\n  });\n  let _txSkeleton;\n  let _amount;\n  if (result instanceof Array) {\n    _txSkeleton = result[0];\n    _amount = BigInt(result[1].toString());\n    return [_txSkeleton, _amount];\n  } else {\n    _txSkeleton = result;\n    return _txSkeleton;\n  }\n}\nasync function transferCompatible(txSkeleton, fromInfo, toAddress, amount, {\n  config = undefined,\n  requireToAddress = true,\n  assertAmountEnough = true\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;\n  if (!template) {\n    throw new Error(\"Provided config does not have SECP256K1_BLAKE16_MULTISIG script setup!\");\n  }\n  const scriptOutPoint = {\n    txHash: template.TX_HASH,\n    index: template.INDEX\n  };\n  txSkeleton = (0, _helper.addCellDep)(txSkeleton, {\n    outPoint: scriptOutPoint,\n    depType: template.DEP_TYPE\n  });\n  const {\n    fromScript,\n    multisigScript\n  } = (0, _from_info.parseFromInfo)(fromInfo, {\n    config\n  });\n  (0, _helper.ensureScript)(fromScript, config, \"SECP256K1_BLAKE160_MULTISIG\");\n  const noMultisigBefore = !txSkeleton.get(\"inputs\").find(i => {\n    return new ScriptValue(i.cellOutput.lock, {\n      validate: false\n    }).equals(new ScriptValue(fromScript, {\n      validate: false\n    }));\n  });\n  if (noMultisigBefore && fromInfo === \"string\") {\n    throw new Error(\"MultisigScript is required for witness!\");\n  }\n  if (requireToAddress && !toAddress) {\n    throw new Error(\"You must provide a to address!\");\n  }\n  let _amount = amount ? _bi.BI.from(amount) : _bi.BI.from(0);\n  if (toAddress) {\n    const toScript = (0, _helpers.parseAddress)(toAddress, {\n      config\n    });\n    txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n      return outputs.push({\n        cellOutput: {\n          capacity: \"0x\" + _amount.toString(16),\n          lock: toScript,\n          type: undefined\n        },\n        data: \"0x\",\n        outPoint: undefined,\n        blockHash: undefined\n      });\n    });\n  }\n  const lastFreezedOutput = txSkeleton.get(\"fixedEntries\").filter(({\n    field\n  }) => field === \"outputs\").maxBy(({\n    index\n  }) => index);\n  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;\n  for (; i < txSkeleton.get(\"outputs\").size && _amount.gt(0); ++i) {\n    const output = txSkeleton.get(\"outputs\").get(i);\n    if (new ScriptValue(output.cellOutput.lock, {\n      validate: false\n    }).equals(new ScriptValue(fromScript, {\n      validate: false\n    }))) {\n      const cellCapacity = _bi.BI.from(output.cellOutput.capacity);\n      let deductCapacity;\n      if (_amount.gte(cellCapacity)) {\n        deductCapacity = cellCapacity;\n      } else {\n        deductCapacity = cellCapacity.sub((0, _helpers.minimalCellCapacityCompatible)(output));\n        if (deductCapacity.gt(_amount)) {\n          deductCapacity = _amount;\n        }\n      }\n      _amount = _amount.sub(deductCapacity);\n      output.cellOutput.capacity = \"0x\" + cellCapacity.sub(deductCapacity).toString(16);\n    }\n  }\n  // remove all output cells with capacity equal to 0\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.filter(output => !_bi.BI.from(output.cellOutput.capacity).eq(0));\n  });\n  /*\n   * Collect and add new input cells so as to prepare remaining capacities.\n   */\n  if (_amount.gt(0)) {\n    const cellProvider = txSkeleton.get(\"cellProvider\");\n    if (!cellProvider) {\n      throw new Error(\"cell provider is missing!\");\n    }\n    // TODO: ignore locktime now.\n    const cellCollector = cellProvider.collector({\n      lock: fromScript\n    });\n    const changeCell = {\n      cellOutput: {\n        capacity: \"0x0\",\n        lock: fromScript,\n        type: undefined\n      },\n      data: \"0x\",\n      outPoint: undefined,\n      blockHash: undefined\n    };\n    let changeCapacity = _bi.BI.from(0);\n    let previousInputs = (0, _immutable.Set)();\n    for (const input of txSkeleton.get(\"inputs\")) {\n      previousInputs = previousInputs.add(`${input.outPoint.txHash}_${input.outPoint.index}`);\n    }\n    for await (const inputCell of cellCollector.collect()) {\n      // skip inputs already exists in txSkeleton.inputs\n      if (previousInputs.has(`${inputCell.outPoint.txHash}_${inputCell.outPoint.index}`)) {\n        continue;\n      }\n      txSkeleton = txSkeleton.update(\"inputs\", inputs => inputs.push(inputCell));\n      txSkeleton = txSkeleton.update(\"witnesses\", witnesses => witnesses.push(\"0x\"));\n      const inputCapacity = _bi.BI.from(inputCell.cellOutput.capacity);\n      let deductCapacity = inputCapacity;\n      if (deductCapacity.gt(_amount)) {\n        deductCapacity = _amount;\n      }\n      _amount = _amount.sub(deductCapacity);\n      changeCapacity = changeCapacity.add(inputCapacity.sub(deductCapacity));\n      if (_amount.eq(0) && (changeCapacity.eq(0) || changeCapacity.gt((0, _helpers.minimalCellCapacityCompatible)(changeCell)))) {\n        break;\n      }\n    }\n    if (changeCapacity.gt(0)) {\n      changeCell.cellOutput.capacity = \"0x\" + changeCapacity.toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", outputs => outputs.push(changeCell));\n    }\n  }\n  if (_amount.gt(0) && assertAmountEnough) {\n    throw new Error(\"Not enough capacity in from address!\");\n  }\n  const firstIndex = txSkeleton.get(\"inputs\").findIndex(input => new ScriptValue(input.cellOutput.lock, {\n    validate: false\n  }).equals(new ScriptValue(fromScript, {\n    validate: false\n  })));\n  if (firstIndex !== -1) {\n    while (_bi.BI.from(firstIndex).gte(txSkeleton.get(\"witnesses\").size)) {\n      txSkeleton = txSkeleton.update(\"witnesses\", witnesses => witnesses.push(\"0x\"));\n    }\n\n    // if using MultisigScript, check witnesses\n    if (noMultisigBefore || typeof fromInfo !== \"string\") {\n      let witness = txSkeleton.get(\"witnesses\").get(firstIndex);\n      const newWitnessArgs = {\n        lock: \"0x\" + multisigScript.slice(2) + _helper.SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(fromInfo.M)\n      };\n      if (witness !== \"0x\") {\n        const witnessArgs = _base.blockchain.WitnessArgs.unpack(_codec.bytes.bytify(witness));\n        const lock = witnessArgs.lock;\n        if (!!lock && !!newWitnessArgs.lock && !_codec.bytes.equal(lock, newWitnessArgs.lock)) {\n          throw new Error(\"Lock field in first witness is set aside for signature!\");\n        }\n        const inputType = witnessArgs.inputType;\n        if (inputType) {\n          newWitnessArgs.inputType = inputType;\n        }\n        const outputType = witnessArgs.outputType;\n        if (outputType) {\n          newWitnessArgs.outputType = outputType;\n        }\n      }\n      witness = _codec.bytes.hexify(_base.blockchain.WitnessArgs.pack(newWitnessArgs));\n      txSkeleton = txSkeleton.update(\"witnesses\", witnesses => witnesses.set(firstIndex, witness));\n    }\n  }\n  if (!assertAmountEnough) {\n    return [txSkeleton, _bi.BI.from(_amount)];\n  }\n  return txSkeleton;\n}\n\n/**\n * pay fee by multisig script cells\n *\n * @param txSkeleton\n * @param fromInfo\n * @param amount fee in shannon\n * @param options\n */\nasync function payFee(txSkeleton, fromInfo, amount, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  return transferCompatible(txSkeleton, fromInfo, undefined, amount, {\n    config,\n    requireToAddress: false\n  });\n}\n\n/**\n * Inject capacity from `fromInfo` to target output.\n *\n * @param txSkeleton\n * @param outputIndex\n * @param fromInfo\n * @param options\n */\nasync function injectCapacity(txSkeleton, outputIndex, fromInfo, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  if (outputIndex >= txSkeleton.get(\"outputs\").size) {\n    throw new Error(\"Invalid output index!\");\n  }\n  const capacity = _bi.BI.from(txSkeleton.get(\"outputs\").get(outputIndex).cellOutput.capacity);\n  return transferCompatible(txSkeleton, fromInfo, undefined, capacity, {\n    config,\n    requireToAddress: false\n  });\n}\n\n/**\n * prepare for txSkeleton signingEntries, will update txSkeleton.get(\"signingEntries\")\n *\n * @param txSkeleton\n * @param options\n */\nfunction prepareSigningEntries(txSkeleton, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  return (0, _helper.prepareSigningEntries)(txSkeleton, config, \"SECP256K1_BLAKE160_MULTISIG\");\n}\nvar _default = exports.default = {\n  transfer,\n  transferCompatible,\n  payFee,\n  prepareSigningEntries,\n  serializeMultisigScript: _from_info.serializeMultisigScript,\n  multisigArgs: _from_info.multisigArgs,\n  injectCapacity,\n  setupInputCell,\n  CellCollector\n};\n//# sourceMappingURL=secp256k1_blake160_multisig.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.issueToken = issueToken;\nexports.ownerForSudt = ownerForSudt;\nexports.packAmount = packAmount;\nexports.transfer = transfer;\nexports.unpackAmount = unpackAmount;\nvar _helper = require(\"./helper\");\nvar _base = require(\"@ckb-lumos/base\");\nvar _secp256k1_blake160_multisig = _interopRequireDefault(require(\"./secp256k1_blake160_multisig\"));\nvar _from_info = require(\"./from_info\");\nvar _common = _interopRequireDefault(require(\"./common\"));\nvar _helpers = require(\"@ckb-lumos/helpers\");\nvar _immutable = require(\"immutable\");\nvar _configManager = require(\"@ckb-lumos/config-manager\");\nvar _locktime_pool = require(\"./locktime_pool\");\nvar _anyone_can_pay = _interopRequireWildcard(require(\"./anyone_can_pay\"));\nvar _secp256k1_blake = _interopRequireDefault(require(\"./secp256k1_blake160\"));\nvar _bi = require(\"@ckb-lumos/bi\");\nvar _codec = require(\"@ckb-lumos/codec\");\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nconst {\n  computeScriptHash\n} = _base.utils;\nconst {\n  ScriptValue\n} = _base.values;\n/**\n * Issue an sUDT cell\n *\n * @param txSkeleton\n * @param fromInfo\n * @param amount\n * @param capacity\n * @param tipHeader\n * @param options\n */\nasync function issueToken(txSkeleton, fromInfo, amount, capacity, tipHeader, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  const template = config.SCRIPTS.SUDT;\n  if (!template) {\n    throw new Error(\"Provided config does not have SUDT script setup!\");\n  }\n  txSkeleton = (0, _helper.addCellDep)(txSkeleton, {\n    outPoint: {\n      txHash: template.TX_HASH,\n      index: template.INDEX\n    },\n    depType: template.DEP_TYPE\n  });\n  const fromScript = (0, _from_info.parseFromInfo)(fromInfo, {\n    config\n  }).fromScript;\n  const toScript = fromScript;\n  const sudtTypeScript = {\n    codeHash: template.CODE_HASH,\n    hashType: template.HASH_TYPE,\n    args: computeScriptHash(fromScript)\n  };\n  const targetOutput = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: toScript,\n      type: sudtTypeScript\n    },\n    data: _codec.bytes.hexify(_codec.number.Uint128LE.pack(amount)),\n    outPoint: undefined,\n    blockHash: undefined\n  };\n  if (!capacity) {\n    capacity = (0, _helpers.minimalCellCapacityCompatible)(targetOutput);\n  }\n  const _capacity = _bi.BI.from(capacity);\n  targetOutput.cellOutput.capacity = \"0x\" + _capacity.toString(16);\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.push(targetOutput);\n  });\n  const outputIndex = txSkeleton.get(\"outputs\").size - 1;\n\n  // fix entry\n  txSkeleton = txSkeleton.update(\"fixedEntries\", fixedEntries => {\n    return fixedEntries.push({\n      field: \"outputs\",\n      index: outputIndex\n    });\n  });\n  txSkeleton = await _common.default.injectCapacity(txSkeleton, [fromInfo], _bi.BI.from(_bi.BI.from(targetOutput.cellOutput.capacity)), undefined, tipHeader, {\n    config\n  });\n  return txSkeleton;\n}\n\n/**\n *\n * @param txSkeleton\n * @param fromInfos\n * @param sudtToken\n * @param toAddress\n * @param amount\n * @param changeAddress if not provided, will use first fromInfo\n * @param capacity\n * @param tipHeader\n * @param options When `splitChangeCell = true` && change amount > 0 && change capacity >= minimalCellCapacity(change cell with sudt) + minimalCellCapacity(change cell without sudt), change cell will split to two change cells, one with sudt and one without.\n */\nasync function transfer(txSkeleton, fromInfos, sudtToken, toAddress, amount, changeAddress, capacity, tipHeader, {\n  config = undefined,\n  LocktimePoolCellCollector = _locktime_pool.CellCollector,\n  splitChangeCell = false\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  let _amount = _bi.BI.from(amount);\n  let _capacity = capacity ? _bi.BI.from(capacity) : undefined;\n  const SUDT_SCRIPT = config.SCRIPTS.SUDT;\n  if (!SUDT_SCRIPT) {\n    throw new Error(\"Provided config does not have SUDT script setup!\");\n  }\n  if (fromInfos.length === 0) {\n    throw new Error(\"`fromInfos` can't be empty!\");\n  }\n  if (!toAddress) {\n    throw new Error(\"You must provide a to address!\");\n  }\n  const toScript = (0, _helpers.parseAddress)(toAddress, {\n    config\n  });\n  const fromScripts = fromInfos.map(fromInfo => (0, _from_info.parseFromInfo)(fromInfo, {\n    config\n  }).fromScript);\n  const changeOutputLockScript = changeAddress ? (0, _helpers.parseAddress)(changeAddress, {\n    config\n  }) : fromScripts[0];\n  if (_amount.lte(0)) {\n    throw new Error(\"amount must be greater than 0\");\n  }\n  const sudtType = _generateSudtScript(sudtToken, config);\n  const cellProvider = txSkeleton.get(\"cellProvider\");\n  if (!cellProvider) {\n    throw new Error(\"Cell provider is missing!\");\n  }\n\n  // if toScript is an anyone-can-pay script\n  let toAddressInputCapacity = _bi.BI.from(0);\n  let toAddressInputAmount = _bi.BI.from(0);\n  if ((0, _helper.isAcpScript)(toScript, config)) {\n    const toAddressCellCollector = new _anyone_can_pay.CellCollector(toAddress, cellProvider, {\n      config,\n      queryOptions: {\n        type: sudtType,\n        data: \"any\"\n      }\n    });\n    const toAddressInput = (await toAddressCellCollector.collect().next()).value;\n    if (!toAddressInput) {\n      throw new Error(`toAddress ANYONE_CAN_PAY input not found!`);\n    }\n    txSkeleton = txSkeleton.update(\"inputs\", inputs => {\n      return inputs.push(toAddressInput);\n    });\n    txSkeleton = txSkeleton.update(\"witnesses\", witnesses => {\n      return witnesses.push(\"0x\");\n    });\n    toAddressInputCapacity = _bi.BI.from(toAddressInput.cellOutput.capacity);\n    toAddressInputAmount = unpackAmount(toAddressInput.data);\n  }\n  const targetOutput = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: toScript,\n      type: sudtType\n    },\n    data: _codec.bytes.hexify(_codec.number.Uint128LE.pack(_amount)),\n    outPoint: undefined,\n    blockHash: undefined\n  };\n  if ((0, _helper.isAcpScript)(toScript, config)) {\n    if (!_capacity) {\n      _capacity = _bi.BI.from(0);\n    }\n    targetOutput.cellOutput.capacity = \"0x\" + toAddressInputCapacity.add(_capacity).toString(16);\n    targetOutput.data = _codec.bytes.hexify(_codec.number.Uint128LE.pack(toAddressInputAmount.add(_amount)));\n  } else {\n    if (!_capacity) {\n      _capacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(targetOutput));\n    }\n    targetOutput.cellOutput.capacity = \"0x\" + _capacity.toString(16);\n  }\n\n  // collect cells with which includes sUDT info\n  txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n    return outputs.push(targetOutput);\n  });\n  txSkeleton = txSkeleton.update(\"fixedEntries\", fixedEntries => {\n    return fixedEntries.push({\n      field: \"outputs\",\n      index: txSkeleton.get(\"outputs\").size - 1\n    });\n  });\n  txSkeleton = (0, _helper.addCellDep)(txSkeleton, {\n    outPoint: {\n      txHash: SUDT_SCRIPT.TX_HASH,\n      index: SUDT_SCRIPT.INDEX\n    },\n    depType: SUDT_SCRIPT.DEP_TYPE\n  });\n\n  // collect cells\n  const changeCell = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: changeOutputLockScript,\n      type: sudtType\n    },\n    data: _codec.bytes.hexify(_codec.number.Uint128LE.pack(0)),\n    outPoint: undefined,\n    blockHash: undefined\n  };\n  const changeCellWithoutSudt = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: changeOutputLockScript,\n      type: undefined\n    },\n    data: \"0x\",\n    outPoint: undefined,\n    blockHash: undefined\n  };\n  let changeCapacity = _bi.BI.from(0);\n  let changeAmount = _bi.BI.from(0);\n  let previousInputs = (0, _immutable.Set)();\n  for (const input of txSkeleton.get(\"inputs\")) {\n    previousInputs = previousInputs.add(`${input.outPoint.txHash}_${input.outPoint.index}`);\n  }\n  let cellCollectorInfos = (0, _immutable.List)();\n  if (tipHeader) {\n    fromInfos.forEach((fromInfo, index) => {\n      const locktimePoolCellCollector = new LocktimePoolCellCollector(fromInfo, cellProvider, {\n        config,\n        tipHeader,\n        queryOptions: {\n          type: sudtType,\n          data: \"any\"\n        }\n      });\n      cellCollectorInfos = cellCollectorInfos.push({\n        cellCollector: locktimePoolCellCollector,\n        index\n      });\n    });\n  }\n  fromInfos.forEach((fromInfo, index) => {\n    const secpCollector = new _secp256k1_blake.default.CellCollector(fromInfo, cellProvider, {\n      config,\n      queryOptions: {\n        type: sudtType,\n        data: \"any\"\n      }\n    });\n    const multisigCollector = new _secp256k1_blake160_multisig.default.CellCollector(fromInfo, cellProvider, {\n      config,\n      queryOptions: {\n        type: sudtType,\n        data: \"any\"\n      }\n    });\n    const acpCollector = new _anyone_can_pay.default.CellCollector(fromInfo, cellProvider, {\n      config,\n      queryOptions: {\n        type: sudtType,\n        data: \"any\"\n      }\n    });\n    cellCollectorInfos = cellCollectorInfos.push({\n      cellCollector: secpCollector,\n      index\n    }, {\n      cellCollector: multisigCollector,\n      index\n    }, {\n      cellCollector: acpCollector,\n      index,\n      isAnyoneCanPay: true,\n      destroyable: (0, _from_info.parseFromInfo)(fromInfo, {\n        config\n      }).destroyable\n    });\n  });\n  if (tipHeader) {\n    fromInfos.forEach((fromInfo, index) => {\n      const locktimeCellCollector = new LocktimePoolCellCollector(fromInfo, cellProvider, {\n        config,\n        tipHeader\n      });\n      cellCollectorInfos = cellCollectorInfos.push({\n        cellCollector: locktimeCellCollector,\n        index\n      });\n    });\n  }\n  fromInfos.forEach((fromInfo, index) => {\n    const secpCollector = new _secp256k1_blake.default.CellCollector(fromInfo, cellProvider, {\n      config\n    });\n    const multisigCollector = new _secp256k1_blake160_multisig.default.CellCollector(fromInfo, cellProvider, {\n      config\n    });\n    const acpCollector = new _anyone_can_pay.default.CellCollector(fromInfo, cellProvider, {\n      config\n    });\n    cellCollectorInfos = cellCollectorInfos.push({\n      cellCollector: secpCollector,\n      index\n    }, {\n      cellCollector: multisigCollector,\n      index\n    }, {\n      cellCollector: acpCollector,\n      index,\n      isAnyoneCanPay: true,\n      destroyable: (0, _from_info.parseFromInfo)(fromInfo, {\n        config\n      }).destroyable\n    });\n  });\n  for (const {\n    index,\n    cellCollector,\n    isAnyoneCanPay,\n    destroyable\n  } of cellCollectorInfos) {\n    for await (const inputCell of cellCollector.collect()) {\n      // skip inputs already exists in txSkeleton.inputs\n      const key = `${inputCell.outPoint.txHash}_${inputCell.outPoint.index}`;\n      if (previousInputs.has(key)) {\n        continue;\n      }\n      previousInputs = previousInputs.add(key);\n      const fromInfo = fromInfos[index];\n      txSkeleton = await _common.default.setupInputCell(txSkeleton, inputCell, fromInfo, {\n        config\n      });\n      // remove output which added by `setupInputCell`\n      const lastOutputIndex = txSkeleton.get(\"outputs\").size - 1;\n      txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n        return outputs.remove(lastOutputIndex);\n      });\n      // remove output fixedEntry\n      const fixedEntryIndex = txSkeleton.get(\"fixedEntries\").findIndex(fixedEntry => {\n        return fixedEntry.field === \"outputs\" && fixedEntry.index === lastOutputIndex;\n      });\n      if (fixedEntryIndex >= 0) {\n        txSkeleton = txSkeleton.update(\"fixedEntries\", fixedEntries => {\n          return fixedEntries.remove(fixedEntryIndex);\n        });\n      }\n      const inputCapacity = _bi.BI.from(inputCell.cellOutput.capacity);\n      const inputAmount = inputCell.cellOutput.type ? unpackAmount(inputCell.data) : _bi.BI.from(0);\n      let deductCapacity = isAnyoneCanPay && !destroyable ? inputCapacity.sub((0, _helpers.minimalCellCapacityCompatible)(inputCell)) : inputCapacity;\n      let deductAmount = inputAmount;\n      if (deductCapacity.gt(_capacity)) {\n        deductCapacity = _bi.BI.from(_capacity);\n      }\n      _capacity = _capacity.sub(deductCapacity);\n      const currentChangeCapacity = inputCapacity.sub(deductCapacity);\n      if (!isAnyoneCanPay || isAnyoneCanPay && destroyable) {\n        changeCapacity = changeCapacity.add(currentChangeCapacity);\n      }\n      if (deductAmount.gt(_amount)) {\n        deductAmount = _amount;\n      }\n      _amount = _amount.sub(deductAmount);\n      const currentChangeAmount = inputAmount.sub(deductAmount);\n      if (!isAnyoneCanPay || isAnyoneCanPay && destroyable) {\n        changeAmount = changeAmount.add(currentChangeAmount);\n      }\n      if (isAnyoneCanPay && !destroyable) {\n        const acpChangeCell = {\n          cellOutput: {\n            capacity: \"0x\" + currentChangeCapacity.toString(16),\n            lock: inputCell.cellOutput.lock,\n            type: inputCell.cellOutput.type\n          },\n          data: inputCell.cellOutput.type ? _codec.bytes.hexify(_codec.number.Uint128LE.pack(currentChangeAmount)) : \"0x\"\n        };\n        txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n          return outputs.push(acpChangeCell);\n        });\n        if (inputCell.cellOutput.type) {\n          txSkeleton = txSkeleton.update(\"fixedEntries\", fixedEntries => {\n            return fixedEntries.push({\n              field: \"outputs\",\n              index: txSkeleton.get(\"outputs\").size - 1\n            });\n          });\n        }\n      }\n\n      // changeAmount = 0n, the change output no need to include sudt type script\n      if (_capacity.eq(0) && _amount.eq(0) && (changeCapacity.eq(0) && changeAmount.eq(0) || changeCapacity.gt((0, _helpers.minimalCellCapacityCompatible)(changeCellWithoutSudt)) && changeAmount.eq(0))) {\n        changeCell.cellOutput.type = undefined;\n        changeCell.data = \"0x\";\n        break;\n      }\n      if (_capacity.eq(0) && _amount.eq(0) && changeCapacity.gt((0, _helpers.minimalCellCapacityCompatible)(changeCellWithoutSudt)) && changeAmount.gt(0)) {\n        break;\n      }\n    }\n  }\n\n  // if change cell is an anyone-can-pay cell and exists in txSkeleton.get(\"outputs\") and not in fixedEntries\n  // 1. change lock script is acp\n  // 2. lock and type are equal to output OutputA in outputs\n  // 3. OutputA is not fixed.\n  let changeOutputIndex = -1;\n  if ((0, _helper.isAcpScript)(changeCell.cellOutput.lock, config) && (changeOutputIndex = txSkeleton.get(\"outputs\").findIndex(output => {\n    return new ScriptValue(changeCell.cellOutput.lock, {\n      validate: false\n    }).equals(new ScriptValue(output.cellOutput.lock, {\n      validate: false\n    })) && (changeAmount.eq(0) && !changeCell.cellOutput.type && !output.cellOutput.type || changeAmount.gte(0) && !!changeCell.cellOutput.type && !!output.cellOutput.type && new ScriptValue(changeCell.cellOutput.type, {\n      validate: false\n    }).equals(new ScriptValue(output.cellOutput.type, {\n      validate: false\n    })));\n  })) !== -1 && txSkeleton.get(\"fixedEntries\").findIndex(fixedEntry => {\n    return fixedEntry.field === \"output\" && fixedEntry.index === changeOutputIndex;\n  }) === -1) {\n    const originOutput = txSkeleton.get(\"outputs\").get(changeOutputIndex);\n    const clonedOutput = JSON.parse(JSON.stringify(originOutput));\n    clonedOutput.cellOutput.capacity = \"0x\" + _bi.BI.from(originOutput.cellOutput.capacity).add(changeCapacity).toString(16);\n    if (changeAmount.gt(0)) {\n      clonedOutput.data = _codec.bytes.hexify(_codec.number.Uint128LE.pack(unpackAmount(originOutput.data).add(changeAmount)));\n    }\n    const minimalChangeCellCapcaity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(changeCell));\n    const minimalChangeCellWithoutSudtCapacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(changeCellWithoutSudt));\n    let splitFlag = false;\n    if (changeAmount.gt(0) && splitChangeCell && changeCapacity.gte(minimalChangeCellCapcaity.add(minimalChangeCellWithoutSudtCapacity))) {\n      clonedOutput.cellOutput.capacity = originOutput.cellOutput.capacity;\n      changeCellWithoutSudt.cellOutput.capacity = \"0x\" + changeCapacity.toString(16);\n      splitFlag = true;\n    }\n    txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n      return outputs.set(changeOutputIndex, clonedOutput);\n    });\n    if (splitFlag) {\n      txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n        return outputs.push(changeCellWithoutSudt);\n      });\n    }\n  } else if (changeCapacity.gte((0, _helpers.minimalCellCapacityCompatible)(changeCell))) {\n    changeCell.cellOutput.capacity = \"0x\" + changeCapacity.toString(16);\n    if (changeAmount.gt(0)) {\n      changeCell.data = _codec.bytes.hexify(_codec.number.Uint128LE.pack(changeAmount));\n    }\n    const minimalChangeCellCapcaity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(changeCell));\n    const minimalChangeCellWithoutSudtCapacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(changeCellWithoutSudt));\n    let splitFlag = false;\n    if (changeAmount.gt(0) && splitChangeCell) {\n      if (changeCapacity.gte(minimalChangeCellCapcaity.add(minimalChangeCellWithoutSudtCapacity))) {\n        changeCell.cellOutput.capacity = \"0x\" + minimalChangeCellCapcaity.toString(16);\n        changeCellWithoutSudt.cellOutput.capacity = \"0x\" + changeCapacity.sub(minimalChangeCellCapcaity).toString(16);\n        splitFlag = true;\n      }\n    }\n    txSkeleton = txSkeleton.update(\"outputs\", outputs => outputs.push(changeCell));\n    if (changeAmount.gt(0)) {\n      txSkeleton = txSkeleton.update(\"fixedEntries\", fixedEntries => {\n        return fixedEntries.push({\n          field: \"outputs\",\n          index: txSkeleton.get(\"outputs\").size - 1\n        });\n      });\n    }\n    if (splitFlag) {\n      txSkeleton = txSkeleton.update(\"outputs\", outputs => {\n        return outputs.push(changeCellWithoutSudt);\n      });\n    }\n  } else if (changeAmount.gt(0) && changeCapacity.lt((0, _helpers.minimalCellCapacityCompatible)(changeCell))) {\n    throw new Error(\"Not enough capacity for change in from infos!\");\n  }\n  if (_capacity.gt(0)) {\n    throw new Error(\"Not enough capacity in from infos!\");\n  }\n  if (_amount.gt(0)) {\n    throw new Error(\"Not enough amount in from infos!\");\n  }\n  return txSkeleton;\n}\nfunction _generateSudtScript(token, config) {\n  const SUDT_SCRIPT = config.SCRIPTS.SUDT;\n  // TODO: check token is a valid hash\n  return {\n    codeHash: SUDT_SCRIPT.CODE_HASH,\n    hashType: SUDT_SCRIPT.HASH_TYPE,\n    args: token\n  };\n}\n\n/**\n * Compute sudt token by owner from info.\n *\n * @param fromInfo\n * @param options\n */\nfunction ownerForSudt(fromInfo, {\n  config = undefined\n} = {}) {\n  config = config || (0, _configManager.getConfig)();\n  const {\n    fromScript\n  } = (0, _from_info.parseFromInfo)(fromInfo, {\n    config\n  });\n  const lockHash = computeScriptHash(fromScript);\n  return lockHash;\n}\nfunction unpackAmount(data) {\n  return _codec.number.Uint128LE.unpack(_codec.bytes.bytify(data).slice(0, 16));\n}\nfunction packAmount(amount) {\n  return _codec.bytes.hexify(_codec.number.Uint128LE.pack(amount));\n}\nvar _default = exports.default = {\n  issueToken,\n  transfer,\n  ownerForSudt,\n  packAmount,\n  unpackAmount\n};\n//# sourceMappingURL=sudt.js.map","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","const basex = require('base-x')\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _paramsFormatter = require(\"../paramsFormatter\");\nvar resultFmts = _interopRequireWildcard(require(\"../resultFormatter\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nvar _default = exports.default = {\n  getTipBlockNumber: {\n    method: \"get_tip_block_number\",\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toNumber\n  },\n  getTipHeader: {\n    method: \"get_tip_header\",\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toHeader\n  },\n  getCurrentEpoch: {\n    method: \"get_current_epoch\",\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toEpoch\n  },\n  getEpochByNumber: {\n    method: \"get_epoch_by_number\",\n    paramsFormatters: [_paramsFormatter.formatter.toNumber],\n    resultFormatters: resultFmts.toEpoch\n  },\n  getBlockHash: {\n    method: \"get_block_hash\",\n    paramsFormatters: [_paramsFormatter.formatter.toNumber]\n  },\n  getBlock: {\n    method: \"get_block\",\n    paramsFormatters: [_paramsFormatter.formatter.toHash],\n    resultFormatters: resultFmts.toBlock\n  },\n  getBlockByNumber: {\n    method: \"get_block_by_number\",\n    paramsFormatters: [_paramsFormatter.formatter.toNumber],\n    resultFormatters: resultFmts.toBlock\n  },\n  getHeader: {\n    method: \"get_header\",\n    paramsFormatters: [_paramsFormatter.formatter.toHash],\n    resultFormatters: resultFmts.toHeader\n  },\n  getHeaderByNumber: {\n    method: \"get_header_by_number\",\n    paramsFormatters: [_paramsFormatter.formatter.toNumber],\n    resultFormatters: resultFmts.toHeader\n  },\n  getLiveCell: {\n    method: \"get_live_cell\",\n    paramsFormatters: [_paramsFormatter.formatter.toOutPoint],\n    resultFormatters: resultFmts.toLiveCellWithStatus\n  },\n  getTransaction: {\n    method: \"get_transaction\",\n    paramsFormatters: [_paramsFormatter.formatter.toHash],\n    resultFormatters: resultFmts.toTransactionWithStatus\n  },\n  getCellbaseOutputCapacityDetails: {\n    method: \"get_cellbase_output_capacity_details\",\n    paramsFormatters: [_paramsFormatter.formatter.toHash],\n    resultFormatters: resultFmts.toCellbaseOutputCapacityDetails\n  },\n  getBlockEconomicState: {\n    method: \"get_block_economic_state\",\n    paramsFormatters: [_paramsFormatter.formatter.toHash],\n    resultFormatters: resultFmts.toBlockEconomicState\n  },\n  getTransactionProof: {\n    method: \"get_transaction_proof\",\n    paramsFormatters: [_paramsFormatter.formatter.toArray(_paramsFormatter.formatter.toHash), _paramsFormatter.formatter.toOptional(_paramsFormatter.formatter.toHash)],\n    resultFormatters: resultFmts.toTransactionProof\n  },\n  verifyTransactionProof: {\n    method: \"verify_transaction_proof\",\n    paramsFormatters: [_paramsFormatter.formatter.toTransactionProof]\n  },\n  getConsensus: {\n    method: \"get_consensus\",\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toConsensus\n  }\n};\n//# sourceMappingURL=chain.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _paramsFormatter = require(\"../paramsFormatter\");\nvar _default = exports.default = {\n  dryRunTransaction: {\n    method: \"dry_run_transaction\",\n    paramsFormatters: [_paramsFormatter.formatter.toRawTransaction]\n  },\n  // skip _compute_transaction_hash\n\n  calculateDaoMaximumWithdraw: {\n    method: \"calculate_dao_maximum_withdraw\",\n    paramsFormatters: [_paramsFormatter.formatter.toOutPoint, _paramsFormatter.formatter.toHash]\n  }\n\n  // skip estimate_fee_rate\n\n  // skip _compute_script_hash\n};\n//# sourceMappingURL=experimental.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rpcProperties = exports.Base = void 0;\nvar _chain = _interopRequireDefault(require(\"./chain\"));\nvar _experimental = _interopRequireDefault(require(\"./experimental\"));\nvar _net = _interopRequireDefault(require(\"./net\"));\nvar _pool = _interopRequireDefault(require(\"./pool\"));\nvar _stats = _interopRequireDefault(require(\"./stats\"));\nvar _indexer = _interopRequireDefault(require(\"./indexer\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nconst rpcProperties = exports.rpcProperties = {\n  ..._chain.default,\n  ..._experimental.default,\n  ..._indexer.default,\n  // skip minerRpc\n  ..._net.default,\n  ..._pool.default,\n  ..._stats.default\n  // skip subscription\n};\n\n// prettier-ignore\n\n// prettier-ignore\n\n// prettier-ignore\n\nclass Base {\n  #rpcProperties = rpcProperties;\n  get rpcProperties() {\n    return this.#rpcProperties;\n  }\n}\nexports.Base = Base;\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _paramsFormatter = require(\"../paramsFormatter\");\nvar resultFmts = _interopRequireWildcard(require(\"../resultFormatter\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nconst schemas = {\n  getIndexerTip: {\n    method: \"get_indexer_tip\",\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toTip\n  },\n  getCells: {\n    method: \"get_cells\",\n    paramsFormatters: [_paramsFormatter.formatter.toGetCellsSearchKey, _paramsFormatter.formatter.toOrder, _paramsFormatter.formatter.toNumber, _paramsFormatter.formatter.toOptional(_paramsFormatter.formatter.toHash)],\n    resultFormatters: resultFmts.toGetCellsResult\n  },\n  getTransactions: {\n    method: \"get_transactions\",\n    paramsFormatters: [_paramsFormatter.formatter.toGetTransactionsSearchKey, _paramsFormatter.formatter.toOrder, _paramsFormatter.formatter.toNumber, _paramsFormatter.formatter.toOptional(_paramsFormatter.formatter.toHash)],\n    resultFormatters: resultFmts.toGetTransactionsResult\n  },\n  getCellsCapacity: {\n    method: \"get_cells_capacity\",\n    paramsFormatters: [_paramsFormatter.formatter.toSearchKey],\n    resultFormatters: resultFmts.toCellsCapacity\n  },\n  getBlockFilter: {\n    method: \"get_block_filter\",\n    paramsFormatters: [_paramsFormatter.formatter.toHash],\n    resultFormatters: resultFmts.toNullable(resultFmts.toBlockFilter)\n  },\n  getTransactionAndWitnessProof: {\n    method: \"get_transaction_and_witness_proof\",\n    paramsFormatters: [_paramsFormatter.formatter.toArray(_paramsFormatter.formatter.toHash), _paramsFormatter.formatter.toOptional(_paramsFormatter.formatter.toHash)],\n    resultFormatters: resultFmts.toTransactionAndWitnessProof\n  },\n  verifyTransactionAndWitnessProof: {\n    method: \"verify_transaction_and_witness_proof\",\n    paramsFormatters: [_paramsFormatter.formatter.toTransactionAndWitnessProof],\n    resultFormatters: resultFmts.toArray(resultFmts.toHash)\n  },\n  getForkBlock: {\n    method: \"get_fork_block\",\n    paramsFormatters: [_paramsFormatter.formatter.toHash, _paramsFormatter.formatter.toOptional(_paramsFormatter.formatter.toNumber)],\n    resultFormatters: resultFmts.toNullable(resultFmts.toForkBlockResult)\n  },\n  getBlockMedianTime: {\n    method: \"get_block_median_time\",\n    paramsFormatters: [_paramsFormatter.formatter.toHash],\n    resultFormatters: resultFmts.toNullable(resultFmts.toNumber)\n  },\n  estimateCycles: {\n    method: \"estimate_cycles\",\n    paramsFormatters: [_paramsFormatter.formatter.toRawTransaction],\n    resultFormatters: resultFmts.toEstimateCycles\n  },\n  getFeeRateStatistics: {\n    method: \"get_fee_rate_statistics\",\n    paramsFormatters: [_paramsFormatter.formatter.toOptional(_paramsFormatter.formatter.toNumber)],\n    resultFormatters: resultFmts.toNullable(resultFmts.toFeeRateStatistics)\n  },\n  getFeeRateStatics: {\n    method: \"get_fee_rate_statics\",\n    paramsFormatters: [_paramsFormatter.formatter.toOptional(_paramsFormatter.formatter.toNumber)],\n    resultFormatters: resultFmts.toNullable(resultFmts.toFeeRateStatistics)\n  }\n};\nvar _default = exports.default = schemas;\n//# sourceMappingURL=indexer.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _paramsFormatter = require(\"../paramsFormatter\");\nvar resultFmts = _interopRequireWildcard(require(\"../resultFormatter\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nvar _default = exports.default = {\n  localNodeInfo: {\n    method: \"local_node_info\",\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toLocalNodeInfo\n  },\n  getPeers: {\n    method: \"get_peers\",\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toPeers\n  },\n  getBannedAddresses: {\n    method: \"get_banned_addresses\",\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toBannedAddresses\n  },\n  clearBannedAddresses: {\n    method: \"clear_banned_addresses\",\n    paramsFormatters: []\n  },\n  setBan: {\n    method: \"set_ban\",\n    paramsFormatters: []\n  },\n  syncState: {\n    method: \"sync_state\",\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toSyncState\n  },\n  setNetworkActive: {\n    method: \"set_network_active\",\n    paramsFormatters: [_paramsFormatter.formatter.toBoolean]\n  },\n  addNode: {\n    method: \"add_node\",\n    paramsFormatters: []\n  },\n  removeNode: {\n    method: \"remove_node\",\n    paramsFormatters: []\n  },\n  pingPeers: {\n    method: \"ping_peers\",\n    paramsFormatters: []\n  }\n};\n//# sourceMappingURL=net.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _paramsFormatter = require(\"../paramsFormatter\");\nvar resultFmts = _interopRequireWildcard(require(\"../resultFormatter\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nvar _default = exports.default = {\n  sendTransaction: {\n    method: \"send_transaction\",\n    paramsFormatters: [_paramsFormatter.formatter.toRawTransaction, _paramsFormatter.formatter.toOutputsValidator],\n    resultFormatters: resultFmts.toHash\n  },\n  txPoolInfo: {\n    method: \"tx_pool_info\",\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toTxPoolInfo\n  },\n  clearTxPool: {\n    method: \"clear_tx_pool\",\n    paramsFormatters: []\n  },\n  getRawTxPool: {\n    method: \"get_raw_tx_pool\",\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toRawTxPool\n  }\n};\n//# sourceMappingURL=pool.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar resultFmts = _interopRequireWildcard(require(\"../resultFormatter\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nvar _default = exports.default = {\n  getBlockchainInfo: {\n    method: \"get_blockchain_info\",\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toBlockchainInfo\n  },\n  getDeploymentsInfo: {\n    method: \"get_deployments_info\",\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toDeploymentsInfo\n  }\n};\n//# sourceMappingURL=stats.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.ErrorCode = void 0;\nlet ErrorCode = exports.ErrorCode = /*#__PURE__*/function (ErrorCode) {\n  ErrorCode[ErrorCode[\"ParameterInvalid\"] = 101] = \"ParameterInvalid\";\n  ErrorCode[ErrorCode[\"IdNotMatch\"] = 201] = \"IdNotMatch\";\n  ErrorCode[ErrorCode[\"MethodNotFound\"] = 202] = \"MethodNotFound\";\n  ErrorCode[ErrorCode[\"PayloadMessage\"] = 203] = \"PayloadMessage\";\n  ErrorCode[ErrorCode[\"ResponseMessage\"] = 204] = \"ResponseMessage\";\n  return ErrorCode;\n}({});\nvar _default = exports.default = ErrorCode;\n//# sourceMappingURL=ErrorCode.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.PayloadInBatchException = exports.MethodInBatchNotFoundException = exports.IdNotMatchedInBatchException = void 0;\nvar _ErrorCode = _interopRequireDefault(require(\"./ErrorCode\"));\nvar _rpc = require(\"./rpc\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nconst ERROR_LABEL = \"Batch Request\";\nclass MethodInBatchNotFoundException extends Error {\n  code = _ErrorCode.default.MethodNotFound;\n  constructor(name) {\n    super(`[${ERROR_LABEL}]: Method ${name} is not found`);\n  }\n}\nexports.MethodInBatchNotFoundException = MethodInBatchNotFoundException;\nclass PayloadInBatchException extends Error {\n  code = _ErrorCode.default.PayloadMessage;\n  constructor(index, message) {\n    super(`[${ERROR_LABEL} ${index}]: ${message}`);\n    this.index = index;\n  }\n}\nexports.PayloadInBatchException = PayloadInBatchException;\nclass IdNotMatchedInBatchException extends _rpc.IdNotMatchException {\n  constructor(index, requestId, responseId) {\n    super(requestId, responseId);\n    this.message = `[${ERROR_LABEL} ${index}]: ${this.message}`;\n    this.index = index;\n  }\n}\nexports.IdNotMatchedInBatchException = IdNotMatchedInBatchException;\nvar _default = exports.default = {\n  MethodInBatchNotFoundException,\n  PayloadInBatchException,\n  IdNotMatchedInBatchException\n};\n//# sourceMappingURL=batch.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.StringHashTypeException = exports.PageSizeTooSmallException = exports.PageSizeTooLargeException = exports.OutputsValidatorTypeException = exports.HexStringWithout0xException = exports.BigintOrHexStringTypeException = void 0;\nvar _ErrorCode = _interopRequireDefault(require(\"./ErrorCode\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n// eslint-disable-next-line import/no-named-as-default\n\nclass PageSizeTooLargeException extends RangeError {\n  code = _ErrorCode.default.ParameterInvalid;\n  constructor(pageSize, maxSize) {\n    super(`Expect page size to be at most ${maxSize}, but ${pageSize} received`);\n  }\n}\nexports.PageSizeTooLargeException = PageSizeTooLargeException;\nclass PageSizeTooSmallException extends RangeError {\n  code = _ErrorCode.default.ParameterInvalid;\n  constructor(pageSize, minSize) {\n    super(`Expect page size to be at least ${minSize}, but ${pageSize} received`);\n  }\n}\nexports.PageSizeTooSmallException = PageSizeTooSmallException;\nclass OutputsValidatorTypeException extends TypeError {\n  code = _ErrorCode.default.ParameterInvalid;\n  constructor() {\n    super(`Expect outputs validator to be 'default' or 'passthrough'`);\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */\nexports.OutputsValidatorTypeException = OutputsValidatorTypeException;\nclass BigintOrHexStringTypeException extends TypeError {\n  code = _ErrorCode.default.ParameterInvalid;\n  constructor(value) {\n    super(`Expect number to be bigint or hex string, but ${value} received`);\n  }\n}\nexports.BigintOrHexStringTypeException = BigintOrHexStringTypeException;\nclass StringHashTypeException extends TypeError {\n  code = _ErrorCode.default.ParameterInvalid;\n  constructor(hash) {\n    super(`Expect hash to be string, but ${hash} received`);\n  }\n}\n/* eslint-enable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */\nexports.StringHashTypeException = StringHashTypeException;\nclass HexStringWithout0xException extends Error {\n  code = _ErrorCode.default.ParameterInvalid;\n  constructor(hex) {\n    super(`Hex string ${hex} should start with 0x`);\n  }\n}\nexports.HexStringWithout0xException = HexStringWithout0xException;\nvar _default = exports.default = {\n  PageSizeTooLargeException,\n  PageSizeTooSmallException,\n  OutputsValidatorTypeException,\n  BigintOrHexStringTypeException,\n  StringHashTypeException,\n  HexStringWithout0xException\n};\n//# sourceMappingURL=formatter.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _formatter = require(\"./formatter\");\nObject.keys(_formatter).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _formatter[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _formatter[key];\n    }\n  });\n});\nvar _rpc = require(\"./rpc\");\nObject.keys(_rpc).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _rpc[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _rpc[key];\n    }\n  });\n});\nvar _batch = require(\"./batch\");\nObject.keys(_batch).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _batch[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _batch[key];\n    }\n  });\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.ResponseException = exports.IdNotMatchException = void 0;\nvar _ErrorCode = _interopRequireDefault(require(\"./ErrorCode\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nclass IdNotMatchException extends Error {\n  code = _ErrorCode.default.IdNotMatch;\n  constructor(requestId, responseId) {\n    super(`Expect json rpc id to be ${requestId}, but ${responseId} received`);\n  }\n}\nexports.IdNotMatchException = IdNotMatchException;\nclass ResponseException extends Error {\n  code = _ErrorCode.default.ResponseMessage;\n}\nexports.ResponseException = ResponseException;\nvar _default = exports.default = {\n  IdNotMatchException,\n  ResponseException\n};\n//# sourceMappingURL=rpc.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResultFormatter = exports.RPC = exports.ParamsFormatter = exports.DEFAULT_RPC_TIMEOUT = exports.CKBRPC = void 0;\nvar _Base = require(\"./Base\");\nvar _method = require(\"./method\");\nvar _paramsFormatter = require(\"./paramsFormatter\");\nvar resultFormatter = _interopRequireWildcard(require(\"./resultFormatter\"));\nvar _exceptions = require(\"./exceptions\");\nvar _crossFetch = _interopRequireDefault(require(\"cross-fetch\"));\nvar _abortController = _interopRequireDefault(require(\"abort-controller\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nconst ParamsFormatter = exports.ParamsFormatter = _paramsFormatter.formatter;\nconst ResultFormatter = exports.ResultFormatter = resultFormatter;\nconst DEFAULT_RPC_TIMEOUT = exports.DEFAULT_RPC_TIMEOUT = 30000;\nclass CKBRPC extends _Base.Base {\n  #config;\n  #node = {\n    url: \"\"\n  };\n  get node() {\n    return this.#node;\n  }\n  #paramsFormatter = _paramsFormatter.formatter;\n  get paramsFormatter() {\n    return this.#paramsFormatter;\n  }\n  #resultFormatter = resultFormatter;\n  get resultFormatter() {\n    return this.#resultFormatter;\n  }\n  constructor(url, config = {}) {\n    super();\n    this.setNode({\n      url\n    });\n    const {\n      timeout = DEFAULT_RPC_TIMEOUT,\n      fetch = _crossFetch.default\n    } = config;\n    this.#config = {\n      timeout,\n      fetch\n    };\n    Object.defineProperties(this, {\n      addMethod: {\n        value: this.addMethod,\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n      setNode: {\n        value: this.setNode,\n        enumerable: false,\n        writable: false,\n        configurable: false\n      }\n      // createBatchRequest: { value: this.createBatchRequest, enumerable: false, writable: false, configurable: false },\n    });\n    Object.keys(this.rpcProperties).forEach(name => {\n      this.addMethod({\n        name,\n        ...this.rpcProperties[name]\n      }, this.#config);\n    });\n  }\n  setNode(node) {\n    Object.assign(this.node, node);\n    return this.node;\n  }\n  addMethod = (options, config) => {\n    const method = new _method.Method(this.node, options, config);\n    Object.defineProperty(this, options.name, {\n      value: method.call,\n      enumerable: true\n    });\n  };\n  /* eslint-disable */\n  createBatchRequest = (params = []) => {\n    const ctx = this;\n    const proxied = new Proxy([], {\n      set(...p) {\n        const methods = Object.keys(ctx);\n        if (p[1] !== \"length\") {\n          var _p$;\n          const name = p === null || p === void 0 || (_p$ = p[2]) === null || _p$ === void 0 ? void 0 : _p$[0];\n          if (methods.indexOf(name) === -1) {\n            throw new _exceptions.MethodInBatchNotFoundException(name);\n          }\n        }\n        return Reflect.set(...p);\n      }\n    });\n    Object.defineProperties(proxied, {\n      add: {\n        value(...args) {\n          this.push(args);\n          return this;\n        }\n      },\n      remove: {\n        value(i) {\n          this.splice(i, 1);\n          return this;\n        }\n      },\n      exec: {\n        async value() {\n          const payload = proxied.map(([f, ...p], i) => {\n            try {\n              const method = new _method.Method(ctx.node, {\n                ...ctx.rpcProperties[f],\n                name: f\n              });\n              return method.getPayload(...p);\n            } catch (err) {\n              throw new _exceptions.PayloadInBatchException(i, err.message);\n            }\n          });\n          const controller = new _abortController.default();\n          const signal = controller.signal;\n          const timeout = setTimeout(() => controller.abort(), ctx.#config.timeout);\n          const batchRes = await ctx.#config.fetch(ctx.#node.url, {\n            method: \"POST\",\n            headers: {\n              \"content-type\": \"application/json\"\n            },\n            body: JSON.stringify(payload),\n            signal\n          }).then(res => res.json());\n          clearTimeout(timeout);\n          return batchRes.map((res, i) => {\n            var _ctx$rpcProperties$pr, _ctx$rpcProperties$pr2, _ctx$rpcProperties$pr3;\n            if (res.id !== payload[i].id) {\n              return new _exceptions.IdNotMatchedInBatchException(i, payload[i].id, res.id);\n            }\n            return (_ctx$rpcProperties$pr = (_ctx$rpcProperties$pr2 = (_ctx$rpcProperties$pr3 = ctx.rpcProperties[proxied[i][0]]).resultFormatters) === null || _ctx$rpcProperties$pr2 === void 0 ? void 0 : _ctx$rpcProperties$pr2.call(_ctx$rpcProperties$pr3, res.result)) !== null && _ctx$rpcProperties$pr !== void 0 ? _ctx$rpcProperties$pr : res.result;\n          });\n        }\n      }\n    });\n    params.forEach(p => proxied.push(p));\n    return proxied;\n  };\n}\nexports.RPC = exports.CKBRPC = CKBRPC;\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Method = void 0;\nvar _exceptions = require(\"./exceptions\");\nvar _ = require(\".\");\nvar _abortController = _interopRequireDefault(require(\"abort-controller\"));\nvar _crossFetch = _interopRequireDefault(require(\"cross-fetch\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nclass Method {\n  #name;\n  #config;\n  get name() {\n    return this.#name;\n  }\n  #options = {\n    name: \"\",\n    method: \"\",\n    paramsFormatters: [],\n    resultFormatters: undefined\n  };\n  #node;\n  constructor(node, options, config = {}) {\n    this.#node = node;\n    this.#options = options;\n    this.#name = options.name;\n    const {\n      timeout = _.DEFAULT_RPC_TIMEOUT,\n      fetch = _crossFetch.default\n    } = config;\n    this.#config = {\n      timeout,\n      fetch\n    };\n    Object.defineProperty(this.call, \"name\", {\n      value: options.name,\n      configurable: false,\n      writable: false\n    });\n  }\n\n  /* eslint-disable @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types */\n  call = async (...params) => {\n    const payload = this.getPayload(...params);\n    const controller = new _abortController.default();\n    const signal = controller.signal;\n    const timeout = setTimeout(() => controller.abort(), this.#config.timeout);\n    const res = await this.#config.fetch(this.#node.url, {\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json\"\n      },\n      body: JSON.stringify(payload),\n      signal\n    }).then(res => res.json()).then(res => {\n      var _this$options$resultF, _this$options$resultF2, _this$options;\n      if (res.id !== payload.id) {\n        throw new _exceptions.IdNotMatchException(payload.id, res.id);\n      }\n      if (res.error) {\n        throw new _exceptions.ResponseException(JSON.stringify(res.error));\n      }\n      return (_this$options$resultF = (_this$options$resultF2 = (_this$options = this.#options).resultFormatters) === null || _this$options$resultF2 === void 0 ? void 0 : _this$options$resultF2.call(_this$options, res.result)) !== null && _this$options$resultF !== void 0 ? _this$options$resultF : res.result;\n    });\n    clearTimeout(timeout);\n    return res;\n  };\n  getPayload = (...params) => {\n    const data = params.map((p, i) => this.#options.paramsFormatters[i] && this.#options.paramsFormatters[i](p) || p);\n    /* eslint-disable @typescript-eslint/no-magic-numbers */\n    const id = Math.round(Math.random() * 10000);\n    const payload = {\n      id,\n      method: this.#options.method,\n      params: data,\n      jsonrpc: \"2.0\"\n    };\n    return payload;\n  };\n}\n/* eslint-enable @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types */\nexports.Method = Method;\n//# sourceMappingURL=method.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatter = void 0;\nvar _exceptions = require(\"./exceptions\");\nvar _bi = require(\"@ckb-lumos/bi\");\n/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */\nconst formatter = exports.formatter = {\n  toOptional: format => arg => {\n    if (!format || arg === undefined || arg === null) {\n      return arg;\n    }\n    return format(arg);\n  },\n  toArray: format => arg => {\n    if (typeof format !== \"function\" || !Array.isArray(arg)) {\n      return arg;\n    }\n    return arg.map(format);\n  },\n  toHash: hash => {\n    if (typeof hash !== \"string\") {\n      throw new _exceptions.StringHashTypeException(hash);\n    }\n    return hash.startsWith(\"0x\") ? hash : `0x${hash}`;\n  },\n  toNumber: number => {\n    if (typeof number === \"bigint\") {\n      return `0x${number.toString(16)}`;\n    }\n    if (typeof number !== \"string\") {\n      throw new _exceptions.BigintOrHexStringTypeException(number);\n    }\n    if (!number.startsWith(\"0x\")) {\n      throw new _exceptions.HexStringWithout0xException(number);\n    }\n    return number;\n  },\n  toScript: script => {\n    const {\n      codeHash,\n      hashType: hash_type,\n      ...rest\n    } = script;\n    return {\n      code_hash: formatter.toHash(codeHash),\n      hash_type,\n      ...rest\n    };\n  },\n  toOutPoint: outPoint => {\n    const {\n      txHash,\n      index,\n      ...rest\n    } = outPoint;\n    return {\n      tx_hash: formatter.toHash(txHash),\n      index: formatter.toNumber(index),\n      ...rest\n    };\n  },\n  toInput: input => {\n    if (!input) return input;\n    const {\n      previousOutput,\n      since,\n      ...rest\n    } = input;\n    return {\n      previous_output: formatter.toOutPoint(previousOutput),\n      since: formatter.toNumber(since),\n      ...rest\n    };\n  },\n  toOutput: output => {\n    if (!output) return output;\n    const {\n      capacity,\n      lock,\n      type = undefined,\n      ...rest\n    } = output;\n    return {\n      capacity: formatter.toNumber(capacity),\n      lock: formatter.toScript(lock),\n      type: type ? formatter.toScript(type) : type,\n      ...rest\n    };\n  },\n  toDepType: type => {\n    if (type === \"depGroup\") {\n      return \"dep_group\";\n    }\n    return type;\n  },\n  toOrder: order => {\n    return order;\n  },\n  toCellDep: cellDep => {\n    if (!cellDep) return cellDep;\n    const {\n      outPoint,\n      depType = \"code\",\n      ...rest\n    } = cellDep;\n    return {\n      out_point: formatter.toOutPoint(outPoint),\n      dep_type: formatter.toDepType(depType),\n      ...rest\n    };\n  },\n  toRawTransaction: transaction => {\n    if (!transaction) return transaction;\n    const {\n      version,\n      cellDeps = [],\n      inputs = [],\n      outputs = [],\n      outputsData: outputs_data = [],\n      headerDeps: header_deps = [],\n      ...rest\n    } = transaction;\n    const formattedInputs = inputs.map(input => formatter.toInput(input));\n    const formattedOutputs = outputs.map(output => formatter.toOutput(output));\n    const formattedCellDeps = cellDeps.map(cellDep => formatter.toCellDep(cellDep));\n    const tx = {\n      version: formatter.toNumber(version),\n      cell_deps: formattedCellDeps,\n      inputs: formattedInputs,\n      outputs: formattedOutputs,\n      outputs_data,\n      header_deps,\n      ...rest\n    };\n    return tx;\n  },\n  toPageNumber: (pageNo = \"0x1\") => formatter.toNumber(pageNo),\n  toPageSize: (pageSize = \"0x32\") => {\n    const size = _bi.BI.from(pageSize);\n    const MAX_SIZE = 50;\n    const MIN_SIZE = 0;\n    if (_bi.BI.from(size).gt(MAX_SIZE)) throw new _exceptions.PageSizeTooLargeException(pageSize, MAX_SIZE);\n    if (_bi.BI.from(size).lt(MIN_SIZE)) throw new _exceptions.PageSizeTooSmallException(pageSize, MIN_SIZE);\n    return formatter.toNumber(`0x${size.toString(16)}`);\n  },\n  toReverseOrder: (reverse = false) => !!reverse,\n  toOutputsValidator: outputsValidator => {\n    if (!outputsValidator) return undefined;\n    const VALIDATORS = [\"default\", \"passthrough\"];\n    if (VALIDATORS.indexOf(outputsValidator) > -1) {\n      return outputsValidator;\n    }\n    throw new _exceptions.OutputsValidatorTypeException();\n  },\n  toBoolean: value => {\n    return !!value;\n  },\n  toTransactionProof: proof => {\n    if (!proof) return proof;\n    const {\n      blockHash: block_hash,\n      witnessesRoot: witnesses_root,\n      ...rest\n    } = proof;\n    return {\n      block_hash,\n      witnesses_root,\n      ...rest\n    };\n  },\n  toTransactionAndWitnessProof: proof => {\n    return {\n      block_hash: proof.blockHash,\n      witnesses_proof: proof.witnessesProof,\n      transactions_proof: proof.transactionsProof\n    };\n  },\n  toSearchFilter: data => {\n    if (!data) return data;\n    return {\n      script: data.script ? formatter.toScript(data.script) : data.script,\n      output_data_len_range: data.outputDataLenRange,\n      output_capacity_range: data.outputCapacityRange,\n      block_range: data.blockRange,\n      script_len_range: data.scriptLenRange\n    };\n  },\n  toSearchKey: data => {\n    if (!data) return data;\n    return {\n      script: formatter.toScript(data.script),\n      script_type: data.scriptType,\n      filter: data.filter ? formatter.toSearchFilter(data.filter) : data.filter,\n      script_search_mode: data.scriptSearchMode ? data.scriptSearchMode : \"prefix\"\n    };\n  },\n  toGetCellsSearchKey: data => {\n    if (!data) return data;\n    return {\n      ...formatter.toSearchKey(data),\n      with_data: data.withData\n    };\n  },\n  toGetTransactionsSearchKey: data => {\n    if (!data) return data;\n    return {\n      ...formatter.toSearchKey(data),\n      group_by_transaction: data.groupByTransaction\n    };\n  }\n};\n/* eslint-enable camelcase, @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */\n//# sourceMappingURL=paramsFormatter.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toBannedAddresses = exports.toBannedAddress = exports.toArray = exports.toAlertMessage = void 0;\nexports.toBlock = toBlock;\nexports.toHash = exports.toGetTransactionsResult = exports.toGetCellsResult = exports.toForkBlockResult = exports.toFeeRateStatistics = exports.toFeeRate = exports.toEstimateCycles = exports.toEpoch = exports.toDeploymentsInfo = exports.toDeploymentInfo = exports.toDeployment = exports.toDeployState = exports.toDepType = exports.toConsensus = exports.toCellsIncludingOutPoint = exports.toCellsCapacity = exports.toCells = exports.toCellbaseOutputCapacityDetails = exports.toCellIncludingOutPoint = exports.toCellDep = exports.toCell = exports.toCapacityByLockHash = exports.toBlockchainInfo = exports.toBlockFilter = exports.toBlockEconomicState = void 0;\nexports.toHeader = toHeader;\nexports.toTip = exports.toSyncState = exports.toScript = exports.toRemoteNodeInfo = exports.toRawTxPool = exports.toPeers = exports.toOutput = exports.toOutPoint = exports.toNumber = exports.toNullable = exports.toLockHashIndexStates = exports.toLockHashIndexState = exports.toLocalNodeInfo = exports.toLiveCellsByLockHash = exports.toLiveCellWithStatus = exports.toLiveCell = exports.toInput = void 0;\nexports.toTransaction = toTransaction;\nexports.toUncleBlock = exports.toTxPoolInfo = exports.toTransactionsByLockHash = exports.toTransactionWithStatus = exports.toTransactionProof = exports.toTransactionPoint = exports.toTransactionAndWitnessProof = void 0;\n/* eslint-disable camelcase, @typescript-eslint/no-explicit-any */\n\nconst isTxPoolIds = rawTxPool => {\n  return Array.isArray(rawTxPool.pending);\n};\nconst toArray = format => arg => {\n  if (typeof format !== \"function\" || !Array.isArray(arg)) {\n    return arg;\n  }\n  return arg.map(format);\n};\nexports.toArray = toArray;\nconst toNullable = format => origin => {\n  if (!format || origin === null) return origin;\n  return format(origin);\n};\nexports.toNullable = toNullable;\nconst toNumber = number => number.toString();\nexports.toNumber = toNumber;\nconst toHash = hash => hash;\nexports.toHash = toHash;\nfunction toHeader(header) {\n  if (typeof header === \"string\") return header;\n  if (!header) return header;\n  const {\n    compact_target: compactTarget,\n    transactions_root: transactionsRoot,\n    proposals_hash: proposalsHash,\n    extra_hash: extraHash,\n    parent_hash: parentHash,\n    ...rest\n  } = header;\n  return {\n    compactTarget,\n    parentHash,\n    transactionsRoot,\n    proposalsHash,\n    extraHash,\n    ...rest\n  };\n}\nconst toScript = script => {\n  if (!script) return script;\n  const {\n    code_hash: codeHash,\n    hash_type: hashType,\n    ...rest\n  } = script;\n  return {\n    codeHash,\n    hashType,\n    ...rest\n  };\n};\nexports.toScript = toScript;\nconst toInput = input => {\n  if (!input) return input;\n  const {\n    previous_output: previousOutput,\n    ...rest\n  } = input;\n  return {\n    previousOutput: previousOutput ? toOutPoint(previousOutput) : previousOutput,\n    ...rest\n  };\n};\nexports.toInput = toInput;\nconst toOutput = output => {\n  if (!output) return output;\n  const {\n    lock,\n    type,\n    ...rest\n  } = output;\n  return {\n    lock: toScript(lock),\n    type: type ? toScript(type) : type,\n    ...rest\n  };\n};\nexports.toOutput = toOutput;\nconst toOutPoint = outPoint => {\n  const {\n    tx_hash: txHash,\n    ...rest\n  } = outPoint;\n  return {\n    txHash,\n    ...rest\n  };\n};\nexports.toOutPoint = toOutPoint;\nconst toDepType = type => {\n  if (type === \"dep_group\") {\n    return \"depGroup\";\n  }\n  return type;\n};\nexports.toDepType = toDepType;\nconst toCellDep = cellDep => {\n  if (!cellDep) return cellDep;\n  const {\n    out_point: outPoint,\n    dep_type = \"code\",\n    ...rest\n  } = cellDep;\n  return {\n    outPoint: toOutPoint(outPoint),\n    depType: toDepType(dep_type),\n    ...rest\n  };\n};\nexports.toCellDep = toCellDep;\nfunction toTransaction(tx) {\n  if (!tx || typeof tx !== \"object\") return tx;\n  const {\n    cell_deps: cellDeps = [],\n    inputs = [],\n    outputs = [],\n    outputs_data: outputsData = [],\n    header_deps: headerDeps = [],\n    ...rest\n  } = tx;\n  return {\n    cellDeps: cellDeps.map(toCellDep),\n    inputs: inputs.map(toInput),\n    outputs: outputs.map(toOutput),\n    outputsData,\n    headerDeps,\n    ...rest\n  };\n}\nconst toUncleBlock = uncleBlock => {\n  if (!uncleBlock) return uncleBlock;\n  const {\n    header,\n    ...rest\n  } = uncleBlock;\n  return {\n    header: toHeader(header),\n    ...rest\n  };\n};\nexports.toUncleBlock = toUncleBlock;\nconst toTip = tip => ({\n  blockHash: tip.block_hash,\n  blockNumber: tip.block_number\n});\nexports.toTip = toTip;\nfunction toBlock(res) {\n  if (!res) return res;\n  if (typeof res === \"string\") return res;\n  if (\"block\" in res && \"cycles\" in res) {\n    return {\n      cycles: res.cycles,\n      block: toBlock(res.block)\n    };\n  }\n  const {\n    header,\n    uncles = [],\n    transactions = [],\n    ...rest\n  } = res;\n  return {\n    header: toHeader(header),\n    uncles: uncles.map(toUncleBlock),\n    transactions: transactions.map(toTransaction),\n    ...rest\n  };\n}\nconst toAlertMessage = alertMessage => {\n  if (!alertMessage) return alertMessage;\n  const {\n    notice_until: noticeUntil,\n    ...rest\n  } = alertMessage;\n  return {\n    noticeUntil,\n    ...rest\n  };\n};\nexports.toAlertMessage = toAlertMessage;\nconst toBlockchainInfo = info => {\n  if (!info) return info;\n  const {\n    is_initial_block_download: isInitialBlockDownload,\n    median_time: medianTime,\n    alerts,\n    ...rest\n  } = info;\n  return {\n    isInitialBlockDownload,\n    medianTime,\n    alerts: alerts.map(toAlertMessage),\n    ...rest\n  };\n};\nexports.toBlockchainInfo = toBlockchainInfo;\nconst toLocalNodeInfo = info => {\n  if (!info) return info;\n  const {\n    node_id: nodeId,\n    protocols,\n    ...rest\n  } = info;\n  return {\n    nodeId,\n    protocols: protocols.map(({\n      id,\n      name,\n      support_versions: supportVersions\n    }) => ({\n      id,\n      name,\n      supportVersions\n    })),\n    ...rest\n  };\n};\nexports.toLocalNodeInfo = toLocalNodeInfo;\nconst toRemoteNodeInfo = info => {\n  if (!info) return info;\n  const {\n    node_id: nodeId,\n    connected_duration: connectedDuration,\n    is_outbound: isOutbound,\n    last_ping_duration: lastPingDuration,\n    sync_state,\n    ...rest\n  } = info;\n  return {\n    nodeId,\n    connectedDuration,\n    isOutbound,\n    lastPingDuration,\n    syncState: {\n      bestKnownHeaderHash: sync_state.best_known_header_hash,\n      bestKnownHeaderNumber: sync_state.best_known_header_number,\n      canFetchCount: sync_state.can_fetch_count,\n      inflightCount: sync_state.inflight_count,\n      lastCommonHeaderHash: sync_state.last_common_header_hash,\n      lastCommonHeaderNumber: sync_state.last_common_header_number,\n      unknownHeaderListSize: sync_state.unknown_header_list_size\n    },\n    ...rest\n  };\n};\nexports.toRemoteNodeInfo = toRemoteNodeInfo;\nconst toTxPoolInfo = info => {\n  if (!info) return info;\n  const {\n    last_txs_updated_at: lastTxsUpdatedAt,\n    tip_hash: tipHash,\n    tip_number: tipNumber,\n    total_tx_cycles: totalTxCycles,\n    total_tx_size: totalTxSize,\n    min_fee_rate: minFeeRate,\n    min_rbf_rate: minRbfRate,\n    tx_size_limit: txSizeLimit,\n    max_tx_pool_size: maxTxPoolSize,\n    ...rest\n  } = info;\n  return {\n    lastTxsUpdatedAt,\n    tipHash,\n    tipNumber,\n    totalTxCycles,\n    totalTxSize,\n    minFeeRate,\n    minRbfRate,\n    txSizeLimit,\n    maxTxPoolSize,\n    ...rest\n  };\n};\nexports.toTxPoolInfo = toTxPoolInfo;\nconst toPeers = nodes => {\n  if (!Array.isArray(nodes)) return [];\n  return nodes.map(toRemoteNodeInfo);\n};\nexports.toPeers = toPeers;\nconst toCell = cell => {\n  if (!cell) return cell;\n  const {\n    lock,\n    type,\n    ...rest\n  } = cell;\n  return {\n    lock: toScript(lock),\n    type: type ? toScript(type) : undefined,\n    ...rest\n  };\n};\nexports.toCell = toCell;\nconst toLiveCell = liveCell => {\n  if (!liveCell) return liveCell;\n  const {\n    data,\n    output,\n    ...rest\n  } = liveCell;\n  return {\n    data,\n    output: toOutput(output),\n    ...rest\n  };\n};\nexports.toLiveCell = toLiveCell;\nconst toLiveCellWithStatus = cellWithStatus => {\n  if (!cellWithStatus) return cellWithStatus;\n  const {\n    cell,\n    ...rest\n  } = cellWithStatus;\n  return {\n    cell: toLiveCell(cell),\n    ...rest\n  };\n};\nexports.toLiveCellWithStatus = toLiveCellWithStatus;\nconst toCells = cells => {\n  if (!Array.isArray(cells)) return [];\n  return cells.map(toCell);\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexports.toCells = toCells;\nconst toCellIncludingOutPoint = cell => {\n  if (!cell) return cell;\n  const {\n    lock,\n    block_hash: blockHash,\n    out_point,\n    output_data_len: outputDataLen,\n    ...rest\n  } = cell;\n  return {\n    blockHash,\n    lock: toScript(lock),\n    outPoint: toOutPoint(out_point),\n    outputDataLen,\n    ...rest\n  };\n};\nexports.toCellIncludingOutPoint = toCellIncludingOutPoint;\nconst toCellsIncludingOutPoint = cells => {\n  if (!Array.isArray(cells)) return [];\n  return cells.map(toCellIncludingOutPoint);\n};\nexports.toCellsIncludingOutPoint = toCellsIncludingOutPoint;\nconst toTransactionWithStatus = txWithStatus => {\n  if (!txWithStatus) return txWithStatus;\n  const {\n    transaction,\n    tx_status: {\n      block_hash: blockHash,\n      status\n    },\n    time_added_to_pool,\n    min_replace_fee,\n    fee,\n    ...rest\n  } = txWithStatus;\n  return {\n    transaction: toTransaction(transaction),\n    txStatus: {\n      blockHash,\n      status,\n      ...(\"reason\" in txWithStatus.tx_status ? {\n        reason: txWithStatus.tx_status.reason\n      } : {})\n    },\n    timeAddedToPool: time_added_to_pool,\n    minReplaceFee: min_replace_fee,\n    fee,\n    ...rest\n  };\n};\nexports.toTransactionWithStatus = toTransactionWithStatus;\nconst toEpoch = epoch => {\n  if (!epoch) return epoch;\n  const {\n    start_number: startNumber,\n    compact_target: compactTarget,\n    ...rest\n  } = epoch;\n  return {\n    compactTarget,\n    startNumber,\n    ...rest\n  };\n};\nexports.toEpoch = toEpoch;\nconst toTransactionPoint = transactionPoint => {\n  if (!transactionPoint) return transactionPoint;\n  const {\n    block_number: blockNumber,\n    tx_hash: txHash,\n    ...rest\n  } = transactionPoint;\n  return {\n    blockNumber,\n    txHash,\n    ...rest\n  };\n};\nexports.toTransactionPoint = toTransactionPoint;\nconst toTransactionsByLockHash = transactions => {\n  if (!transactions) return transactions;\n  return transactions.map(tx => ({\n    consumedBy: tx.consumed_by ? toTransactionPoint(tx.consumed_by) : tx.consumed_by,\n    createdBy: toTransactionPoint(tx.created_by)\n  }));\n};\nexports.toTransactionsByLockHash = toTransactionsByLockHash;\nconst toLiveCellsByLockHash = cells => {\n  if (!cells) return cells;\n  return cells.map(cell => ({\n    cellOutput: toCell(cell.cell_output),\n    createdBy: toTransactionPoint(cell.created_by),\n    cellbase: cell.cellbase,\n    outputDataLen: cell.output_data_len\n  }));\n};\nexports.toLiveCellsByLockHash = toLiveCellsByLockHash;\nconst toLockHashIndexState = index => {\n  if (!index) return index;\n  const {\n    block_hash: blockHash,\n    block_number: blockNumber,\n    lock_hash: lockHash,\n    ...rest\n  } = index;\n  return {\n    blockHash,\n    blockNumber,\n    lockHash,\n    ...rest\n  };\n};\nexports.toLockHashIndexState = toLockHashIndexState;\nconst toLockHashIndexStates = states => {\n  if (!states) return states;\n  return states.map(toLockHashIndexState);\n};\nexports.toLockHashIndexStates = toLockHashIndexStates;\nconst toBannedAddress = bannedAddress => {\n  if (!bannedAddress) return bannedAddress;\n  const {\n    ban_reason: banReason,\n    ban_until: banUntil,\n    created_at: createdAt,\n    ...rest\n  } = bannedAddress;\n  return {\n    banReason,\n    banUntil,\n    createdAt,\n    ...rest\n  };\n};\nexports.toBannedAddress = toBannedAddress;\nconst toBannedAddresses = bannedAddresses => {\n  if (!bannedAddresses) return bannedAddresses;\n  return bannedAddresses.map(banAddr => toBannedAddress(banAddr));\n};\nexports.toBannedAddresses = toBannedAddresses;\nconst toCellbaseOutputCapacityDetails = details => {\n  if (!details) return details;\n  const {\n    proposal_reward: proposalReward,\n    tx_fee: txFee,\n    ...rest\n  } = details;\n  return {\n    proposalReward,\n    txFee,\n    ...rest\n  };\n};\nexports.toCellbaseOutputCapacityDetails = toCellbaseOutputCapacityDetails;\nconst toFeeRate = feeRateObj => {\n  if (!feeRateObj) {\n    return feeRateObj;\n  }\n  const {\n    fee_rate: feeRate,\n    ...rest\n  } = feeRateObj;\n  return {\n    feeRate,\n    ...rest\n  };\n};\nexports.toFeeRate = toFeeRate;\nconst toCapacityByLockHash = capacityByLockHash => {\n  if (!capacityByLockHash) {\n    return capacityByLockHash;\n  }\n  const {\n    cells_count: cellsCount,\n    block_number: blockNumber,\n    capacity,\n    ...rest\n  } = capacityByLockHash;\n  return {\n    blockNumber,\n    capacity,\n    cellsCount,\n    ...rest\n  };\n};\nexports.toCapacityByLockHash = toCapacityByLockHash;\nconst toBlockEconomicState = blockEconomicState => {\n  if (!blockEconomicState) {\n    return blockEconomicState;\n  }\n  const {\n    finalized_at: finalizedAt,\n    miner_reward: minerReward,\n    txs_fee: txsFee,\n    ...rest\n  } = blockEconomicState;\n  return {\n    finalizedAt,\n    minerReward,\n    txsFee,\n    ...rest\n  };\n};\nexports.toBlockEconomicState = toBlockEconomicState;\nconst toSyncState = state => {\n  if (!state) {\n    return state;\n  }\n  return {\n    bestKnownBlockNumber: state.best_known_block_number,\n    bestKnownBlockTimestamp: state.best_known_block_timestamp,\n    fastTime: state.fast_time,\n    ibd: state.ibd,\n    inflightBlocksCount: state.inflight_blocks_count,\n    lowTime: state.low_time,\n    normalTime: state.normal_time,\n    orphanBlocksCount: state.orphan_blocks_count\n  };\n};\nexports.toSyncState = toSyncState;\nconst toTransactionProof = proof => {\n  if (!proof) {\n    return proof;\n  }\n  const {\n    block_hash: blockHash,\n    witnesses_root: witnessesRoot,\n    ...rest\n  } = proof;\n  return {\n    blockHash,\n    witnessesRoot,\n    ...rest\n  };\n};\nexports.toTransactionProof = toTransactionProof;\nconst toHardforkFeature = feature => {\n  return {\n    rfc: feature.rfc,\n    epochNumber: feature.epoch_number\n  };\n};\nconst toDeployment = deployment => {\n  return {\n    bit: deployment.bit,\n    start: deployment.start,\n    timeout: deployment.timeout,\n    minActivationEpoch: deployment.min_activation_epoch,\n    period: deployment.period,\n    threshold: deployment.threshold\n  };\n};\nexports.toDeployment = toDeployment;\nconst toSoftFork = softFork => {\n  if (\"rfc0043\" in softFork) {\n    return {\n      status: softFork.status,\n      rfc0043: toDeployment(softFork.rfc0043)\n    };\n  }\n  return softFork;\n};\nconst toConsensus = consensus => {\n  if (!consensus) return consensus;\n  const rpcHardforkFeatures = consensus.hardfork_features;\n  const softforks = consensus.softforks;\n  const lightClient = softforks.light_client && toSoftFork(softforks.light_client);\n  const testdummy = softforks.testdummy && toSoftFork(softforks.testdummy);\n  return {\n    blockVersion: consensus.block_version,\n    cellbaseMaturity: consensus.cellbase_maturity,\n    daoTypeHash: consensus.dao_type_hash,\n    epochDurationTarget: consensus.epoch_duration_target,\n    genesisHash: consensus.genesis_hash,\n    id: consensus.id,\n    initialPrimaryEpochReward: consensus.initial_primary_epoch_reward,\n    maxBlockBytes: consensus.max_block_bytes,\n    maxBlockCycles: consensus.max_block_cycles,\n    maxBlockProposalsLimit: consensus.max_block_proposals_limit,\n    maxUnclesNum: consensus.max_uncles_num,\n    medianTimeBlockCount: consensus.median_time_block_count,\n    orphanRateTarget: consensus.orphan_rate_target,\n    permanentDifficultyInDummy: consensus.permanent_difficulty_in_dummy,\n    primaryEpochRewardHalvingInterval: consensus.primary_epoch_reward_halving_interval,\n    proposerRewardRatio: consensus.proposer_reward_ratio,\n    secondaryEpochReward: consensus.secondary_epoch_reward,\n    secp256k1Blake160MultisigAllTypeHash: consensus.secp256k1_blake160_multisig_all_type_hash,\n    secp256k1Blake160SighashAllTypeHash: consensus.secp256k1_blake160_sighash_all_type_hash,\n    txProposalWindow: consensus.tx_proposal_window,\n    txVersion: consensus.tx_version,\n    typeIdCodeHash: consensus.type_id_code_hash,\n    hardforkFeatures: rpcHardforkFeatures.map(toHardforkFeature),\n    softforks: {\n      ...(lightClient && {\n        lightClient\n      }),\n      ...(testdummy && {\n        testdummy\n      })\n    }\n  };\n};\nexports.toConsensus = toConsensus;\nconst toRawTxPool = rawTxPool => {\n  if (!rawTxPool) return rawTxPool;\n  if (isTxPoolIds(rawTxPool)) {\n    return rawTxPool;\n  }\n  const toTxVerbosity = ({\n    ancestors_count: ancestorsCount,\n    ancestors_cycles: ancestorsCycles,\n    ancestors_size: ancestorsSize,\n    ...rest\n  }) => ({\n    ancestorsCount,\n    ancestorsCycles,\n    ancestorsSize,\n    ...rest\n  });\n  const proposed = {};\n  const pending = {};\n  Object.keys(rawTxPool.proposed).forEach(hash => {\n    proposed[hash] = toTxVerbosity(rawTxPool.proposed[hash]);\n  });\n  Object.keys(rawTxPool.pending).forEach(hash => {\n    pending[hash] = toTxVerbosity(rawTxPool.pending[hash]);\n  });\n  return {\n    proposed,\n    pending\n  };\n};\nexports.toRawTxPool = toRawTxPool;\nconst toIndexerCell = indexerCell => {\n  if (!indexerCell) return indexerCell;\n  return {\n    blockNumber: indexerCell.block_number,\n    outPoint: toOutPoint(indexerCell.out_point),\n    output: toOutput(indexerCell.output),\n    outputData: indexerCell.output_data,\n    txIndex: indexerCell.tx_index\n  };\n};\nconst toGetCellsResult = getCellsResult => ({\n  lastCursor: getCellsResult.last_cursor,\n  objects: getCellsResult.objects.map(object => toIndexerCell(object))\n});\nexports.toGetCellsResult = toGetCellsResult;\nconst isUngroupedIndexerTransaction = value => {\n  if (value.cells) {\n    return false;\n  }\n  return true;\n};\nconst toIndexerTransaction = indexerTransaction => {\n  if (!indexerTransaction) return indexerTransaction;\n  if (isUngroupedIndexerTransaction(indexerTransaction)) {\n    return {\n      txHash: indexerTransaction.tx_hash,\n      blockNumber: indexerTransaction.block_number,\n      ioIndex: indexerTransaction.io_index,\n      ioType: indexerTransaction.io_type,\n      txIndex: indexerTransaction.tx_index\n    };\n  }\n  return {\n    txHash: indexerTransaction.tx_hash,\n    txIndex: indexerTransaction.tx_index,\n    blockNumber: indexerTransaction.block_number,\n    cells: indexerTransaction.cells\n  };\n};\nconst toGetTransactionsResult = getTransactionsResult => {\n  if (!getTransactionsResult) return getTransactionsResult;\n  return {\n    lastCursor: getTransactionsResult.last_cursor,\n    objects: getTransactionsResult.objects.map(object => toIndexerTransaction(object))\n  };\n};\nexports.toGetTransactionsResult = toGetTransactionsResult;\nconst toCellsCapacity = cellsCapacity => {\n  if (!cellsCapacity) return cellsCapacity;\n  return {\n    capacity: cellsCapacity.capacity,\n    blockHash: cellsCapacity.block_hash,\n    blockNumber: cellsCapacity.block_number\n  };\n};\nexports.toCellsCapacity = toCellsCapacity;\nconst toBlockFilter = blockFilter => {\n  return {\n    hash: blockFilter.hash,\n    data: blockFilter.data\n  };\n};\nexports.toBlockFilter = toBlockFilter;\nconst toTransactionAndWitnessProof = proof => {\n  return {\n    blockHash: proof.block_hash,\n    transactionsProof: proof.transactions_proof,\n    witnessesProof: proof.witnesses_proof\n  };\n};\nexports.toTransactionAndWitnessProof = toTransactionAndWitnessProof;\nconst toFeeRateStatistics = statistics => {\n  return {\n    mean: statistics.mean,\n    median: statistics.median\n  };\n};\nexports.toFeeRateStatistics = toFeeRateStatistics;\nconst toForkBlockResult = result => {\n  if (typeof result === \"string\") {\n    return result;\n  }\n  return {\n    header: toHeader(result.header),\n    uncles: result.uncles.map(toUncleBlock),\n    transactions: result.transactions.map(toTransaction),\n    proposals: result.proposals,\n    extension: result.extension\n  };\n};\nexports.toForkBlockResult = toForkBlockResult;\nconst toEstimateCycles = cycle => {\n  return {\n    cycles: cycle.cycles\n  };\n};\nexports.toEstimateCycles = toEstimateCycles;\nconst toDeployState = state => {\n  if (state === \"locked_in\") {\n    return \"lockedIn\";\n  }\n  return state;\n};\nexports.toDeployState = toDeployState;\nconst toDeploymentInfo = deploymentInfo => {\n  return {\n    bit: deploymentInfo.bit,\n    /// specifies the first epoch in which the bit gains meaning.\n    start: deploymentInfo.start,\n    timeout: deploymentInfo.timeout,\n    minActivationEpoch: deploymentInfo.min_activation_epoch,\n    period: deploymentInfo.period,\n    threshold: deploymentInfo.threshold,\n    since: deploymentInfo.since,\n    state: toDeployState(deploymentInfo.state)\n  };\n};\nexports.toDeploymentInfo = toDeploymentInfo;\nconst toDeploymentsInfo = deploymentInfo => {\n  const {\n    light_client,\n    testdummy\n  } = deploymentInfo.deployments;\n  return {\n    hash: deploymentInfo.hash,\n    epoch: deploymentInfo.epoch,\n    deployments: {\n      ...(light_client ? {\n        lightClient: toDeploymentInfo(light_client)\n      } : {}),\n      ...(testdummy ? {\n        testdummy: toDeploymentInfo(testdummy)\n      } : {})\n    }\n  };\n};\n\n/* eslint-enable camelcase */\nexports.toDeploymentsInfo = toDeploymentsInfo;\n//# sourceMappingURL=resultFormatter.js.map","/*globals self, window */\n\"use strict\"\n\n/*eslint-disable @mysticatea/prettier */\nconst { AbortController, AbortSignal } =\n    typeof self !== \"undefined\" ? self :\n    typeof window !== \"undefined\" ? window :\n    /* otherwise */ undefined\n/*eslint-enable @mysticatea/prettier */\n\nmodule.exports = AbortController\nmodule.exports.AbortSignal = AbortSignal\nmodule.exports.default = AbortController\n"],"names":["Object","defineProperty","exports","value","convertQueryOptionToLumosSearchKey","filterByLumosQueryOptions","cells","options","searchKey","filteredCells","filter","cell","filterByLumosSearchKey","argsLen","_codec","bytes","bytify","cellOutput","lock","args","length","data","instanceOfDataWithSearchMode","searchMode","dataSearch","equal","expectPrefix","actualPrefix","slice","instanceOfScriptWrapper","unwrapScriptWrapper","unwrapDataWrapper","_base","_bi","queryOptions","searchKeyLock","searchKeyType","queryLock","queryType","type","script","scriptType","scriptSearchMode","Error","outputDataLenRange","outputCapacityRange","scriptLenRange","isExactMode","blockchain","Script","pack","checkScriptWithPrefixMode","checkScriptLenRange","capacity","BI","from","fromCapacity","toCapacity","lt","gte","dataLen","fromDataLen","toDataLen","filterScript","codeHash","expectArgsPrefix","actualArgsPrefix","hashType","scriptLen","concat","fromScriptLen","toScriptLen","object","inputScript","input","CKBCellCollector","_toolkit","_services","_crossFetch","_interopRequireDefault","obj","__esModule","default","_ckbIndexerFilter","constructor","terminableCellFetcher","queries","otherQueryOptions","this","defaultQuery","undefined","fromBlock","toBlock","order","skip","bufferSize","Array","isArray","map","query","forEach","validateQueryOption","convertQueryOptionToSearchKey","validators","ValidateScript","utils","assertHexadecimal","getHexStringBytes","Number","dataLenRange","toString","getLiveCell","lastCursor","searchKeyFilter","sizeLimit","getCells","generateSearchKey","count","counter","_cell","collect","request","rpcUrl","res","method","body","JSON","stringify","headers","status","result","json","error","getLiveCellWithBlockHash","objects","requestData","index","id","jsonrpc","params","blockNumber","blockHashList","ckbRpcUrl","item","rpcResponse","find","responseItem","blockHash","visitedCellKey","Set","collectBySingleQuery","_cell$outPoint","_cell$outPoint2","key","outPoint","txHash","has","add","withBlockHash","getCellWithCursor","async","buffer","skippedCount","enumerable","get","_collector","_indexer","TerminableCellAdapter","_transaction_collector","_rpc","CkbIndexer","_events","_type","_rpc2","DefaultTerminator","stop","push","defaultLogger","level","message","console","log","static","medianTimeEmitters","emitters","isSubscribeRunning","ckbIndexerUrl","uri","ckbIndexerUri","getCkbRpc","CKBRPC","getIndexerRpc","rpc","getTip","getIndexerTip","RPC","tip","asyncSleep","timeout","Promise","resolve","setTimeout","waitForSync","blockDifference","rpcTipNumber","parseInt","getTipHeader","number","collector","terminator","getTransactions","infos","cursor","txs","running","start","startForever","subscribe","scheduleLoop","emitter","IndexerEmitter","outputData","loop","poll","then","catch","e","stack","block","getBlockByNumber","publishAppendBlockEvents","nextBlockNumber","header","parentHash","txIndex","tx","transactions","entries","inputTxHashes","inputs","previousOutput","requestBatchTransactionWithStatus","response","txWithStatus","cellIndex","output","transaction","outputs","outputsData","filterEvents","outputIndex","emitMedianTimeEvents","checkFilterOptions","emit","emitterScript","checkBlockNumber","lte","checkOutputData","checkScript","checkArgs","emitterArgs","substring","medianTime","getBlockchainInfo","medianTimeEmitter","subscribeMedianTime","EventEmitter","getCellsableRpc","liveCells","liveCell","toSearchKey","toSearchFilter","toScript","toGetTransactionsSearchKey","toGetCellsSearchKey","code_hash","hash_type","output_data_len_range","output_capacity_range","block_range","blockRange","script_len_range","script_type","script_search_mode","with_data","withData","group_by_transaction","groupByTransaction","toTip","toOutPoint","toCellOutPut","block_hash","block_number","tx_hash","_paramsFormatter","deepCamel","limit","getIndexerInfo","requestBatch","txHashes","requestBody","ResultFormatter","toTransactionWithStatus","_resultFormatter","hexString","assertHexString","Math","ceil","substr","CKBIndexerTransactionCollector","services","_interopRequireWildcard","r","t","_getRequireWildcardCache","n","__proto__","a","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","WeakMap","indexer","TransactionCollector","CKBRpcUrl","super","filterOptions","skipMissing","includeStatus","asBaseTransactionCollector","fetchIndexerTransaction","indexerTransactionList","getTransactionByLockAndTypeIndependent","filterByTypeIoTypeAndLockIoType","getResolvedTransactionRequestPayload","unresolvedTransactionList","requestPayload","unresolvedTransaction","indexerTransaction","ioType","unresolvedOutPoint","ioIndex","getResolvedCell","resolvedTransactionList","resolvedTransaction","hash","filterTransaction","resolvedCell","isCellScriptArgsValid","txStatus","cycles","timeAddedToPool","minReplaceFee","fee","getTransactionListFromRpc","queryWithTypeAdditionOptions","queryWithLockAdditionOptions","lockLastCursor","typeLastCursor","split","queriesWithoutType","transactionByLock","queriesWithoutLock","transactionByType","transactionList1","transactionList2","tx1","tx2","targetTx","intersection","getDetailRequestData","hashItem","isLockArgsLenMatched","targetCell","lockArgsLen","_targetCell$type","typeArgsLen","filterByIoType","inputResult","getTxWithCursor","getTransactionHashes","transactionHashes","WitnessArgs","BytesVec","BytesOpt","Bytes","Byte32Vec","Byte32","WitnessArgsOf","createFixedHexBytesCodec","_bytes","_molecule","byteLength","createFixedBytesCodec","hex","unpack","buf","hexify","byteVecOf","option","vector","payload","table","input_type","output_type","HexifyCodec","createBytesCodec","CellCollector","checkLimit","injectCapacity","prepareSigningEntries","setupInputCell","setupOutputCell","withdraw","_configManager","_helpers","_immutable","_from_info","_helper","_sudt","ScriptValue","values","CKBHasher","ckbHash","fromInfo","cellProvider","config","getConfig","fromScript","parseFromInfo","cellCollector","isAcpScript","inputCell","txSkeleton","_fromInfo","defaultWitness","since","inputLock","update","inputSinces","size","witnesses","outputCell","fixedEntries","field","template","SCRIPTS","ANYONE_CAN_PAY","scriptOutPoint","TX_HASH","INDEX","firstIndex","addCellDep","depType","DEP_TYPE","findIndex","validate","equals","witness","newWitnessArgs","SECP_SIGNATURE_PLACEHOLDER","witnessArgs","inputType","outputType","acpArgs","_capacity","minimalAmount","minimalCapacity","pow","multiplier","multiplicand","mul","toAddress","generateAddress","toAddressCellCollector","toAddressInput","next","outputCapacity","lastFreezedOutput","maxBy","gt","cellCapacity","availableCapacity","sub","minimalCellCapacityCompatible","deductCapacity","eq","getInputKey","changeCell","changeCapacity","minimalChangeCapacity","previousInputs","lastOutputIndex","fixedEntryIndex","remove","fixedEntry","inputCapacity","processedArgs","createTransactionFromSkeleton","RawTransaction","signingEntries","CODE_HASH","HASH_TYPE","sumOfOutputCapacity","reduce","c","sumOfOutputAmount","unpackAmount","fInputs","sumOfInputCapacity","sumOfInputAmount","lockValue","hasher","hashWitness","j","otherInput","signingEntry","digestHex","fromInput","fromInputCapacity","inputMinimalCellCapacity","parseAddress","targetOutput","payFee","payFeeByFeeRate","registerCustomLockScriptInfos","transfer","_secp256k1_blake160_multisig","_secp256k1_blake","_locktime_pool","_anyone_can_pay","_omnilock","lockScriptInfos","configHashCode","_predefinedInfos","_customInfos","generateLockScriptInfos","getPredefinedInfos","_config","_config2","_config3","_config4","secpTemplate","SECP256K1_BLAKE160","multisigTemplate","SECP256K1_BLAKE160_MULTISIG","acpTemplate","omnilockTemplate","OMNILOCK","predefinedInfos","lockScriptInfo","hashCode","Buffer","fromInfos","amount","changeAddress","tipHeader","useLocktimeCellsFirst","LocktimePoolCellCollector","_targetLockScriptInfo","_amount","targetLockScriptInfo","enableDeductCapacity","deductAmount","injectCapacityWithoutChangeCompatible","LocktimeCellCollector","_commonTransferCompatible","_input$outPoint","_input$outPoint2","fromScripts","_deductCapacityCompatible","loop1","cellCollectors","inputKey","collectInputCompatible","needCapacity","clonedOutput","parse","lastOutput","lastOutputCapacity","lastOutputFixedEntryIndex","destroyable","_needCapacity","minimalOutputCapacity","canUseCapacity","clonedLastOutput","_txSkeleton$get$get","feeRate","newTxSkeleton","currentTransactionSize","getTransactionSize","calculateFeeCompatible","ratio","base","div","getTransactionSizeByTx","Transaction","__tests__","_commonTransfer","BigInt","resetLockScriptInfos","getLockScriptInfos","calculateFee","calculateDaoEarliestSince","calculateDaoEarliestSinceCompatible","calculateMaximumWithdraw","calculateMaximumWithdrawCompatible","deposit","extractDaoDataCompatible","listDaoCells","unlock","_common","parseSince","DEPOSIT_DAO_DATA","DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE","cellType","daoTypeScript","generateDaoScript","fromAddress","enableNonSystemScript","DAO_SCRIPT","DAO","_checkFromInfoSince","Uint64LE","toHexString","relative","_addDaoCellDep","isSecp256k1Blake160Script","isSecp256k1Blake160MultisigScript","encodeToAddress","isMultisigFromInfo","parseEpochCompatible","epoch","_epoch","shr","and","epochSinceCompatible","_length","_index","_number","shl","depositInput","withdrawInput","RpcClient","_checkDaoScript","typeScript","withdrawTypeScript","depositBlockHeader","getHeader","depositEpoch","withdrawBlockHeader","withdrawEpoch","withdrawFraction","depositFraction","depositedEpochs","lockEpochs","minimalSince","dao","depositHeaderDepIndex","headerDeps","defaultWitnessArgs","fromLockScript","depositBlockHeaderEpoch","withdrawBlockHeaderEpoch","test","startsWith","withdrawCell","depositDao","withdrawDao","toBigInt","depositAR","ar","withdrawAR","occupiedCapacity","targetOutputIndex","clonedTargetOutput","Uint64","compareScriptBinaryWithOnChainData","generateDeployWithDataTx","generateDeployWithTypeIdTx","generateUpgradeTypeIdDataTx","bytesToHex","padStart","updateOutputs","updateCellDeps","cellDeps","clear","secp256k1Config","secp256k1MultiSigConfig","completeTx","b","_feeRate","multisigScript","repeat","M","txFee","calculateTxFee","pop","serializedTx","txSize","calculateTxHash","getScriptConfig","getScriptConfigByTypeHash","computeScriptHash","getScriptConfigByDataHash","verifyFromInfo","helpers","nameOfScript","publicKeyHashes","TransactionSkeleton","scriptBinary","scriptConfig","resolved","findCellsByLock","lockScript","typeId","generateTypeIdScript","deployedCell","localHash","calculateCodeHashByBin","scriptBin","bin","valueOf","byteOffset","onChainHash","getDataHash","getTransaction","maybeMultisig","R","multisigArgs","customData","serializeMultisigScript","fromScriptArgs","address","h","join","serializedMultisigScript","sinceLE","ensureScript","isAcpAddress","isDaoScript","isOmnilockAddress","isOmnilockScript","isSecp256k1Blake160Address","isSecp256k1Blake160MultisigAddress","isSudtScript","newCellDep","cellDep","OutPointValue","SUDT","len","_p2pkh","createP2PKHMessageGroup","_dao","_deploy","secp256k1Blake160","secp256k1Blake160Multisig","locktimePool","common","sudt","anyoneCanPay","transferCompatible","_","_since","parseEpoch","maximumAbsoluteEpochSince","generateAbsoluteEpochSince","validateSince","NodeRPC","tipSinceValidationInfo","median_timestamp","List","maximumCapacity","depositBlockHash","withdrawBlockHash","sinceValidationInfo","_parseMultisigArgsSinceCompatible","transactionWithStatus","depositOutPoint","daoSince","withdrawEpochValue","fourEpochsLater","multisigSince","parseSinceCompatible","requireToAddress","assertAmountEnough","_txSkeleton","_transferCompatible","lockArgs","collectInput","assign","_minimalChangeCapacity","injectCapacityWithoutChange","decodeAddress","_bech","bech32","fromWords","decode","words","_bs","signMessage","digest","provider","internal","window","unisat","okxwallet","bitcoin","accounts","requestAccounts","digestWithout0x","signatureBase64","BTC_PREFIX","signature","base64ToHex","str","raw","atob","charCodeAt","phantom","solana","signed","TextEncoder","encode","COMMON_PREFIX","publicKey","toBytes","OmnilockWitnessLock","createOmnilockScript","_blockchain","_utils","IdentityFlagsType","OMNILOCK_AUTH_CONTENT_LENGTH","SECP256K1_SIGNATURE_PLACEHOLDER_LENGTH","ED25519_SIGNATURE_PLACEHOLDER_LENGTH","omnilockInfo","omnilockConfig","omnilockArgs","flag","auth","IdentityFlagsEthereum","content","IdentityFlagsCkb","IdentityFlagsBitcoin","authContent","IdentityFlagsSolana","Hexify","Auth","SmtProof","SmtProofEntry","mask","byteOf","proof","SmtProofEntryVec","OmniIdentity","identity","proofs","OmniIdentityOpt","omni_identity","preimage","secp256k1Template","omnilockOutPoint","secp256k1OutPoint","createWitnessLockPlaceholder","identityFlag","signatureLength","serializedLength","Uint8Array","locks","thunkableHasher","defaultCkbHasher","groups","groupInputs","lockSet","scriptHash","Map","toArray","rawTxHash","calcRawTxHash","createdTx","rawTx","version","Function","messageGroup","group","keys","messageHasher","resolveThunk","indexes","firstWitness","lengthBuffer","ArrayBuffer","view","DataView","witnessHexString","setUint32","digested","g","prototype","x","thunkOrValue","requireMultisigScript","parsedFromScript","noMultisigBefore","issueToken","ownerForSudt","packAmount","Uint128LE","sudtToken","splitChangeCell","SUDT_SCRIPT","changeOutputLockScript","sudtType","_generateSudtScript","token","toAddressInputCapacity","toAddressInputAmount","changeCellWithoutSudt","changeAmount","cellCollectorInfos","locktimePoolCellCollector","secpCollector","multisigCollector","acpCollector","isAnyoneCanPay","locktimeCellCollector","inputAmount","currentChangeCapacity","currentChangeAmount","acpChangeCell","changeOutputIndex","originOutput","minimalChangeCellCapcaity","minimalChangeCellWithoutSudtCapacity","splitFlag","module","ALPHABET","TypeError","BASE_MAP","charAt","xc","BASE","LEADER","FACTOR","iFACTOR","decodeUnsafe","source","psz","zeroes","b256","carry","it3","it4","vch","isView","pbegin","pend","b58","it1","it2","string","basex","resultFmts","getTipBlockNumber","paramsFormatters","resultFormatters","toNumber","toHeader","getCurrentEpoch","toEpoch","getEpochByNumber","formatter","getBlockHash","getBlock","toHash","getHeaderByNumber","toLiveCellWithStatus","getCellbaseOutputCapacityDetails","toCellbaseOutputCapacityDetails","getBlockEconomicState","toBlockEconomicState","getTransactionProof","toOptional","toTransactionProof","verifyTransactionProof","getConsensus","toConsensus","dryRunTransaction","toRawTransaction","calculateDaoMaximumWithdraw","rpcProperties","Base","_chain","_experimental","_net","_pool","_stats","schemas","toOrder","toGetCellsResult","toGetTransactionsResult","getCellsCapacity","toCellsCapacity","getBlockFilter","toNullable","toBlockFilter","getTransactionAndWitnessProof","toTransactionAndWitnessProof","verifyTransactionAndWitnessProof","getForkBlock","toForkBlockResult","getBlockMedianTime","estimateCycles","toEstimateCycles","getFeeRateStatistics","toFeeRateStatistics","getFeeRateStatics","localNodeInfo","toLocalNodeInfo","getPeers","toPeers","getBannedAddresses","toBannedAddresses","clearBannedAddresses","setBan","syncState","toSyncState","setNetworkActive","toBoolean","addNode","removeNode","pingPeers","sendTransaction","toOutputsValidator","txPoolInfo","toTxPoolInfo","clearTxPool","getRawTxPool","toRawTxPool","toBlockchainInfo","getDeploymentsInfo","toDeploymentsInfo","ErrorCode","PayloadInBatchException","MethodInBatchNotFoundException","IdNotMatchedInBatchException","_ErrorCode","ERROR_LABEL","code","MethodNotFound","name","PayloadMessage","IdNotMatchException","requestId","responseId","StringHashTypeException","PageSizeTooSmallException","PageSizeTooLargeException","OutputsValidatorTypeException","HexStringWithout0xException","BigintOrHexStringTypeException","RangeError","ParameterInvalid","pageSize","maxSize","minSize","_formatter","_batch","ResponseException","IdNotMatch","ResponseMessage","ParamsFormatter","DEFAULT_RPC_TIMEOUT","_Base","_method","resultFormatter","_exceptions","_abortController","url","node","paramsFormatter","setNode","fetch","defineProperties","addMethod","writable","configurable","Method","createBatchRequest","ctx","proxied","Proxy","p","methods","_p$","indexOf","Reflect","splice","exec","f","getPayload","err","controller","signal","abort","batchRes","clearTimeout","_ctx$rpcProperties$pr","_ctx$rpcProperties$pr2","_ctx$rpcProperties$pr3","_this$options$resultF","_this$options$resultF2","_this$options","round","random","format","arg","rest","toInput","previous_output","toOutput","toDepType","toCellDep","out_point","dep_type","outputs_data","header_deps","formattedInputs","formattedOutputs","formattedCellDeps","cell_deps","toPageNumber","pageNo","toPageSize","toReverseOrder","reverse","outputsValidator","witnessesRoot","witnesses_root","witnesses_proof","witnessesProof","transactions_proof","transactionsProof","toBannedAddress","toAlertMessage","uncles","toUncleBlock","toTransaction","toFeeRate","toDeploymentInfo","toDeployment","toDeployState","toCellsIncludingOutPoint","toCells","toCellIncludingOutPoint","toCell","toCapacityByLockHash","toRemoteNodeInfo","toLockHashIndexStates","toLockHashIndexState","toLiveCellsByLockHash","toLiveCell","toTransactionsByLockHash","toTransactionPoint","origin","compact_target","compactTarget","transactions_root","transactionsRoot","proposals_hash","proposalsHash","extra_hash","extraHash","parent_hash","uncleBlock","alertMessage","notice_until","noticeUntil","info","is_initial_block_download","isInitialBlockDownload","median_time","alerts","node_id","nodeId","protocols","support_versions","supportVersions","connected_duration","connectedDuration","is_outbound","isOutbound","last_ping_duration","lastPingDuration","sync_state","bestKnownHeaderHash","best_known_header_hash","bestKnownHeaderNumber","best_known_header_number","canFetchCount","can_fetch_count","inflightCount","inflight_count","lastCommonHeaderHash","last_common_header_hash","lastCommonHeaderNumber","last_common_header_number","unknownHeaderListSize","unknown_header_list_size","last_txs_updated_at","lastTxsUpdatedAt","tip_hash","tipHash","tip_number","tipNumber","total_tx_cycles","totalTxCycles","total_tx_size","totalTxSize","min_fee_rate","minFeeRate","min_rbf_rate","minRbfRate","tx_size_limit","txSizeLimit","max_tx_pool_size","maxTxPoolSize","nodes","cellWithStatus","output_data_len","outputDataLen","tx_status","time_added_to_pool","min_replace_fee","reason","start_number","startNumber","transactionPoint","consumedBy","consumed_by","createdBy","created_by","cell_output","cellbase","lock_hash","lockHash","states","bannedAddress","ban_reason","banReason","ban_until","banUntil","created_at","createdAt","bannedAddresses","banAddr","details","proposal_reward","proposalReward","tx_fee","feeRateObj","fee_rate","capacityByLockHash","cells_count","cellsCount","blockEconomicState","finalized_at","finalizedAt","miner_reward","minerReward","txs_fee","txsFee","state","bestKnownBlockNumber","best_known_block_number","bestKnownBlockTimestamp","best_known_block_timestamp","fastTime","fast_time","ibd","inflightBlocksCount","inflight_blocks_count","lowTime","low_time","normalTime","normal_time","orphanBlocksCount","orphan_blocks_count","toHardforkFeature","feature","rfc","epochNumber","epoch_number","deployment","bit","minActivationEpoch","min_activation_epoch","period","threshold","toSoftFork","softFork","rfc0043","consensus","rpcHardforkFeatures","hardfork_features","softforks","lightClient","light_client","testdummy","blockVersion","block_version","cellbaseMaturity","cellbase_maturity","daoTypeHash","dao_type_hash","epochDurationTarget","epoch_duration_target","genesisHash","genesis_hash","initialPrimaryEpochReward","initial_primary_epoch_reward","maxBlockBytes","max_block_bytes","maxBlockCycles","max_block_cycles","maxBlockProposalsLimit","max_block_proposals_limit","maxUnclesNum","max_uncles_num","medianTimeBlockCount","median_time_block_count","orphanRateTarget","orphan_rate_target","permanentDifficultyInDummy","permanent_difficulty_in_dummy","primaryEpochRewardHalvingInterval","primary_epoch_reward_halving_interval","proposerRewardRatio","proposer_reward_ratio","secondaryEpochReward","secondary_epoch_reward","secp256k1Blake160MultisigAllTypeHash","secp256k1_blake160_multisig_all_type_hash","secp256k1Blake160SighashAllTypeHash","secp256k1_blake160_sighash_all_type_hash","txProposalWindow","tx_proposal_window","txVersion","tx_version","typeIdCodeHash","type_id_code_hash","hardforkFeatures","rawTxPool","pending","isTxPoolIds","toTxVerbosity","ancestors_count","ancestorsCount","ancestors_cycles","ancestorsCycles","ancestors_size","ancestorsSize","proposed","getCellsResult","last_cursor","toIndexerCell","indexerCell","output_data","tx_index","getTransactionsResult","toIndexerTransaction","io_index","io_type","cellsCapacity","blockFilter","statistics","mean","median","proposals","extension","cycle","deploymentInfo","deployments","AbortController","AbortSignal","self"],"sourceRoot":""}
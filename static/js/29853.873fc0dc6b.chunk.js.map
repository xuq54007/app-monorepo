{"version":3,"file":"static/js/29853.873fc0dc6b.chunk.js","mappings":"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","sources":["webpack://web/../../node_modules/@emurgo/cardano-message-signing-asmjs/cardano_message_signing_bg.js","webpack://web/../../node_modules/@emurgo/cardano-serialization-lib-asmjs/cardano_serialization_lib_bg.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/constants/index.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/utils/errors.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/utils/common.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/methods/largestFirst.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/utils/logger.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/methods/randomImprove.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/types/types.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/utils/trezor/transformations.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/types/trezor.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/utils/trezor/sign.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/utils/onekey/transaction.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/utils/onekey/error.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/utils/onekey/signTx.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/utils/onekey/dapp.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/utils/onekey/txToOneKey.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/utils/onekey/index.js","webpack://web/../../node_modules/@onekeyfe/cardano-coin-selection-asmjs/lib/esm/index.js"],"sourcesContent":["import * as wasm from './cardano_message_signing.asm.js';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedTextEncoder = new TextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachegetFloat64Memory0 = null;\nfunction getFloat64Memory0() {\n    if (cachegetFloat64Memory0 === null || cachegetFloat64Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachegetFloat64Memory0;\n}\n/**\n*/\nexport const LabelKind = Object.freeze({ Int:0,\"0\":\"Int\",Text:1,\"1\":\"Text\", });\n/**\n*/\nexport const SignedMessageKind = Object.freeze({ COSESIGN:0,\"0\":\"COSESIGN\",COSESIGN1:1,\"1\":\"COSESIGN1\", });\n/**\n*/\nexport const SigContext = Object.freeze({ Signature:0,\"0\":\"Signature\",Signature1:1,\"1\":\"Signature1\",CounterSignature:2,\"2\":\"CounterSignature\", });\n/**\n*/\nexport const CBORSpecialType = Object.freeze({ Bool:0,\"0\":\"Bool\",Float:1,\"1\":\"Float\",Unassigned:2,\"2\":\"Unassigned\",Break:3,\"3\":\"Break\",Undefined:4,\"4\":\"Undefined\",Null:5,\"5\":\"Null\", });\n/**\n*/\nexport const CBORValueKind = Object.freeze({ Int:0,\"0\":\"Int\",Bytes:1,\"1\":\"Bytes\",Text:2,\"2\":\"Text\",Array:3,\"3\":\"Array\",Object:4,\"4\":\"Object\",TaggedCBOR:5,\"5\":\"TaggedCBOR\",Special:6,\"6\":\"Special\", });\n/**\n*/\nexport const AlgorithmId = Object.freeze({\n/**\n*r\" EdDSA (Pure EdDSA, not HashedEdDSA) - the algorithm used for Cardano addresses\n*/\nEdDSA:0,\"0\":\"EdDSA\",\n/**\n*r\" ChaCha20/Poly1305 w/ 256-bit key, 128-bit tag\n*/\nChaCha20Poly1305:1,\"1\":\"ChaCha20Poly1305\", });\n/**\n*/\nexport const KeyType = Object.freeze({\n/**\n*r\" octet key pair\n*/\nOKP:0,\"0\":\"OKP\",\n/**\n*r\" 2-coord EC\n*/\nEC2:1,\"1\":\"EC2\",Symmetric:2,\"2\":\"Symmetric\", });\n/**\n*/\nexport const ECKey = Object.freeze({ CRV:0,\"0\":\"CRV\",X:1,\"1\":\"X\",Y:2,\"2\":\"Y\",D:3,\"3\":\"D\", });\n/**\n*/\nexport const CurveType = Object.freeze({ P256:0,\"0\":\"P256\",P384:1,\"1\":\"P384\",P521:2,\"2\":\"P521\",X25519:3,\"3\":\"X25519\",X448:4,\"4\":\"X448\",Ed25519:5,\"5\":\"Ed25519\",Ed448:6,\"6\":\"Ed448\", });\n/**\n*/\nexport const KeyOperation = Object.freeze({ Sign:0,\"0\":\"Sign\",Verify:1,\"1\":\"Verify\",Encrypt:2,\"2\":\"Encrypt\",Decrypt:3,\"3\":\"Decrypt\",WrapKey:4,\"4\":\"WrapKey\",UnwrapKey:5,\"5\":\"UnwrapKey\",DeriveKey:6,\"6\":\"DeriveKey\",DeriveBits:7,\"7\":\"DeriveBits\", });\n/**\n*/\nexport class BigNum {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BigNum.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bignum_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BigNum}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bignum_from_bytes(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {string} string\n    * @returns {BigNum}\n    */\n    static from_str(string) {\n        var ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bignum_from_str(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_mul(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_mul(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_add(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_add(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_sub(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_sub(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n}\n/**\n*/\nexport class CBORArray {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CBORArray.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborarray_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborarray_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CBORArray}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborarray_from_bytes(ptr0, len0);\n        return CBORArray.__wrap(ret);\n    }\n    /**\n    * @returns {CBORArray}\n    */\n    static new() {\n        var ret = wasm.cborarray_new();\n        return CBORArray.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.cborarray_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {CBORValue}\n    */\n    get(index) {\n        var ret = wasm.cborarray_get(this.ptr, index);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {CBORValue} elem\n    */\n    add(elem) {\n        _assertClass(elem, CBORValue);\n        wasm.cborarray_add(this.ptr, elem.ptr);\n    }\n    /**\n    * @param {boolean} use_definite\n    */\n    set_definite_encoding(use_definite) {\n        wasm.cborarray_set_definite_encoding(this.ptr, use_definite);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_definite() {\n        var ret = wasm.cborarray_is_definite(this.ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class CBORObject {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CBORObject.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborobject_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborobject_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CBORObject}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborobject_from_bytes(ptr0, len0);\n        return CBORObject.__wrap(ret);\n    }\n    /**\n    * @returns {CBORObject}\n    */\n    static new() {\n        var ret = wasm.cborobject_new();\n        return CBORObject.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.cborobject_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {CBORValue} key\n    * @param {CBORValue} value\n    * @returns {CBORValue | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, CBORValue);\n        _assertClass(value, CBORValue);\n        var ret = wasm.cborobject_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {CBORValue} key\n    * @returns {CBORValue | undefined}\n    */\n    get(key) {\n        _assertClass(key, CBORValue);\n        var ret = wasm.cborobject_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n    * @returns {CBORArray}\n    */\n    keys() {\n        var ret = wasm.cborobject_keys(this.ptr);\n        return CBORArray.__wrap(ret);\n    }\n    /**\n    * @param {boolean} use_definite\n    */\n    set_definite_encoding(use_definite) {\n        wasm.cborobject_set_definite_encoding(this.ptr, use_definite);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_definite() {\n        var ret = wasm.cborobject_is_definite(this.ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class CBORSpecial {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CBORSpecial.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborspecial_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborspecial_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CBORSpecial}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborspecial_from_bytes(ptr0, len0);\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @param {boolean} b\n    * @returns {CBORSpecial}\n    */\n    static new_bool(b) {\n        var ret = wasm.cborspecial_new_bool(b);\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @param {number} u\n    * @returns {CBORSpecial}\n    */\n    static new_unassigned(u) {\n        var ret = wasm.cborspecial_new_unassigned(u);\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @returns {CBORSpecial}\n    */\n    static new_break() {\n        var ret = wasm.cborspecial_new_break();\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @returns {CBORSpecial}\n    */\n    static new_null() {\n        var ret = wasm.cborspecial_new_null();\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @returns {CBORSpecial}\n    */\n    static new_undefined() {\n        var ret = wasm.cborspecial_new_undefined();\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.cborspecial_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {boolean | undefined}\n    */\n    as_bool() {\n        var ret = wasm.cborspecial_as_bool(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    as_float() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborspecial_as_float(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    as_unassigned() {\n        var ret = wasm.cborspecial_as_unassigned(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n}\n/**\n*/\nexport class CBORValue {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CBORValue.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborvalue_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborvalue_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CBORValue}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborvalue_from_bytes(ptr0, len0);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {Int} int\n    * @returns {CBORValue}\n    */\n    static new_int(int) {\n        _assertClass(int, Int);\n        var ret = wasm.cborvalue_new_int(int.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CBORValue}\n    */\n    static new_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborvalue_new_bytes(ptr0, len0);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {string} text\n    * @returns {CBORValue}\n    */\n    static new_text(text) {\n        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborvalue_new_text(ptr0, len0);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {CBORArray} arr\n    * @returns {CBORValue}\n    */\n    static new_array(arr) {\n        _assertClass(arr, CBORArray);\n        var ret = wasm.cborvalue_new_array(arr.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {CBORObject} obj\n    * @returns {CBORValue}\n    */\n    static new_object(obj) {\n        _assertClass(obj, CBORObject);\n        var ret = wasm.cborvalue_new_object(obj.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {TaggedCBOR} tagged\n    * @returns {CBORValue}\n    */\n    static new_tagged(tagged) {\n        _assertClass(tagged, TaggedCBOR);\n        var ret = wasm.cborvalue_new_tagged(tagged.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {CBORSpecial} special\n    * @returns {CBORValue}\n    */\n    static new_special(special) {\n        _assertClass(special, CBORSpecial);\n        var ret = wasm.cborvalue_new_special(special.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {Label} label\n    * @returns {CBORValue}\n    */\n    static from_label(label) {\n        _assertClass(label, Label);\n        var ret = wasm.cborvalue_from_label(label.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.cborvalue_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Int | undefined}\n    */\n    as_int() {\n        var ret = wasm.cborvalue_as_int(this.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborvalue_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string | undefined}\n    */\n    as_text() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborvalue_as_text(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {CBORArray | undefined}\n    */\n    as_array() {\n        var ret = wasm.cborvalue_as_array(this.ptr);\n        return ret === 0 ? undefined : CBORArray.__wrap(ret);\n    }\n    /**\n    * @returns {CBORObject | undefined}\n    */\n    as_object() {\n        var ret = wasm.cborvalue_as_object(this.ptr);\n        return ret === 0 ? undefined : CBORObject.__wrap(ret);\n    }\n    /**\n    * @returns {TaggedCBOR | undefined}\n    */\n    as_tagged() {\n        var ret = wasm.cborvalue_as_tagged(this.ptr);\n        return ret === 0 ? undefined : TaggedCBOR.__wrap(ret);\n    }\n    /**\n    * @returns {CBORSpecial | undefined}\n    */\n    as_special() {\n        var ret = wasm.cborvalue_as_special(this.ptr);\n        return ret === 0 ? undefined : CBORSpecial.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSEEncrypt {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSEEncrypt.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coseencrypt_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSEEncrypt}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coseencrypt_from_bytes(ptr0, len0);\n        return COSEEncrypt.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    ciphertext() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {COSERecipients}\n    */\n    recipients() {\n        var ret = wasm.coseencrypt_recipients(this.ptr);\n        return COSERecipients.__wrap(ret);\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array | undefined} ciphertext\n    * @param {COSERecipients} recipients\n    * @returns {COSEEncrypt}\n    */\n    static new(headers, ciphertext, recipients) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(ciphertext) ? 0 : passArray8ToWasm0(ciphertext, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(recipients, COSERecipients);\n        var ret = wasm.coseencrypt_new(headers.ptr, ptr0, len0, recipients.ptr);\n        return COSEEncrypt.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSEEncrypt0 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSEEncrypt0.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coseencrypt0_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSEEncrypt0}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coseencrypt0_from_bytes(ptr0, len0);\n        return COSEEncrypt0.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    ciphertext() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array | undefined} ciphertext\n    * @returns {COSEEncrypt0}\n    */\n    static new(headers, ciphertext) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(ciphertext) ? 0 : passArray8ToWasm0(ciphertext, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coseencrypt0_new(headers.ptr, ptr0, len0);\n        return COSEEncrypt0.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSEKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSEKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosekey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSEKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosekey_from_bytes(ptr0, len0);\n        return COSEKey.__wrap(ret);\n    }\n    /**\n    * @param {Label} key_type\n    */\n    set_key_type(key_type) {\n        _assertClass(key_type, Label);\n        wasm.cosekey_set_key_type(this.ptr, key_type.ptr);\n    }\n    /**\n    * @returns {Label}\n    */\n    key_type() {\n        var ret = wasm.cosekey_key_type(this.ptr);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} key_id\n    */\n    set_key_id(key_id) {\n        var ptr0 = passArray8ToWasm0(key_id, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosekey_set_key_id(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    key_id() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_key_id(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Label} algorithm_id\n    */\n    set_algorithm_id(algorithm_id) {\n        _assertClass(algorithm_id, Label);\n        wasm.cosekey_set_algorithm_id(this.ptr, algorithm_id.ptr);\n    }\n    /**\n    * @returns {Label | undefined}\n    */\n    algorithm_id() {\n        var ret = wasm.cosekey_algorithm_id(this.ptr);\n        return ret === 0 ? undefined : Label.__wrap(ret);\n    }\n    /**\n    * @param {Labels} key_ops\n    */\n    set_key_ops(key_ops) {\n        _assertClass(key_ops, Labels);\n        wasm.cosekey_set_key_ops(this.ptr, key_ops.ptr);\n    }\n    /**\n    * @returns {Labels | undefined}\n    */\n    key_ops() {\n        var ret = wasm.cosekey_key_ops(this.ptr);\n        return ret === 0 ? undefined : Labels.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} base_init_vector\n    */\n    set_base_init_vector(base_init_vector) {\n        var ptr0 = passArray8ToWasm0(base_init_vector, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosekey_set_base_init_vector(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    base_init_vector() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_base_init_vector(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Label} label\n    * @returns {CBORValue | undefined}\n    */\n    header(label) {\n        _assertClass(label, Label);\n        var ret = wasm.cosekey_header(this.ptr, label.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {Label} label\n    * @param {CBORValue} value\n    */\n    set_header(label, value) {\n        _assertClass(label, Label);\n        _assertClass(value, CBORValue);\n        wasm.cosekey_set_header(this.ptr, label.ptr, value.ptr);\n    }\n    /**\n    * @param {Label} key_type\n    * @returns {COSEKey}\n    */\n    static new(key_type) {\n        _assertClass(key_type, Label);\n        var ret = wasm.cosekey_new(key_type.ptr);\n        return COSEKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSERecipient {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSERecipient.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coserecipient_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coserecipient_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSERecipient}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coserecipient_from_bytes(ptr0, len0);\n        return COSERecipient.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    ciphertext() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array | undefined} ciphertext\n    * @returns {COSERecipient}\n    */\n    static new(headers, ciphertext) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(ciphertext) ? 0 : passArray8ToWasm0(ciphertext, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coseencrypt0_new(headers.ptr, ptr0, len0);\n        return COSERecipient.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSERecipients {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSERecipients.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coserecipients_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coserecipients_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSERecipients}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coserecipients_from_bytes(ptr0, len0);\n        return COSERecipients.__wrap(ret);\n    }\n    /**\n    * @returns {COSERecipients}\n    */\n    static new() {\n        var ret = wasm.coserecipients_new();\n        return COSERecipients.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.coserecipients_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {COSERecipient}\n    */\n    get(index) {\n        var ret = wasm.coserecipients_get(this.ptr, index);\n        return COSERecipient.__wrap(ret);\n    }\n    /**\n    * @param {COSERecipient} elem\n    */\n    add(elem) {\n        _assertClass(elem, COSERecipient);\n        wasm.coserecipients_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class COSESign {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESign.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesign_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesign_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSESign}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign_from_bytes(ptr0, len0);\n        return COSESign.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    payload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {COSESignatures}\n    */\n    signatures() {\n        var ret = wasm.cosesign_signatures(this.ptr);\n        return COSESignatures.__wrap(ret);\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array | undefined} payload\n    * @param {COSESignatures} signatures\n    * @returns {COSESign}\n    */\n    static new(headers, payload, signatures) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(payload) ? 0 : passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(signatures, COSESignatures);\n        var ret = wasm.cosesign_new(headers.ptr, ptr0, len0, signatures.ptr);\n        return COSESign.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSESign1 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESign1.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesign1_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesign1_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSESign1}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1_from_bytes(ptr0, len0);\n        return COSESign1.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    payload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    signature() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesign1_signature(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * For verifying, we will want to reverse-construct this SigStructure to check the signature against\n    * # Arguments\n    * * `external_aad` - External application data - see RFC 8152 section 4.3. Set to None if not using this.\n    * @param {Uint8Array | undefined} external_aad\n    * @param {Uint8Array | undefined} external_payload\n    * @returns {SigStructure}\n    */\n    signed_data(external_aad, external_payload) {\n        var ptr0 = isLikeNone(external_aad) ? 0 : passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(external_payload) ? 0 : passArray8ToWasm0(external_payload, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1_signed_data(this.ptr, ptr0, len0, ptr1, len1);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array | undefined} payload\n    * @param {Uint8Array} signature\n    * @returns {COSESign1}\n    */\n    static new(headers, payload, signature) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(payload) ? 0 : passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1_new(headers.ptr, ptr0, len0, ptr1, len1);\n        return COSESign1.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSESign1Builder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESign1Builder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesign1builder_free(ptr);\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array} payload\n    * @param {boolean} is_payload_external\n    * @returns {COSESign1Builder}\n    */\n    static new(headers, payload, is_payload_external) {\n        _assertClass(headers, Headers);\n        var ptr0 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1builder_new(headers.ptr, ptr0, len0, is_payload_external);\n        return COSESign1Builder.__wrap(ret);\n    }\n    /**\n    */\n    hash_payload() {\n        wasm.cosesign1builder_hash_payload(this.ptr);\n    }\n    /**\n    * @param {Uint8Array} external_aad\n    */\n    set_external_aad(external_aad) {\n        var ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosesign1builder_set_external_aad(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {SigStructure}\n    */\n    make_data_to_sign() {\n        var ret = wasm.cosesign1builder_make_data_to_sign(this.ptr);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} signed_sig_structure\n    * @returns {COSESign1}\n    */\n    build(signed_sig_structure) {\n        var ptr0 = passArray8ToWasm0(signed_sig_structure, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1builder_build(this.ptr, ptr0, len0);\n        return COSESign1.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSESignBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESignBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesignbuilder_free(ptr);\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array} payload\n    * @param {boolean} is_payload_external\n    * @returns {COSESignBuilder}\n    */\n    static new(headers, payload, is_payload_external) {\n        _assertClass(headers, Headers);\n        var ptr0 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesignbuilder_new(headers.ptr, ptr0, len0, is_payload_external);\n        return COSESignBuilder.__wrap(ret);\n    }\n    /**\n    */\n    hash_payload() {\n        wasm.cosesign1builder_hash_payload(this.ptr);\n    }\n    /**\n    * @param {Uint8Array} external_aad\n    */\n    set_external_aad(external_aad) {\n        var ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosesign1builder_set_external_aad(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {SigStructure}\n    */\n    make_data_to_sign() {\n        var ret = wasm.cosesignbuilder_make_data_to_sign(this.ptr);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n    * @param {COSESignatures} signed_sig_structure\n    * @returns {COSESign}\n    */\n    build(signed_sig_structure) {\n        _assertClass(signed_sig_structure, COSESignatures);\n        var ret = wasm.cosesignbuilder_build(this.ptr, signed_sig_structure.ptr);\n        return COSESign.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSESignature {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESignature.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesignature_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesignature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSESignature}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesignature_from_bytes(ptr0, len0);\n        return COSESignature.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    signature() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesignature_signature(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array} signature\n    * @returns {COSESignature}\n    */\n    static new(headers, signature) {\n        _assertClass(headers, Headers);\n        var ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesignature_new(headers.ptr, ptr0, len0);\n        return COSESignature.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSESignatures {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESignatures.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesignatures_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesignatures_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSESignatures}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesignatures_from_bytes(ptr0, len0);\n        return COSESignatures.__wrap(ret);\n    }\n    /**\n    * @returns {COSESignatures}\n    */\n    static new() {\n        var ret = wasm.coserecipients_new();\n        return COSESignatures.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.coserecipients_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {COSESignature}\n    */\n    get(index) {\n        var ret = wasm.cosesignatures_get(this.ptr, index);\n        return COSESignature.__wrap(ret);\n    }\n    /**\n    * @param {COSESignature} elem\n    */\n    add(elem) {\n        _assertClass(elem, COSESignature);\n        wasm.cosesignatures_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class CounterSignature {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CounterSignature.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_countersignature_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.countersignature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CounterSignature}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.countersignature_from_bytes(ptr0, len0);\n        return CounterSignature.__wrap(ret);\n    }\n    /**\n    * @param {COSESignature} cose_signature\n    * @returns {CounterSignature}\n    */\n    static new_single(cose_signature) {\n        _assertClass(cose_signature, COSESignature);\n        var ret = wasm.countersignature_new_single(cose_signature.ptr);\n        return CounterSignature.__wrap(ret);\n    }\n    /**\n    * @param {COSESignatures} cose_signatures\n    * @returns {CounterSignature}\n    */\n    static new_multi(cose_signatures) {\n        _assertClass(cose_signatures, COSESignatures);\n        var ret = wasm.countersignature_new_multi(cose_signatures.ptr);\n        return CounterSignature.__wrap(ret);\n    }\n    /**\n    * @returns {COSESignatures}\n    */\n    signatures() {\n        var ret = wasm.countersignature_signatures(this.ptr);\n        return COSESignatures.__wrap(ret);\n    }\n}\n/**\n*/\nexport class EdDSA25519Key {\n\n    static __wrap(ptr) {\n        const obj = Object.create(EdDSA25519Key.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_eddsa25519key_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} pubkey_bytes\n    * @returns {EdDSA25519Key}\n    */\n    static new(pubkey_bytes) {\n        var ptr0 = passArray8ToWasm0(pubkey_bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.eddsa25519key_new(ptr0, len0);\n        return EdDSA25519Key.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} private_key_bytes\n    */\n    set_private_key(private_key_bytes) {\n        var ptr0 = passArray8ToWasm0(private_key_bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.eddsa25519key_set_private_key(this.ptr, ptr0, len0);\n    }\n    /**\n    */\n    is_for_signing() {\n        wasm.eddsa25519key_is_for_signing(this.ptr);\n    }\n    /**\n    */\n    is_for_verifying() {\n        wasm.eddsa25519key_is_for_verifying(this.ptr);\n    }\n    /**\n    * @returns {COSEKey}\n    */\n    build() {\n        var ret = wasm.eddsa25519key_build(this.ptr);\n        return COSEKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class HeaderMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(HeaderMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_headermap_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headermap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {HeaderMap}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.headermap_from_bytes(ptr0, len0);\n        return HeaderMap.__wrap(ret);\n    }\n    /**\n    * @param {Label} algorithm_id\n    */\n    set_algorithm_id(algorithm_id) {\n        _assertClass(algorithm_id, Label);\n        wasm.headermap_set_algorithm_id(this.ptr, algorithm_id.ptr);\n    }\n    /**\n    * @returns {Label | undefined}\n    */\n    algorithm_id() {\n        var ret = wasm.headermap_algorithm_id(this.ptr);\n        return ret === 0 ? undefined : Label.__wrap(ret);\n    }\n    /**\n    * @param {Labels} criticality\n    */\n    set_criticality(criticality) {\n        _assertClass(criticality, Labels);\n        wasm.headermap_set_criticality(this.ptr, criticality.ptr);\n    }\n    /**\n    * @returns {Labels | undefined}\n    */\n    criticality() {\n        var ret = wasm.headermap_criticality(this.ptr);\n        return ret === 0 ? undefined : Labels.__wrap(ret);\n    }\n    /**\n    * @param {Label} content_type\n    */\n    set_content_type(content_type) {\n        _assertClass(content_type, Label);\n        wasm.cosekey_set_algorithm_id(this.ptr, content_type.ptr);\n    }\n    /**\n    * @returns {Label | undefined}\n    */\n    content_type() {\n        var ret = wasm.cosekey_algorithm_id(this.ptr);\n        return ret === 0 ? undefined : Label.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} key_id\n    */\n    set_key_id(key_id) {\n        var ptr0 = passArray8ToWasm0(key_id, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.headermap_set_key_id(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    key_id() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headermap_key_id(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} init_vector\n    */\n    set_init_vector(init_vector) {\n        var ptr0 = passArray8ToWasm0(init_vector, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosekey_set_base_init_vector(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    init_vector() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_base_init_vector(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} partial_init_vector\n    */\n    set_partial_init_vector(partial_init_vector) {\n        var ptr0 = passArray8ToWasm0(partial_init_vector, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.headermap_set_partial_init_vector(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    partial_init_vector() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headermap_partial_init_vector(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {CounterSignature} counter_signature\n    */\n    set_counter_signature(counter_signature) {\n        _assertClass(counter_signature, CounterSignature);\n        wasm.headermap_set_counter_signature(this.ptr, counter_signature.ptr);\n    }\n    /**\n    * @returns {CounterSignature | undefined}\n    */\n    counter_signature() {\n        var ret = wasm.headermap_counter_signature(this.ptr);\n        return ret === 0 ? undefined : CounterSignature.__wrap(ret);\n    }\n    /**\n    * @param {Label} label\n    * @returns {CBORValue | undefined}\n    */\n    header(label) {\n        _assertClass(label, Label);\n        var ret = wasm.headermap_header(this.ptr, label.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {Label} label\n    * @param {CBORValue} value\n    */\n    set_header(label, value) {\n        _assertClass(label, Label);\n        _assertClass(value, CBORValue);\n        wasm.headermap_set_header(this.ptr, label.ptr, value.ptr);\n    }\n    /**\n    * @returns {Labels}\n    */\n    keys() {\n        var ret = wasm.headermap_keys(this.ptr);\n        return Labels.__wrap(ret);\n    }\n    /**\n    * @returns {HeaderMap}\n    */\n    static new() {\n        var ret = wasm.headermap_new();\n        return HeaderMap.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Headers {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Headers.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_headers_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headers_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Headers}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.headers_from_bytes(ptr0, len0);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {ProtectedHeaderMap}\n    */\n    protected() {\n        var ret = wasm.headers_protected(this.ptr);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @returns {HeaderMap}\n    */\n    unprotected() {\n        var ret = wasm.headers_unprotected(this.ptr);\n        return HeaderMap.__wrap(ret);\n    }\n    /**\n    * @param {ProtectedHeaderMap} protected_\n    * @param {HeaderMap} unprotected_\n    * @returns {Headers}\n    */\n    static new(protected_, unprotected_) {\n        _assertClass(protected_, ProtectedHeaderMap);\n        _assertClass(unprotected_, HeaderMap);\n        var ret = wasm.headers_new(protected_.ptr, unprotected_.ptr);\n        return Headers.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Int {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Int.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_int_free(ptr);\n    }\n    /**\n    * @param {BigNum} x\n    * @returns {Int}\n    */\n    static new(x) {\n        _assertClass(x, BigNum);\n        var ptr0 = x.ptr;\n        x.ptr = 0;\n        var ret = wasm.int_new(ptr0);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} x\n    * @returns {Int}\n    */\n    static new_negative(x) {\n        _assertClass(x, BigNum);\n        var ptr0 = x.ptr;\n        x.ptr = 0;\n        var ret = wasm.int_new_negative(ptr0);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {number} x\n    * @returns {Int}\n    */\n    static new_i32(x) {\n        var ret = wasm.int_new_i32(x);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_positive() {\n        var ret = wasm.int_is_positive(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_positive() {\n        var ret = wasm.int_as_positive(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_negative() {\n        var ret = wasm.int_as_negative(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    as_i32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_as_i32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class Label {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Label.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_label_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.label_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Label}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.label_from_bytes(ptr0, len0);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {Int} int\n    * @returns {Label}\n    */\n    static new_int(int) {\n        _assertClass(int, Int);\n        var ret = wasm.label_new_int(int.ptr);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {string} text\n    * @returns {Label}\n    */\n    static new_text(text) {\n        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.label_new_text(ptr0, len0);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.label_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Int | undefined}\n    */\n    as_int() {\n        var ret = wasm.label_as_int(this.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @returns {string | undefined}\n    */\n    as_text() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.label_as_text(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} id\n    * @returns {Label}\n    */\n    static from_algorithm_id(id) {\n        var ret = wasm.label_from_algorithm_id(id);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {number} key_type\n    * @returns {Label}\n    */\n    static from_key_type(key_type) {\n        var ret = wasm.label_from_key_type(key_type);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {number} ec_key\n    * @returns {Label}\n    */\n    static from_ec_key(ec_key) {\n        var ret = wasm.label_from_ec_key(ec_key);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {number} curve_type\n    * @returns {Label}\n    */\n    static from_curve_type(curve_type) {\n        var ret = wasm.label_from_curve_type(curve_type);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {number} key_op\n    * @returns {Label}\n    */\n    static from_key_operation(key_op) {\n        var ret = wasm.label_from_key_operation(key_op);\n        return Label.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Labels {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Labels.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_labels_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.labels_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Labels}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.labels_from_bytes(ptr0, len0);\n        return Labels.__wrap(ret);\n    }\n    /**\n    * @returns {Labels}\n    */\n    static new() {\n        var ret = wasm.coserecipients_new();\n        return Labels.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.coserecipients_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Label}\n    */\n    get(index) {\n        var ret = wasm.labels_get(this.ptr, index);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {Label} elem\n    */\n    add(elem) {\n        _assertClass(elem, Label);\n        wasm.labels_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class PasswordEncryption {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PasswordEncryption.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_passwordencryption_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.passwordencryption_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PasswordEncryption}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.passwordencryption_from_bytes(ptr0, len0);\n        return PasswordEncryption.__wrap(ret);\n    }\n    /**\n    * @param {COSEEncrypt0} data\n    * @returns {PasswordEncryption}\n    */\n    static new(data) {\n        _assertClass(data, COSEEncrypt0);\n        var ret = wasm.passwordencryption_new(data.ptr);\n        return PasswordEncryption.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ProtectedHeaderMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProtectedHeaderMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_protectedheadermap_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protectedheadermap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProtectedHeaderMap}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.protectedheadermap_from_bytes(ptr0, len0);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @returns {ProtectedHeaderMap}\n    */\n    static new_empty() {\n        var ret = wasm.protectedheadermap_new_empty();\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @param {HeaderMap} header_map\n    * @returns {ProtectedHeaderMap}\n    */\n    static new(header_map) {\n        _assertClass(header_map, HeaderMap);\n        var ret = wasm.protectedheadermap_new(header_map.ptr);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @returns {HeaderMap}\n    */\n    deserialized_headers() {\n        var ret = wasm.protectedheadermap_deserialized_headers(this.ptr);\n        return HeaderMap.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PubKeyEncryption {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PubKeyEncryption.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pubkeyencryption_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.pubkeyencryption_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PubKeyEncryption}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.pubkeyencryption_from_bytes(ptr0, len0);\n        return PubKeyEncryption.__wrap(ret);\n    }\n    /**\n    * @param {COSEEncrypt} data\n    * @returns {PubKeyEncryption}\n    */\n    static new(data) {\n        _assertClass(data, COSEEncrypt);\n        var ret = wasm.pubkeyencryption_new(data.ptr);\n        return PubKeyEncryption.__wrap(ret);\n    }\n}\n/**\n*/\nexport class SigStructure {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SigStructure.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_sigstructure_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sigstructure_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {SigStructure}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.sigstructure_from_bytes(ptr0, len0);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    context() {\n        var ret = wasm.sigstructure_context(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {ProtectedHeaderMap}\n    */\n    body_protected() {\n        var ret = wasm.sigstructure_body_protected(this.ptr);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @returns {ProtectedHeaderMap | undefined}\n    */\n    sign_protected() {\n        var ret = wasm.sigstructure_sign_protected(this.ptr);\n        return ret === 0 ? undefined : ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    external_aad() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sigstructure_external_aad(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    payload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sigstructure_payload(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {ProtectedHeaderMap} sign_protected\n    */\n    set_sign_protected(sign_protected) {\n        _assertClass(sign_protected, ProtectedHeaderMap);\n        wasm.sigstructure_set_sign_protected(this.ptr, sign_protected.ptr);\n    }\n    /**\n    * @param {number} context\n    * @param {ProtectedHeaderMap} body_protected\n    * @param {Uint8Array} external_aad\n    * @param {Uint8Array} payload\n    * @returns {SigStructure}\n    */\n    static new(context, body_protected, external_aad, payload) {\n        _assertClass(body_protected, ProtectedHeaderMap);\n        var ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.sigstructure_new(context, body_protected.ptr, ptr0, len0, ptr1, len1);\n        return SigStructure.__wrap(ret);\n    }\n}\n/**\n*/\nexport class SignedMessage {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SignedMessage.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signedmessage_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signedmessage_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {SignedMessage}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.signedmessage_from_bytes(ptr0, len0);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n    * @param {COSESign} cose_sign\n    * @returns {SignedMessage}\n    */\n    static new_cose_sign(cose_sign) {\n        _assertClass(cose_sign, COSESign);\n        var ret = wasm.signedmessage_new_cose_sign(cose_sign.ptr);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n    * @param {COSESign1} cose_sign1\n    * @returns {SignedMessage}\n    */\n    static new_cose_sign1(cose_sign1) {\n        _assertClass(cose_sign1, COSESign1);\n        var ret = wasm.signedmessage_new_cose_sign1(cose_sign1.ptr);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n    * @param {string} s\n    * @returns {SignedMessage}\n    */\n    static from_user_facing_encoding(s) {\n        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.signedmessage_from_user_facing_encoding(ptr0, len0);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_user_facing_encoding() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signedmessage_to_user_facing_encoding(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.signedmessage_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {COSESign | undefined}\n    */\n    as_cose_sign() {\n        var ret = wasm.signedmessage_as_cose_sign(this.ptr);\n        return ret === 0 ? undefined : COSESign.__wrap(ret);\n    }\n    /**\n    * @returns {COSESign1 | undefined}\n    */\n    as_cose_sign1() {\n        var ret = wasm.signedmessage_as_cose_sign1(this.ptr);\n        return ret === 0 ? undefined : COSESign1.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TaggedCBOR {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TaggedCBOR.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_taggedcbor_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.taggedcbor_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TaggedCBOR}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.taggedcbor_from_bytes(ptr0, len0);\n        return TaggedCBOR.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    tag() {\n        var ret = wasm.taggedcbor_tag(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {CBORValue}\n    */\n    value() {\n        var ret = wasm.taggedcbor_value(this.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} tag\n    * @param {CBORValue} value\n    * @returns {TaggedCBOR}\n    */\n    static new(tag, value) {\n        _assertClass(tag, BigNum);\n        var ptr0 = tag.ptr;\n        tag.ptr = 0;\n        _assertClass(value, CBORValue);\n        var ret = wasm.taggedcbor_new(ptr0, value.ptr);\n        return TaggedCBOR.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_string_new(arg0, arg1) {\n    var ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_debug_string(arg0, arg1) {\n    var ret = debugString(getObject(arg1));\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_rethrow(arg0) {\n    throw takeObject(arg0);\n};\n\n","import * as wasm from './cardano_serialization_lib.asm.js';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {Transaction} tx\n* @param {LinearFee} linear_fee\n* @returns {BigNum}\n*/\nexport function min_fee(tx, linear_fee) {\n    _assertClass(tx, Transaction);\n    _assertClass(linear_fee, LinearFee);\n    var ret = wasm.min_fee(tx.ptr, linear_fee.ptr);\n    return BigNum.__wrap(ret);\n}\n\n/**\n* @param {ExUnits} ex_units\n* @param {ExUnitPrices} ex_unit_prices\n* @returns {BigNum}\n*/\nexport function calculate_ex_units_ceil_cost(ex_units, ex_unit_prices) {\n    _assertClass(ex_units, ExUnits);\n    _assertClass(ex_unit_prices, ExUnitPrices);\n    var ret = wasm.calculate_ex_units_ceil_cost(ex_units.ptr, ex_unit_prices.ptr);\n    return BigNum.__wrap(ret);\n}\n\n/**\n* @param {Transaction} tx\n* @param {ExUnitPrices} ex_unit_prices\n* @returns {BigNum}\n*/\nexport function min_script_fee(tx, ex_unit_prices) {\n    _assertClass(tx, Transaction);\n    _assertClass(ex_unit_prices, ExUnitPrices);\n    var ret = wasm.min_script_fee(tx.ptr, ex_unit_prices.ptr);\n    return BigNum.__wrap(ret);\n}\n\n/**\n* @param {string} password\n* @param {string} salt\n* @param {string} nonce\n* @param {string} data\n* @returns {string}\n*/\nexport function encrypt_with_password(password, salt, nonce, data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passStringToWasm0(password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(salt, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = passStringToWasm0(nonce, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        var ptr3 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len3 = WASM_VECTOR_LEN;\n        wasm.encrypt_with_password(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\n/**\n* @param {string} password\n* @param {string} data\n* @returns {string}\n*/\nexport function decrypt_with_password(password, data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passStringToWasm0(password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        wasm.decrypt_with_password(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\n/**\n* @param {TransactionHash} tx_body_hash\n* @param {ByronAddress} addr\n* @param {LegacyDaedalusPrivateKey} key\n* @returns {BootstrapWitness}\n*/\nexport function make_daedalus_bootstrap_witness(tx_body_hash, addr, key) {\n    _assertClass(tx_body_hash, TransactionHash);\n    _assertClass(addr, ByronAddress);\n    _assertClass(key, LegacyDaedalusPrivateKey);\n    var ret = wasm.make_daedalus_bootstrap_witness(tx_body_hash.ptr, addr.ptr, key.ptr);\n    return BootstrapWitness.__wrap(ret);\n}\n\n/**\n* @param {TransactionHash} tx_body_hash\n* @param {ByronAddress} addr\n* @param {Bip32PrivateKey} key\n* @returns {BootstrapWitness}\n*/\nexport function make_icarus_bootstrap_witness(tx_body_hash, addr, key) {\n    _assertClass(tx_body_hash, TransactionHash);\n    _assertClass(addr, ByronAddress);\n    _assertClass(key, Bip32PrivateKey);\n    var ret = wasm.make_icarus_bootstrap_witness(tx_body_hash.ptr, addr.ptr, key.ptr);\n    return BootstrapWitness.__wrap(ret);\n}\n\n/**\n* @param {TransactionHash} tx_body_hash\n* @param {PrivateKey} sk\n* @returns {Vkeywitness}\n*/\nexport function make_vkey_witness(tx_body_hash, sk) {\n    _assertClass(tx_body_hash, TransactionHash);\n    _assertClass(sk, PrivateKey);\n    var ret = wasm.make_vkey_witness(tx_body_hash.ptr, sk.ptr);\n    return Vkeywitness.__wrap(ret);\n}\n\n/**\n* @param {AuxiliaryData} auxiliary_data\n* @returns {AuxiliaryDataHash}\n*/\nexport function hash_auxiliary_data(auxiliary_data) {\n    _assertClass(auxiliary_data, AuxiliaryData);\n    var ret = wasm.hash_auxiliary_data(auxiliary_data.ptr);\n    return AuxiliaryDataHash.__wrap(ret);\n}\n\n/**\n* @param {TransactionBody} tx_body\n* @returns {TransactionHash}\n*/\nexport function hash_transaction(tx_body) {\n    _assertClass(tx_body, TransactionBody);\n    var ret = wasm.hash_transaction(tx_body.ptr);\n    return TransactionHash.__wrap(ret);\n}\n\n/**\n* @param {PlutusData} plutus_data\n* @returns {DataHash}\n*/\nexport function hash_plutus_data(plutus_data) {\n    _assertClass(plutus_data, PlutusData);\n    var ret = wasm.hash_plutus_data(plutus_data.ptr);\n    return DataHash.__wrap(ret);\n}\n\n/**\n* @param {Redeemers} redeemers\n* @param {Costmdls} cost_models\n* @param {PlutusList | undefined} datums\n* @returns {ScriptDataHash}\n*/\nexport function hash_script_data(redeemers, cost_models, datums) {\n    _assertClass(redeemers, Redeemers);\n    _assertClass(cost_models, Costmdls);\n    let ptr0 = 0;\n    if (!isLikeNone(datums)) {\n        _assertClass(datums, PlutusList);\n        ptr0 = datums.ptr;\n        datums.ptr = 0;\n    }\n    var ret = wasm.hash_script_data(redeemers.ptr, cost_models.ptr, ptr0);\n    return ScriptDataHash.__wrap(ret);\n}\n\n/**\n* @param {TransactionBody} txbody\n* @param {BigNum} pool_deposit\n* @param {BigNum} key_deposit\n* @returns {Value}\n*/\nexport function get_implicit_input(txbody, pool_deposit, key_deposit) {\n    _assertClass(txbody, TransactionBody);\n    _assertClass(pool_deposit, BigNum);\n    _assertClass(key_deposit, BigNum);\n    var ret = wasm.get_implicit_input(txbody.ptr, pool_deposit.ptr, key_deposit.ptr);\n    return Value.__wrap(ret);\n}\n\n/**\n* @param {TransactionBody} txbody\n* @param {BigNum} pool_deposit\n* @param {BigNum} key_deposit\n* @returns {BigNum}\n*/\nexport function get_deposit(txbody, pool_deposit, key_deposit) {\n    _assertClass(txbody, TransactionBody);\n    _assertClass(pool_deposit, BigNum);\n    _assertClass(key_deposit, BigNum);\n    var ret = wasm.get_deposit(txbody.ptr, pool_deposit.ptr, key_deposit.ptr);\n    return BigNum.__wrap(ret);\n}\n\n/**\n*returns minimal amount of ada for the output for case when the amount is included to the output\n* @param {TransactionOutput} output\n* @param {DataCost} data_cost\n* @returns {BigNum}\n*/\nexport function min_ada_for_output(output, data_cost) {\n    _assertClass(output, TransactionOutput);\n    _assertClass(data_cost, DataCost);\n    var ret = wasm.min_ada_for_output(output.ptr, data_cost.ptr);\n    return BigNum.__wrap(ret);\n}\n\n/**\n* !!! DEPRECATED !!!\n* This function uses outdated set of arguments.\n* Use `min_ada_for_output` instead\n* @param {Value} assets\n* @param {boolean} has_data_hash\n* @param {BigNum} coins_per_utxo_word\n* @returns {BigNum}\n*/\nexport function min_ada_required(assets, has_data_hash, coins_per_utxo_word) {\n    _assertClass(assets, Value);\n    _assertClass(coins_per_utxo_word, BigNum);\n    var ret = wasm.min_ada_required(assets.ptr, has_data_hash, coins_per_utxo_word.ptr);\n    return BigNum.__wrap(ret);\n}\n\n/**\n* Receives a script JSON string\n* and returns a NativeScript.\n* Cardano Wallet and Node styles are supported.\n*\n* * wallet: https://github.com/input-output-hk/cardano-wallet/blob/master/specifications/api/swagger.yaml\n* * node: https://github.com/input-output-hk/cardano-node/blob/master/doc/reference/simple-scripts.md\n*\n* self_xpub is expected to be a Bip32PublicKey as hex-encoded bytes\n* @param {string} json\n* @param {string} self_xpub\n* @param {number} schema\n* @returns {NativeScript}\n*/\nexport function encode_json_str_to_native_script(json, self_xpub, schema) {\n    var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = passStringToWasm0(self_xpub, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len1 = WASM_VECTOR_LEN;\n    var ret = wasm.encode_json_str_to_native_script(ptr0, len0, ptr1, len1, schema);\n    return NativeScript.__wrap(ret);\n}\n\n/**\n* @param {Uint8Array} bytes\n* @returns {TransactionMetadatum}\n*/\nexport function encode_arbitrary_bytes_as_metadatum(bytes) {\n    var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.encode_arbitrary_bytes_as_metadatum(ptr0, len0);\n    return TransactionMetadatum.__wrap(ret);\n}\n\n/**\n* @param {TransactionMetadatum} metadata\n* @returns {Uint8Array}\n*/\nexport function decode_arbitrary_bytes_from_metadatum(metadata) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(metadata, TransactionMetadatum);\n        wasm.decode_arbitrary_bytes_from_metadatum(retptr, metadata.ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v0 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v0;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} json\n* @param {number} schema\n* @returns {TransactionMetadatum}\n*/\nexport function encode_json_str_to_metadatum(json, schema) {\n    var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.encode_json_str_to_metadatum(ptr0, len0, schema);\n    return TransactionMetadatum.__wrap(ret);\n}\n\n/**\n* @param {TransactionMetadatum} metadatum\n* @param {number} schema\n* @returns {string}\n*/\nexport function decode_metadatum_to_json_str(metadatum, schema) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(metadatum, TransactionMetadatum);\n        wasm.decode_metadatum_to_json_str(retptr, metadatum.ptr, schema);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\n/**\n* @param {string} json\n* @param {number} schema\n* @returns {PlutusData}\n*/\nexport function encode_json_str_to_plutus_datum(json, schema) {\n    var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.encode_json_str_to_plutus_datum(ptr0, len0, schema);\n    return PlutusData.__wrap(ret);\n}\n\n/**\n* @param {PlutusData} datum\n* @param {number} schema\n* @returns {string}\n*/\nexport function decode_plutus_datum_to_json_str(datum, schema) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(datum, PlutusData);\n        wasm.decode_plutus_datum_to_json_str(retptr, datum.ptr, schema);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nexport const CertificateKind = Object.freeze({ StakeRegistration:0,\"0\":\"StakeRegistration\",StakeDeregistration:1,\"1\":\"StakeDeregistration\",StakeDelegation:2,\"2\":\"StakeDelegation\",PoolRegistration:3,\"3\":\"PoolRegistration\",PoolRetirement:4,\"4\":\"PoolRetirement\",GenesisKeyDelegation:5,\"5\":\"GenesisKeyDelegation\",MoveInstantaneousRewardsCert:6,\"6\":\"MoveInstantaneousRewardsCert\", });\n/**\n*/\nexport const MIRPot = Object.freeze({ Reserves:0,\"0\":\"Reserves\",Treasury:1,\"1\":\"Treasury\", });\n/**\n*/\nexport const MIRKind = Object.freeze({ ToOtherPot:0,\"0\":\"ToOtherPot\",ToStakeCredentials:1,\"1\":\"ToStakeCredentials\", });\n/**\n*/\nexport const RelayKind = Object.freeze({ SingleHostAddr:0,\"0\":\"SingleHostAddr\",SingleHostName:1,\"1\":\"SingleHostName\",MultiHostName:2,\"2\":\"MultiHostName\", });\n/**\n*/\nexport const NativeScriptKind = Object.freeze({ ScriptPubkey:0,\"0\":\"ScriptPubkey\",ScriptAll:1,\"1\":\"ScriptAll\",ScriptAny:2,\"2\":\"ScriptAny\",ScriptNOfK:3,\"3\":\"ScriptNOfK\",TimelockStart:4,\"4\":\"TimelockStart\",TimelockExpiry:5,\"5\":\"TimelockExpiry\", });\n/**\n* Each new language uses a different namespace for hashing its script\n* This is because you could have a language where the same bytes have different semantics\n* So this avoids scripts in different languages mapping to the same hash\n* Note that the enum value here is different than the enum value for deciding the cost model of a script\n*/\nexport const ScriptHashNamespace = Object.freeze({ NativeScript:0,\"0\":\"NativeScript\",PlutusScript:1,\"1\":\"PlutusScript\",PlutusScriptV2:2,\"2\":\"PlutusScriptV2\", });\n/**\n*/\nexport const NetworkIdKind = Object.freeze({ Testnet:0,\"0\":\"Testnet\",Mainnet:1,\"1\":\"Mainnet\", });\n/**\n*/\nexport const CoinSelectionStrategyCIP2 = Object.freeze({\n/**\n* Performs CIP2's Largest First ada-only selection. Will error if outputs contain non-ADA assets.\n*/\nLargestFirst:0,\"0\":\"LargestFirst\",\n/**\n* Performs CIP2's Random Improve ada-only selection. Will error if outputs contain non-ADA assets.\n*/\nRandomImprove:1,\"1\":\"RandomImprove\",\n/**\n* Same as LargestFirst, but before adding ADA, will insert by largest-first for each asset type.\n*/\nLargestFirstMultiAsset:2,\"2\":\"LargestFirstMultiAsset\",\n/**\n* Same as RandomImprove, but before adding ADA, will insert by random-improve for each asset type.\n*/\nRandomImproveMultiAsset:3,\"3\":\"RandomImproveMultiAsset\", });\n/**\n*/\nexport const StakeCredKind = Object.freeze({ Key:0,\"0\":\"Key\",Script:1,\"1\":\"Script\", });\n/**\n* Used to choosed the schema for a script JSON string\n*/\nexport const ScriptSchema = Object.freeze({ Wallet:0,\"0\":\"Wallet\",Node:1,\"1\":\"Node\", });\n/**\n*/\nexport const TransactionMetadatumKind = Object.freeze({ MetadataMap:0,\"0\":\"MetadataMap\",MetadataList:1,\"1\":\"MetadataList\",Int:2,\"2\":\"Int\",Bytes:3,\"3\":\"Bytes\",Text:4,\"4\":\"Text\", });\n/**\n*/\nexport const MetadataJsonSchema = Object.freeze({ NoConversions:0,\"0\":\"NoConversions\",BasicConversions:1,\"1\":\"BasicConversions\",DetailedSchema:2,\"2\":\"DetailedSchema\", });\n/**\n*/\nexport const LanguageKind = Object.freeze({ PlutusV1:0,\"0\":\"PlutusV1\",PlutusV2:1,\"1\":\"PlutusV2\", });\n/**\n*/\nexport const PlutusDataKind = Object.freeze({ ConstrPlutusData:0,\"0\":\"ConstrPlutusData\",Map:1,\"1\":\"Map\",List:2,\"2\":\"List\",Integer:3,\"3\":\"Integer\",Bytes:4,\"4\":\"Bytes\", });\n/**\n*/\nexport const RedeemerTagKind = Object.freeze({ Spend:0,\"0\":\"Spend\",Mint:1,\"1\":\"Mint\",Cert:2,\"2\":\"Cert\",Reward:3,\"3\":\"Reward\", });\n/**\n* JSON <-> PlutusData conversion schemas.\n* Follows ScriptDataJsonSchema in cardano-cli defined at:\n* https://github.com/input-output-hk/cardano-node/blob/master/cardano-api/src/Cardano/Api/ScriptData.hs#L254\n*\n* All methods here have the following restrictions due to limitations on dependencies:\n* * JSON numbers above u64::MAX (positive) or below i64::MIN (negative) will throw errors\n* * Hex strings for bytes don't accept odd-length (half-byte) strings.\n*      cardano-cli seems to support these however but it seems to be different than just 0-padding\n*      on either side when tested so proceed with caution\n*/\nexport const PlutusDatumSchema = Object.freeze({\n/**\n* ScriptDataJsonNoSchema in cardano-node.\n*\n* This is the format used by --script-data-value in cardano-cli\n* This tries to accept most JSON but does not support the full spectrum of Plutus datums.\n* From JSON:\n* * null/true/false/floats NOT supported\n* * strings starting with 0x are treated as hex bytes. All other strings are encoded as their utf8 bytes.\n* To JSON:\n* * ConstrPlutusData not supported in ANY FORM (neither keys nor values)\n* * Lists not supported in keys\n* * Maps not supported in keys\n*/\nBasicConversions:0,\"0\":\"BasicConversions\",\n/**\n* ScriptDataJsonDetailedSchema in cardano-node.\n*\n* This is the format used by --script-data-file in cardano-cli\n* This covers almost all (only minor exceptions) Plutus datums, but the JSON must conform to a strict schema.\n* The schema specifies that ALL keys and ALL values must be contained in a JSON map with 2 cases:\n* 1. For ConstrPlutusData there must be two fields \"constructor\" contianing a number and \"fields\" containing its fields\n*    e.g. { \"constructor\": 2, \"fields\": [{\"int\": 2}, {\"list\": [{\"bytes\": \"CAFEF00D\"}]}]}\n* 2. For all other cases there must be only one field named \"int\", \"bytes\", \"list\" or \"map\"\n*    Integer's value is a JSON number e.g. {\"int\": 100}\n*    Bytes' value is a hex string representing the bytes WITHOUT any prefix e.g. {\"bytes\": \"CAFEF00D\"}\n*    Lists' value is a JSON list of its elements encoded via the same schema e.g. {\"list\": [{\"bytes\": \"CAFEF00D\"}]}\n*    Maps' value is a JSON list of objects, one for each key-value pair in the map, with keys \"k\" and \"v\"\n*          respectively with their values being the plutus datum encoded via this same schema\n*          e.g. {\"map\": [\n*              {\"k\": {\"int\": 2}, \"v\": {\"int\": 5}},\n*              {\"k\": {\"map\": [{\"k\": {\"list\": [{\"int\": 1}]}, \"v\": {\"bytes\": \"FF03\"}}]}, \"v\": {\"list\": []}}\n*          ]}\n* From JSON:\n* * null/true/false/floats NOT supported\n* * the JSON must conform to a very specific schema\n* To JSON:\n* * all Plutus datums should be fully supported outside of the integer range limitations outlined above.\n*/\nDetailedSchema:1,\"1\":\"DetailedSchema\", });\n/**\n*/\nexport class Address {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Address.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_address_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {Address}\n    */\n    static from_bytes(data) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.address_from_bytes(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.address_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Address}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.address_from_json(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Address}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.address_from_hex(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string | undefined} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(prefix) ? 0 : passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {Address}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.address_from_bech32(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    network_id() {\n        var ret = wasm.address_network_id(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class AssetName {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AssetName.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_assetname_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetname_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AssetName}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assetname_from_bytes(ptr0, len0);\n        return AssetName.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetname_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {AssetName}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assetname_from_hex(ptr0, len0);\n        return AssetName.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetname_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.assetname_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {AssetName}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assetname_from_json(ptr0, len0);\n        return AssetName.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} name\n    * @returns {AssetName}\n    */\n    static new(name) {\n        var ptr0 = passArray8ToWasm0(name, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assetname_new(ptr0, len0);\n        return AssetName.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    name() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetname_name(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class AssetNames {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AssetNames.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_assetnames_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetnames_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AssetNames}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assetnames_from_bytes(ptr0, len0);\n        return AssetNames.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetnames_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {AssetNames}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assetnames_from_hex(ptr0, len0);\n        return AssetNames.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetnames_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.assetnames_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {AssetNames}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assetnames_from_json(ptr0, len0);\n        return AssetNames.__wrap(ret);\n    }\n    /**\n    * @returns {AssetNames}\n    */\n    static new() {\n        var ret = wasm.assetnames_new();\n        return AssetNames.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.assetnames_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {AssetName}\n    */\n    get(index) {\n        var ret = wasm.assetnames_get(this.ptr, index);\n        return AssetName.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} elem\n    */\n    add(elem) {\n        _assertClass(elem, AssetName);\n        wasm.assetnames_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class Assets {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Assets.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_assets_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assets_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Assets}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assets_from_bytes(ptr0, len0);\n        return Assets.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assets_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Assets}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assets_from_hex(ptr0, len0);\n        return Assets.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assets_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.assets_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Assets}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assets_from_json(ptr0, len0);\n        return Assets.__wrap(ret);\n    }\n    /**\n    * @returns {Assets}\n    */\n    static new() {\n        var ret = wasm.assets_new();\n        return Assets.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.assets_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {AssetName} key\n    * @param {BigNum} value\n    * @returns {BigNum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, AssetName);\n        _assertClass(value, BigNum);\n        var ret = wasm.assets_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} key\n    * @returns {BigNum | undefined}\n    */\n    get(key) {\n        _assertClass(key, AssetName);\n        var ret = wasm.assets_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {AssetNames}\n    */\n    keys() {\n        var ret = wasm.assets_keys(this.ptr);\n        return AssetNames.__wrap(ret);\n    }\n}\n/**\n*/\nexport class AuxiliaryData {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AuxiliaryData.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_auxiliarydata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AuxiliaryData}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.auxiliarydata_from_bytes(ptr0, len0);\n        return AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydata_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {AuxiliaryData}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.auxiliarydata_from_hex(ptr0, len0);\n        return AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydata_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.auxiliarydata_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {AuxiliaryData}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.auxiliarydata_from_json(ptr0, len0);\n        return AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {AuxiliaryData}\n    */\n    static new() {\n        var ret = wasm.auxiliarydata_new();\n        return AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {GeneralTransactionMetadata | undefined}\n    */\n    metadata() {\n        var ret = wasm.auxiliarydata_metadata(this.ptr);\n        return ret === 0 ? undefined : GeneralTransactionMetadata.__wrap(ret);\n    }\n    /**\n    * @param {GeneralTransactionMetadata} metadata\n    */\n    set_metadata(metadata) {\n        _assertClass(metadata, GeneralTransactionMetadata);\n        wasm.auxiliarydata_set_metadata(this.ptr, metadata.ptr);\n    }\n    /**\n    * @returns {NativeScripts | undefined}\n    */\n    native_scripts() {\n        var ret = wasm.auxiliarydata_native_scripts(this.ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    */\n    set_native_scripts(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        wasm.auxiliarydata_set_native_scripts(this.ptr, native_scripts.ptr);\n    }\n    /**\n    * @returns {PlutusScripts | undefined}\n    */\n    plutus_scripts() {\n        var ret = wasm.auxiliarydata_plutus_scripts(this.ptr);\n        return ret === 0 ? undefined : PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScripts} plutus_scripts\n    */\n    set_plutus_scripts(plutus_scripts) {\n        _assertClass(plutus_scripts, PlutusScripts);\n        wasm.auxiliarydata_set_plutus_scripts(this.ptr, plutus_scripts.ptr);\n    }\n}\n/**\n*/\nexport class AuxiliaryDataHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AuxiliaryDataHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_auxiliarydatahash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AuxiliaryDataHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.auxiliarydatahash_from_bytes(ptr0, len0);\n        return AuxiliaryDataHash.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydatahash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.auxiliarydatahash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {AuxiliaryDataHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.auxiliarydatahash_from_bech32(ptr0, len0);\n        return AuxiliaryDataHash.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydatahash_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {AuxiliaryDataHash}\n    */\n    static from_hex(hex) {\n        var ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.auxiliarydatahash_from_hex(ptr0, len0);\n        return AuxiliaryDataHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class AuxiliaryDataSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AuxiliaryDataSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_auxiliarydataset_free(ptr);\n    }\n    /**\n    * @returns {AuxiliaryDataSet}\n    */\n    static new() {\n        var ret = wasm.auxiliarydataset_new();\n        return AuxiliaryDataSet.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.auxiliarydataset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} tx_index\n    * @param {AuxiliaryData} data\n    * @returns {AuxiliaryData | undefined}\n    */\n    insert(tx_index, data) {\n        _assertClass(data, AuxiliaryData);\n        var ret = wasm.auxiliarydataset_insert(this.ptr, tx_index, data.ptr);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @param {number} tx_index\n    * @returns {AuxiliaryData | undefined}\n    */\n    get(tx_index) {\n        var ret = wasm.auxiliarydataset_get(this.ptr, tx_index);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    indices() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydataset_indices(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class BaseAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BaseAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_baseaddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {StakeCredential} payment\n    * @param {StakeCredential} stake\n    * @returns {BaseAddress}\n    */\n    static new(network, payment, stake) {\n        _assertClass(payment, StakeCredential);\n        _assertClass(stake, StakeCredential);\n        var ret = wasm.baseaddress_new(network, payment.ptr, stake.ptr);\n        return BaseAddress.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    payment_cred() {\n        var ret = wasm.baseaddress_payment_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    stake_cred() {\n        var ret = wasm.baseaddress_stake_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.baseaddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {BaseAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = wasm.baseaddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : BaseAddress.__wrap(ret);\n    }\n}\n/**\n*/\nexport class BigInt {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BigInt.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bigint_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bigint_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BigInt}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bigint_from_bytes(ptr0, len0);\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bigint_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {BigInt}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bigint_from_hex(ptr0, len0);\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bigint_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.bigint_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {BigInt}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bigint_from_json(ptr0, len0);\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_zero() {\n        var ret = wasm.bigint_is_zero(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_u64() {\n        var ret = wasm.bigint_as_u64(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {Int | undefined}\n    */\n    as_int() {\n        var ret = wasm.bigint_as_int(this.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @param {string} text\n    * @returns {BigInt}\n    */\n    static from_str(text) {\n        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bigint_from_str(ptr0, len0);\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bigint_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {BigInt} other\n    * @returns {BigInt}\n    */\n    add(other) {\n        _assertClass(other, BigInt);\n        var ret = wasm.bigint_add(this.ptr, other.ptr);\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @param {BigInt} other\n    * @returns {BigInt}\n    */\n    mul(other) {\n        _assertClass(other, BigInt);\n        var ret = wasm.bigint_mul(this.ptr, other.ptr);\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {BigInt}\n    */\n    static one() {\n        var ret = wasm.bigint_one();\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {BigInt}\n    */\n    increment() {\n        var ret = wasm.bigint_increment(this.ptr);\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @param {BigInt} other\n    * @returns {BigInt}\n    */\n    div_ceil(other) {\n        _assertClass(other, BigInt);\n        var ret = wasm.bigint_div_ceil(this.ptr, other.ptr);\n        return BigInt.__wrap(ret);\n    }\n}\n/**\n*/\nexport class BigNum {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BigNum.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bignum_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BigNum}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bignum_from_bytes(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {BigNum}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bignum_from_hex(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.bignum_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {BigNum}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bignum_from_json(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {string} string\n    * @returns {BigNum}\n    */\n    static from_str(string) {\n        var ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bignum_from_str(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {BigNum}\n    */\n    static zero() {\n        var ret = wasm.bignum_zero();\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    static one() {\n        var ret = wasm.bignum_one();\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_zero() {\n        var ret = wasm.bignum_is_zero(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    div_floor(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_div_floor(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_mul(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_mul(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_add(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_add(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_sub(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_sub(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * returns 0 if it would otherwise underflow\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    clamped_sub(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_clamped_sub(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} rhs_value\n    * @returns {number}\n    */\n    compare(rhs_value) {\n        _assertClass(rhs_value, BigNum);\n        var ret = wasm.bignum_compare(this.ptr, rhs_value.ptr);\n        return ret;\n    }\n    /**\n    * @param {BigNum} rhs_value\n    * @returns {boolean}\n    */\n    less_than(rhs_value) {\n        _assertClass(rhs_value, BigNum);\n        var ret = wasm.bignum_less_than(this.ptr, rhs_value.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {BigNum} a\n    * @param {BigNum} b\n    * @returns {BigNum}\n    */\n    static max(a, b) {\n        _assertClass(a, BigNum);\n        _assertClass(b, BigNum);\n        var ret = wasm.bignum_max(a.ptr, b.ptr);\n        return BigNum.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Bip32PrivateKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Bip32PrivateKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bip32privatekey_free(ptr);\n    }\n    /**\n    * derive this private key with the given index.\n    *\n    * # Security considerations\n    *\n    * * hard derivation index cannot be soft derived with the public key\n    *\n    * # Hard derivation vs Soft derivation\n    *\n    * If you pass an index below 0x80000000 then it is a soft derivation.\n    * The advantage of soft derivation is that it is possible to derive the\n    * public key too. I.e. derivation the private key with a soft derivation\n    * index and then retrieving the associated public key is equivalent to\n    * deriving the public key associated to the parent private key.\n    *\n    * Hard derivation index does not allow public key derivation.\n    *\n    * This is why deriving the private key should not fail while deriving\n    * the public key may fail (if the derivation index is invalid).\n    * @param {number} index\n    * @returns {Bip32PrivateKey}\n    */\n    derive(index) {\n        var ret = wasm.bip32privatekey_derive(this.ptr, index);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * 128-byte xprv a key format in Cardano that some software still uses or requires\n    * the traditional 96-byte xprv is simply encoded as\n    * prv | chaincode\n    * however, because some software may not know how to compute a public key from a private key,\n    * the 128-byte inlines the public key in the following format\n    * prv | pub | chaincode\n    * so be careful if you see the term \"xprv\" as it could refer to either one\n    * our library does not require the pub (instead we compute the pub key when needed)\n    * @param {Uint8Array} bytes\n    * @returns {Bip32PrivateKey}\n    */\n    static from_128_xprv(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32privatekey_from_128_xprv(ptr0, len0);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * see from_128_xprv\n    * @returns {Uint8Array}\n    */\n    to_128_xprv() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_to_128_xprv(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Bip32PrivateKey}\n    */\n    static generate_ed25519_bip32() {\n        var ret = wasm.bip32privatekey_generate_ed25519_bip32();\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {PrivateKey}\n    */\n    to_raw_key() {\n        var ret = wasm.bip32privatekey_to_raw_key(this.ptr);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Bip32PublicKey}\n    */\n    to_public() {\n        var ret = wasm.bip32privatekey_to_public(this.ptr);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Bip32PrivateKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32privatekey_from_bytes(ptr0, len0);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} bech32_str\n    * @returns {Bip32PrivateKey}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32privatekey_from_bech32(ptr0, len0);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {Uint8Array} entropy\n    * @param {Uint8Array} password\n    * @returns {Bip32PrivateKey}\n    */\n    static from_bip39_entropy(entropy, password) {\n        var ptr0 = passArray8ToWasm0(entropy, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(password, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32privatekey_from_bip39_entropy(ptr0, len0, ptr1, len1);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chaincode() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_chaincode(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Bip32PrivateKey}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32privatekey_from_hex(ptr0, len0);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Bip32PublicKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Bip32PublicKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bip32publickey_free(ptr);\n    }\n    /**\n    * derive this public key with the given index.\n    *\n    * # Errors\n    *\n    * If the index is not a soft derivation index (< 0x80000000) then\n    * calling this method will fail.\n    *\n    * # Security considerations\n    *\n    * * hard derivation index cannot be soft derived with the public key\n    *\n    * # Hard derivation vs Soft derivation\n    *\n    * If you pass an index below 0x80000000 then it is a soft derivation.\n    * The advantage of soft derivation is that it is possible to derive the\n    * public key too. I.e. derivation the private key with a soft derivation\n    * index and then retrieving the associated public key is equivalent to\n    * deriving the public key associated to the parent private key.\n    *\n    * Hard derivation index does not allow public key derivation.\n    *\n    * This is why deriving the private key should not fail while deriving\n    * the public key may fail (if the derivation index is invalid).\n    * @param {number} index\n    * @returns {Bip32PublicKey}\n    */\n    derive(index) {\n        var ret = wasm.bip32publickey_derive(this.ptr, index);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {PublicKey}\n    */\n    to_raw_key() {\n        var ret = wasm.bip32publickey_to_raw_key(this.ptr);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Bip32PublicKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32publickey_from_bytes(ptr0, len0);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32publickey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} bech32_str\n    * @returns {Bip32PublicKey}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32publickey_from_bech32(ptr0, len0);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32publickey_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chaincode() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32publickey_chaincode(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32publickey_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Bip32PublicKey}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32publickey_from_hex(ptr0, len0);\n        return Bip32PublicKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Block {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Block.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_block_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.block_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Block}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.block_from_bytes(ptr0, len0);\n        return Block.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.block_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Block}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.block_from_hex(ptr0, len0);\n        return Block.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.block_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.block_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Block}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.block_from_json(ptr0, len0);\n        return Block.__wrap(ret);\n    }\n    /**\n    * @returns {Header}\n    */\n    header() {\n        var ret = wasm.block_header(this.ptr);\n        return Header.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionBodies}\n    */\n    transaction_bodies() {\n        var ret = wasm.block_transaction_bodies(this.ptr);\n        return TransactionBodies.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSets}\n    */\n    transaction_witness_sets() {\n        var ret = wasm.block_transaction_witness_sets(this.ptr);\n        return TransactionWitnessSets.__wrap(ret);\n    }\n    /**\n    * @returns {AuxiliaryDataSet}\n    */\n    auxiliary_data_set() {\n        var ret = wasm.block_auxiliary_data_set(this.ptr);\n        return AuxiliaryDataSet.__wrap(ret);\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    invalid_transactions() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.block_invalid_transactions(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Header} header\n    * @param {TransactionBodies} transaction_bodies\n    * @param {TransactionWitnessSets} transaction_witness_sets\n    * @param {AuxiliaryDataSet} auxiliary_data_set\n    * @param {Uint32Array} invalid_transactions\n    * @returns {Block}\n    */\n    static new(header, transaction_bodies, transaction_witness_sets, auxiliary_data_set, invalid_transactions) {\n        _assertClass(header, Header);\n        _assertClass(transaction_bodies, TransactionBodies);\n        _assertClass(transaction_witness_sets, TransactionWitnessSets);\n        _assertClass(auxiliary_data_set, AuxiliaryDataSet);\n        var ptr0 = passArray32ToWasm0(invalid_transactions, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.block_new(header.ptr, transaction_bodies.ptr, transaction_witness_sets.ptr, auxiliary_data_set.ptr, ptr0, len0);\n        return Block.__wrap(ret);\n    }\n}\n/**\n*/\nexport class BlockHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BlockHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockhash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BlockHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.blockhash_from_bytes(ptr0, len0);\n        return BlockHash.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.blockhash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.blockhash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {BlockHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.blockhash_from_bech32(ptr0, len0);\n        return BlockHash.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.blockhash_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {BlockHash}\n    */\n    static from_hex(hex) {\n        var ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.blockhash_from_hex(ptr0, len0);\n        return BlockHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class BootstrapWitness {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BootstrapWitness.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bootstrapwitness_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BootstrapWitness}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bootstrapwitness_from_bytes(ptr0, len0);\n        return BootstrapWitness.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {BootstrapWitness}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bootstrapwitness_from_hex(ptr0, len0);\n        return BootstrapWitness.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.bootstrapwitness_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {BootstrapWitness}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bootstrapwitness_from_json(ptr0, len0);\n        return BootstrapWitness.__wrap(ret);\n    }\n    /**\n    * @returns {Vkey}\n    */\n    vkey() {\n        var ret = wasm.bootstrapwitness_vkey(this.ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519Signature}\n    */\n    signature() {\n        var ret = wasm.bootstrapwitness_signature(this.ptr);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chain_code() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_chain_code(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    attributes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_attributes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Vkey} vkey\n    * @param {Ed25519Signature} signature\n    * @param {Uint8Array} chain_code\n    * @param {Uint8Array} attributes\n    * @returns {BootstrapWitness}\n    */\n    static new(vkey, signature, chain_code, attributes) {\n        _assertClass(vkey, Vkey);\n        _assertClass(signature, Ed25519Signature);\n        var ptr0 = passArray8ToWasm0(chain_code, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(attributes, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.bootstrapwitness_new(vkey.ptr, signature.ptr, ptr0, len0, ptr1, len1);\n        return BootstrapWitness.__wrap(ret);\n    }\n}\n/**\n*/\nexport class BootstrapWitnesses {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BootstrapWitnesses.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bootstrapwitnesses_free(ptr);\n    }\n    /**\n    * @returns {BootstrapWitnesses}\n    */\n    static new() {\n        var ret = wasm.bootstrapwitnesses_new();\n        return BootstrapWitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.bootstrapwitnesses_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {BootstrapWitness}\n    */\n    get(index) {\n        var ret = wasm.bootstrapwitnesses_get(this.ptr, index);\n        return BootstrapWitness.__wrap(ret);\n    }\n    /**\n    * @param {BootstrapWitness} elem\n    */\n    add(elem) {\n        _assertClass(elem, BootstrapWitness);\n        wasm.bootstrapwitnesses_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class ByronAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ByronAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_byronaddress_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    to_base58() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.byronaddress_to_base58(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.byronaddress_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ByronAddress}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.byronaddress_from_bytes(ptr0, len0);\n        return ByronAddress.__wrap(ret);\n    }\n    /**\n    * returns the byron protocol magic embedded in the address, or mainnet id if none is present\n    * note: for bech32 addresses, you need to use network_id instead\n    * @returns {number}\n    */\n    byron_protocol_magic() {\n        var ret = wasm.byronaddress_byron_protocol_magic(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    attributes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.byronaddress_attributes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    network_id() {\n        var ret = wasm.byronaddress_network_id(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {string} s\n    * @returns {ByronAddress}\n    */\n    static from_base58(s) {\n        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.byronaddress_from_base58(ptr0, len0);\n        return ByronAddress.__wrap(ret);\n    }\n    /**\n    * @param {Bip32PublicKey} key\n    * @param {number} protocol_magic\n    * @returns {ByronAddress}\n    */\n    static icarus_from_key(key, protocol_magic) {\n        _assertClass(key, Bip32PublicKey);\n        var ret = wasm.byronaddress_icarus_from_key(key.ptr, protocol_magic);\n        return ByronAddress.__wrap(ret);\n    }\n    /**\n    * @param {string} s\n    * @returns {boolean}\n    */\n    static is_valid(s) {\n        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.byronaddress_is_valid(ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.byronaddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {ByronAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = wasm.byronaddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : ByronAddress.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Certificate {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Certificate.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_certificate_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificate_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Certificate}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.certificate_from_bytes(ptr0, len0);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificate_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Certificate}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.certificate_from_hex(ptr0, len0);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificate_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.certificate_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Certificate}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.certificate_from_json(ptr0, len0);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeRegistration} stake_registration\n    * @returns {Certificate}\n    */\n    static new_stake_registration(stake_registration) {\n        _assertClass(stake_registration, StakeRegistration);\n        var ret = wasm.certificate_new_stake_registration(stake_registration.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeDeregistration} stake_deregistration\n    * @returns {Certificate}\n    */\n    static new_stake_deregistration(stake_deregistration) {\n        _assertClass(stake_deregistration, StakeDeregistration);\n        var ret = wasm.certificate_new_stake_deregistration(stake_deregistration.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeDelegation} stake_delegation\n    * @returns {Certificate}\n    */\n    static new_stake_delegation(stake_delegation) {\n        _assertClass(stake_delegation, StakeDelegation);\n        var ret = wasm.certificate_new_stake_delegation(stake_delegation.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {PoolRegistration} pool_registration\n    * @returns {Certificate}\n    */\n    static new_pool_registration(pool_registration) {\n        _assertClass(pool_registration, PoolRegistration);\n        var ret = wasm.certificate_new_pool_registration(pool_registration.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {PoolRetirement} pool_retirement\n    * @returns {Certificate}\n    */\n    static new_pool_retirement(pool_retirement) {\n        _assertClass(pool_retirement, PoolRetirement);\n        var ret = wasm.certificate_new_pool_retirement(pool_retirement.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {GenesisKeyDelegation} genesis_key_delegation\n    * @returns {Certificate}\n    */\n    static new_genesis_key_delegation(genesis_key_delegation) {\n        _assertClass(genesis_key_delegation, GenesisKeyDelegation);\n        var ret = wasm.certificate_new_genesis_key_delegation(genesis_key_delegation.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {MoveInstantaneousRewardsCert} move_instantaneous_rewards_cert\n    * @returns {Certificate}\n    */\n    static new_move_instantaneous_rewards_cert(move_instantaneous_rewards_cert) {\n        _assertClass(move_instantaneous_rewards_cert, MoveInstantaneousRewardsCert);\n        var ret = wasm.certificate_new_move_instantaneous_rewards_cert(move_instantaneous_rewards_cert.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.certificate_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {StakeRegistration | undefined}\n    */\n    as_stake_registration() {\n        var ret = wasm.certificate_as_stake_registration(this.ptr);\n        return ret === 0 ? undefined : StakeRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeDeregistration | undefined}\n    */\n    as_stake_deregistration() {\n        var ret = wasm.certificate_as_stake_deregistration(this.ptr);\n        return ret === 0 ? undefined : StakeDeregistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeDelegation | undefined}\n    */\n    as_stake_delegation() {\n        var ret = wasm.certificate_as_stake_delegation(this.ptr);\n        return ret === 0 ? undefined : StakeDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {PoolRegistration | undefined}\n    */\n    as_pool_registration() {\n        var ret = wasm.certificate_as_pool_registration(this.ptr);\n        return ret === 0 ? undefined : PoolRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {PoolRetirement | undefined}\n    */\n    as_pool_retirement() {\n        var ret = wasm.certificate_as_pool_retirement(this.ptr);\n        return ret === 0 ? undefined : PoolRetirement.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisKeyDelegation | undefined}\n    */\n    as_genesis_key_delegation() {\n        var ret = wasm.certificate_as_genesis_key_delegation(this.ptr);\n        return ret === 0 ? undefined : GenesisKeyDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {MoveInstantaneousRewardsCert | undefined}\n    */\n    as_move_instantaneous_rewards_cert() {\n        var ret = wasm.certificate_as_move_instantaneous_rewards_cert(this.ptr);\n        return ret === 0 ? undefined : MoveInstantaneousRewardsCert.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Certificates {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Certificates.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_certificates_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificates_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Certificates}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.certificates_from_bytes(ptr0, len0);\n        return Certificates.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificates_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Certificates}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.certificates_from_hex(ptr0, len0);\n        return Certificates.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificates_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.certificates_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Certificates}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.certificates_from_json(ptr0, len0);\n        return Certificates.__wrap(ret);\n    }\n    /**\n    * @returns {Certificates}\n    */\n    static new() {\n        var ret = wasm.certificates_new();\n        return Certificates.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.certificates_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Certificate}\n    */\n    get(index) {\n        var ret = wasm.certificates_get(this.ptr, index);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {Certificate} elem\n    */\n    add(elem) {\n        _assertClass(elem, Certificate);\n        wasm.certificates_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class ConstrPlutusData {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ConstrPlutusData.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_constrplutusdata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constrplutusdata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ConstrPlutusData}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constrplutusdata_from_bytes(ptr0, len0);\n        return ConstrPlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constrplutusdata_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ConstrPlutusData}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constrplutusdata_from_hex(ptr0, len0);\n        return ConstrPlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    alternative() {\n        var ret = wasm.constrplutusdata_alternative(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList}\n    */\n    data() {\n        var ret = wasm.constrplutusdata_data(this.ptr);\n        return PlutusList.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} alternative\n    * @param {PlutusList} data\n    * @returns {ConstrPlutusData}\n    */\n    static new(alternative, data) {\n        _assertClass(alternative, BigNum);\n        _assertClass(data, PlutusList);\n        var ret = wasm.constrplutusdata_new(alternative.ptr, data.ptr);\n        return ConstrPlutusData.__wrap(ret);\n    }\n}\n/**\n*/\nexport class CostModel {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CostModel.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_costmodel_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmodel_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CostModel}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.costmodel_from_bytes(ptr0, len0);\n        return CostModel.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmodel_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {CostModel}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.costmodel_from_hex(ptr0, len0);\n        return CostModel.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmodel_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.costmodel_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {CostModel}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.costmodel_from_json(ptr0, len0);\n        return CostModel.__wrap(ret);\n    }\n    /**\n    * Creates a new CostModels instance of an unrestricted length\n    * @returns {CostModel}\n    */\n    static new() {\n        var ret = wasm.costmodel_new();\n        return CostModel.__wrap(ret);\n    }\n    /**\n    * Sets the cost at the specified index to the specified value.\n    * In case the operation index is larger than the previous largest used index,\n    * it will fill any inbetween indexes with zeroes\n    * @param {number} operation\n    * @param {Int} cost\n    * @returns {Int}\n    */\n    set(operation, cost) {\n        _assertClass(cost, Int);\n        var ret = wasm.costmodel_set(this.ptr, operation, cost.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {number} operation\n    * @returns {Int}\n    */\n    get(operation) {\n        var ret = wasm.costmodel_get(this.ptr, operation);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.costmodel_len(this.ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nexport class Costmdls {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Costmdls.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_costmdls_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmdls_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Costmdls}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.costmdls_from_bytes(ptr0, len0);\n        return Costmdls.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmdls_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Costmdls}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.costmdls_from_hex(ptr0, len0);\n        return Costmdls.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmdls_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.costmdls_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Costmdls}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.costmdls_from_json(ptr0, len0);\n        return Costmdls.__wrap(ret);\n    }\n    /**\n    * @returns {Costmdls}\n    */\n    static new() {\n        var ret = wasm.costmdls_new();\n        return Costmdls.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.costmdls_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {Language} key\n    * @param {CostModel} value\n    * @returns {CostModel | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, Language);\n        _assertClass(value, CostModel);\n        var ret = wasm.costmdls_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : CostModel.__wrap(ret);\n    }\n    /**\n    * @param {Language} key\n    * @returns {CostModel | undefined}\n    */\n    get(key) {\n        _assertClass(key, Language);\n        var ret = wasm.costmdls_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : CostModel.__wrap(ret);\n    }\n    /**\n    * @returns {Languages}\n    */\n    keys() {\n        var ret = wasm.costmdls_keys(this.ptr);\n        return Languages.__wrap(ret);\n    }\n    /**\n    * @param {Languages} languages\n    * @returns {Costmdls}\n    */\n    retain_language_versions(languages) {\n        _assertClass(languages, Languages);\n        var ret = wasm.costmdls_retain_language_versions(this.ptr, languages.ptr);\n        return Costmdls.__wrap(ret);\n    }\n}\n/**\n*/\nexport class DNSRecordAorAAAA {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DNSRecordAorAAAA.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_dnsrecordaoraaaa_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DNSRecordAorAAAA}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.dnsrecordaoraaaa_from_bytes(ptr0, len0);\n        return DNSRecordAorAAAA.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {DNSRecordAorAAAA}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.dnsrecordaoraaaa_from_hex(ptr0, len0);\n        return DNSRecordAorAAAA.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.dnsrecordaoraaaa_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {DNSRecordAorAAAA}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.dnsrecordaoraaaa_from_json(ptr0, len0);\n        return DNSRecordAorAAAA.__wrap(ret);\n    }\n    /**\n    * @param {string} dns_name\n    * @returns {DNSRecordAorAAAA}\n    */\n    static new(dns_name) {\n        var ptr0 = passStringToWasm0(dns_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.dnsrecordaoraaaa_new(ptr0, len0);\n        return DNSRecordAorAAAA.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    record() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_record(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nexport class DNSRecordSRV {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DNSRecordSRV.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_dnsrecordsrv_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordsrv_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DNSRecordSRV}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.dnsrecordsrv_from_bytes(ptr0, len0);\n        return DNSRecordSRV.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordsrv_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {DNSRecordSRV}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.dnsrecordsrv_from_hex(ptr0, len0);\n        return DNSRecordSRV.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordsrv_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.dnsrecordsrv_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {DNSRecordSRV}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.dnsrecordsrv_from_json(ptr0, len0);\n        return DNSRecordSRV.__wrap(ret);\n    }\n    /**\n    * @param {string} dns_name\n    * @returns {DNSRecordSRV}\n    */\n    static new(dns_name) {\n        var ptr0 = passStringToWasm0(dns_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.dnsrecordsrv_new(ptr0, len0);\n        return DNSRecordSRV.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    record() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordsrv_record(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nexport class DataCost {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DataCost.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_datacost_free(ptr);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Since babbage era we should use coins per byte. Use `.new_coins_per_byte` instead.\n    * @param {BigNum} coins_per_word\n    * @returns {DataCost}\n    */\n    static new_coins_per_word(coins_per_word) {\n        _assertClass(coins_per_word, BigNum);\n        var ret = wasm.datacost_new_coins_per_word(coins_per_word.ptr);\n        return DataCost.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coins_per_byte\n    * @returns {DataCost}\n    */\n    static new_coins_per_byte(coins_per_byte) {\n        _assertClass(coins_per_byte, BigNum);\n        var ret = wasm.datacost_new_coins_per_byte(coins_per_byte.ptr);\n        return DataCost.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coins_per_byte() {\n        var ret = wasm.datacost_coins_per_byte(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n}\n/**\n*/\nexport class DataHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DataHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_datahash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DataHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.datahash_from_bytes(ptr0, len0);\n        return DataHash.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.datahash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.datahash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {DataHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.datahash_from_bech32(ptr0, len0);\n        return DataHash.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.datahash_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {DataHash}\n    */\n    static from_hex(hex) {\n        var ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.datahash_from_hex(ptr0, len0);\n        return DataHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class DatumSource {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DatumSource.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_datumsource_free(ptr);\n    }\n    /**\n    * @param {PlutusData} datum\n    * @returns {DatumSource}\n    */\n    static new(datum) {\n        _assertClass(datum, PlutusData);\n        var ret = wasm.datumsource_new(datum.ptr);\n        return DatumSource.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInput} input\n    * @returns {DatumSource}\n    */\n    static new_ref_input(input) {\n        _assertClass(input, TransactionInput);\n        var ret = wasm.datumsource_new_ref_input(input.ptr);\n        return DatumSource.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Ed25519KeyHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ed25519KeyHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ed25519keyhash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ed25519KeyHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519keyhash_from_bytes(ptr0, len0);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ed25519keyhash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {Ed25519KeyHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519keyhash_from_bech32(ptr0, len0);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhash_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {Ed25519KeyHash}\n    */\n    static from_hex(hex) {\n        var ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519keyhash_from_hex(ptr0, len0);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Ed25519KeyHashes {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ed25519KeyHashes.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ed25519keyhashes_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhashes_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ed25519KeyHashes}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519keyhashes_from_bytes(ptr0, len0);\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhashes_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Ed25519KeyHashes}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519keyhashes_from_hex(ptr0, len0);\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhashes_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.ed25519keyhashes_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Ed25519KeyHashes}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519keyhashes_from_json(ptr0, len0);\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHashes}\n    */\n    static new() {\n        var ret = wasm.ed25519keyhashes_new();\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.ed25519keyhashes_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Ed25519KeyHash}\n    */\n    get(index) {\n        var ret = wasm.ed25519keyhashes_get(this.ptr, index);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHash} elem\n    */\n    add(elem) {\n        _assertClass(elem, Ed25519KeyHash);\n        wasm.ed25519keyhashes_add(this.ptr, elem.ptr);\n    }\n    /**\n    * @returns {Ed25519KeyHashes | undefined}\n    */\n    to_option() {\n        var ret = wasm.ed25519keyhashes_to_option(this.ptr);\n        return ret === 0 ? undefined : Ed25519KeyHashes.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Ed25519Signature {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ed25519Signature.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ed25519signature_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519signature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519signature_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519signature_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech32_str\n    * @returns {Ed25519Signature}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519signature_from_bech32(ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @param {string} input\n    * @returns {Ed25519Signature}\n    */\n    static from_hex(input) {\n        var ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519signature_from_hex(ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ed25519Signature}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519signature_from_bytes(ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n}\n/**\n*/\nexport class EnterpriseAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(EnterpriseAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_enterpriseaddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {StakeCredential} payment\n    * @returns {EnterpriseAddress}\n    */\n    static new(network, payment) {\n        _assertClass(payment, StakeCredential);\n        var ret = wasm.enterpriseaddress_new(network, payment.ptr);\n        return EnterpriseAddress.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    payment_cred() {\n        var ret = wasm.enterpriseaddress_payment_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.enterpriseaddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {EnterpriseAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = wasm.enterpriseaddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : EnterpriseAddress.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ExUnitPrices {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ExUnitPrices.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_exunitprices_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunitprices_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ExUnitPrices}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.exunitprices_from_bytes(ptr0, len0);\n        return ExUnitPrices.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunitprices_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ExUnitPrices}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.exunitprices_from_hex(ptr0, len0);\n        return ExUnitPrices.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunitprices_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.exunitprices_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {ExUnitPrices}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.exunitprices_from_json(ptr0, len0);\n        return ExUnitPrices.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    mem_price() {\n        var ret = wasm.exunitprices_mem_price(this.ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    step_price() {\n        var ret = wasm.exunitprices_step_price(this.ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} mem_price\n    * @param {UnitInterval} step_price\n    * @returns {ExUnitPrices}\n    */\n    static new(mem_price, step_price) {\n        _assertClass(mem_price, UnitInterval);\n        _assertClass(step_price, UnitInterval);\n        var ret = wasm.exunitprices_new(mem_price.ptr, step_price.ptr);\n        return ExUnitPrices.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ExUnits {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ExUnits.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_exunits_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunits_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ExUnits}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.exunits_from_bytes(ptr0, len0);\n        return ExUnits.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunits_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ExUnits}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.exunits_from_hex(ptr0, len0);\n        return ExUnits.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunits_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.exunits_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {ExUnits}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.exunits_from_json(ptr0, len0);\n        return ExUnits.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    mem() {\n        var ret = wasm.exunits_mem(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    steps() {\n        var ret = wasm.exunits_steps(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} mem\n    * @param {BigNum} steps\n    * @returns {ExUnits}\n    */\n    static new(mem, steps) {\n        _assertClass(mem, BigNum);\n        _assertClass(steps, BigNum);\n        var ret = wasm.exunits_new(mem.ptr, steps.ptr);\n        return ExUnits.__wrap(ret);\n    }\n}\n/**\n*/\nexport class GeneralTransactionMetadata {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GeneralTransactionMetadata.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_generaltransactionmetadata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.generaltransactionmetadata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GeneralTransactionMetadata}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.generaltransactionmetadata_from_bytes(ptr0, len0);\n        return GeneralTransactionMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.generaltransactionmetadata_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {GeneralTransactionMetadata}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.generaltransactionmetadata_from_hex(ptr0, len0);\n        return GeneralTransactionMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.generaltransactionmetadata_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.generaltransactionmetadata_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {GeneralTransactionMetadata}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.generaltransactionmetadata_from_json(ptr0, len0);\n        return GeneralTransactionMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {GeneralTransactionMetadata}\n    */\n    static new() {\n        var ret = wasm.generaltransactionmetadata_new();\n        return GeneralTransactionMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.generaltransactionmetadata_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {BigNum} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, BigNum);\n        _assertClass(value, TransactionMetadatum);\n        var ret = wasm.generaltransactionmetadata_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} key\n    * @returns {TransactionMetadatum | undefined}\n    */\n    get(key) {\n        _assertClass(key, BigNum);\n        var ret = wasm.generaltransactionmetadata_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionMetadatumLabels}\n    */\n    keys() {\n        var ret = wasm.generaltransactionmetadata_keys(this.ptr);\n        return TransactionMetadatumLabels.__wrap(ret);\n    }\n}\n/**\n*/\nexport class GenesisDelegateHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenesisDelegateHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genesisdelegatehash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisDelegateHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesisdelegatehash_from_bytes(ptr0, len0);\n        return GenesisDelegateHash.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesisdelegatehash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.genesisdelegatehash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {GenesisDelegateHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesisdelegatehash_from_bech32(ptr0, len0);\n        return GenesisDelegateHash.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesisdelegatehash_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {GenesisDelegateHash}\n    */\n    static from_hex(hex) {\n        var ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesisdelegatehash_from_hex(ptr0, len0);\n        return GenesisDelegateHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class GenesisHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenesisHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genesishash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesishash_from_bytes(ptr0, len0);\n        return GenesisHash.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesishash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.genesishash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {GenesisHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesishash_from_bech32(ptr0, len0);\n        return GenesisHash.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesishash_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {GenesisHash}\n    */\n    static from_hex(hex) {\n        var ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesishash_from_hex(ptr0, len0);\n        return GenesisHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class GenesisHashes {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenesisHashes.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genesishashes_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesishashes_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisHashes}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesishashes_from_bytes(ptr0, len0);\n        return GenesisHashes.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesishashes_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {GenesisHashes}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesishashes_from_hex(ptr0, len0);\n        return GenesisHashes.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesishashes_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.genesishashes_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {GenesisHashes}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesishashes_from_json(ptr0, len0);\n        return GenesisHashes.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisHashes}\n    */\n    static new() {\n        var ret = wasm.genesishashes_new();\n        return GenesisHashes.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.genesishashes_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {GenesisHash}\n    */\n    get(index) {\n        var ret = wasm.genesishashes_get(this.ptr, index);\n        return GenesisHash.__wrap(ret);\n    }\n    /**\n    * @param {GenesisHash} elem\n    */\n    add(elem) {\n        _assertClass(elem, GenesisHash);\n        wasm.genesishashes_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class GenesisKeyDelegation {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenesisKeyDelegation.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genesiskeydelegation_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesiskeydelegation_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisKeyDelegation}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesiskeydelegation_from_bytes(ptr0, len0);\n        return GenesisKeyDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesiskeydelegation_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {GenesisKeyDelegation}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesiskeydelegation_from_hex(ptr0, len0);\n        return GenesisKeyDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesiskeydelegation_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.genesiskeydelegation_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {GenesisKeyDelegation}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesiskeydelegation_from_json(ptr0, len0);\n        return GenesisKeyDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisHash}\n    */\n    genesishash() {\n        var ret = wasm.genesiskeydelegation_genesishash(this.ptr);\n        return GenesisHash.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisDelegateHash}\n    */\n    genesis_delegate_hash() {\n        var ret = wasm.genesiskeydelegation_genesis_delegate_hash(this.ptr);\n        return GenesisDelegateHash.__wrap(ret);\n    }\n    /**\n    * @returns {VRFKeyHash}\n    */\n    vrf_keyhash() {\n        var ret = wasm.genesiskeydelegation_vrf_keyhash(this.ptr);\n        return VRFKeyHash.__wrap(ret);\n    }\n    /**\n    * @param {GenesisHash} genesishash\n    * @param {GenesisDelegateHash} genesis_delegate_hash\n    * @param {VRFKeyHash} vrf_keyhash\n    * @returns {GenesisKeyDelegation}\n    */\n    static new(genesishash, genesis_delegate_hash, vrf_keyhash) {\n        _assertClass(genesishash, GenesisHash);\n        _assertClass(genesis_delegate_hash, GenesisDelegateHash);\n        _assertClass(vrf_keyhash, VRFKeyHash);\n        var ret = wasm.genesiskeydelegation_new(genesishash.ptr, genesis_delegate_hash.ptr, vrf_keyhash.ptr);\n        return GenesisKeyDelegation.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Header {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Header.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_header_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.header_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Header}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.header_from_bytes(ptr0, len0);\n        return Header.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.header_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Header}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.header_from_hex(ptr0, len0);\n        return Header.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.header_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.header_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Header}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.header_from_json(ptr0, len0);\n        return Header.__wrap(ret);\n    }\n    /**\n    * @returns {HeaderBody}\n    */\n    header_body() {\n        var ret = wasm.header_header_body(this.ptr);\n        return HeaderBody.__wrap(ret);\n    }\n    /**\n    * @returns {KESSignature}\n    */\n    body_signature() {\n        var ret = wasm.header_body_signature(this.ptr);\n        return KESSignature.__wrap(ret);\n    }\n    /**\n    * @param {HeaderBody} header_body\n    * @param {KESSignature} body_signature\n    * @returns {Header}\n    */\n    static new(header_body, body_signature) {\n        _assertClass(header_body, HeaderBody);\n        _assertClass(body_signature, KESSignature);\n        var ret = wasm.header_new(header_body.ptr, body_signature.ptr);\n        return Header.__wrap(ret);\n    }\n}\n/**\n*/\nexport class HeaderBody {\n\n    static __wrap(ptr) {\n        const obj = Object.create(HeaderBody.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_headerbody_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headerbody_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {HeaderBody}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.headerbody_from_bytes(ptr0, len0);\n        return HeaderBody.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headerbody_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {HeaderBody}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.headerbody_from_hex(ptr0, len0);\n        return HeaderBody.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headerbody_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.headerbody_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {HeaderBody}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.headerbody_from_json(ptr0, len0);\n        return HeaderBody.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    block_number() {\n        var ret = wasm.headerbody_block_number(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Returns a Slot32 (u32) value in case the underlying original BigNum (u64) value is within the limits.\n    * Otherwise will just raise an error.\n    * @returns {number}\n    */\n    slot() {\n        var ret = wasm.headerbody_slot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BigNum}\n    */\n    slot_bignum() {\n        var ret = wasm.headerbody_slot_bignum(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BlockHash | undefined}\n    */\n    prev_hash() {\n        var ret = wasm.headerbody_prev_hash(this.ptr);\n        return ret === 0 ? undefined : BlockHash.__wrap(ret);\n    }\n    /**\n    * @returns {Vkey}\n    */\n    issuer_vkey() {\n        var ret = wasm.headerbody_issuer_vkey(this.ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {VRFVKey}\n    */\n    vrf_vkey() {\n        var ret = wasm.headerbody_vrf_vkey(this.ptr);\n        return VRFVKey.__wrap(ret);\n    }\n    /**\n    * If this function returns true, the `.nonce_vrf_or_nothing`\n    * and the `.leader_vrf_or_nothing` functions will return\n    * non-empty results\n    * @returns {boolean}\n    */\n    has_nonce_and_leader_vrf() {\n        var ret = wasm.headerbody_has_nonce_and_leader_vrf(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * Might return nothing in case `.has_nonce_and_leader_vrf` returns false\n    * @returns {VRFCert | undefined}\n    */\n    nonce_vrf_or_nothing() {\n        var ret = wasm.headerbody_nonce_vrf_or_nothing(this.ptr);\n        return ret === 0 ? undefined : VRFCert.__wrap(ret);\n    }\n    /**\n    * Might return nothing in case `.has_nonce_and_leader_vrf` returns false\n    * @returns {VRFCert | undefined}\n    */\n    leader_vrf_or_nothing() {\n        var ret = wasm.headerbody_leader_vrf_or_nothing(this.ptr);\n        return ret === 0 ? undefined : VRFCert.__wrap(ret);\n    }\n    /**\n    * If this function returns true, the `.vrf_result_or_nothing`\n    * function will return a non-empty result\n    * @returns {boolean}\n    */\n    has_vrf_result() {\n        var ret = wasm.headerbody_has_vrf_result(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * Might return nothing in case `.has_vrf_result` returns false\n    * @returns {VRFCert | undefined}\n    */\n    vrf_result_or_nothing() {\n        var ret = wasm.headerbody_vrf_result_or_nothing(this.ptr);\n        return ret === 0 ? undefined : VRFCert.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    block_body_size() {\n        var ret = wasm.headerbody_block_body_size(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BlockHash}\n    */\n    block_body_hash() {\n        var ret = wasm.headerbody_block_body_hash(this.ptr);\n        return BlockHash.__wrap(ret);\n    }\n    /**\n    * @returns {OperationalCert}\n    */\n    operational_cert() {\n        var ret = wasm.headerbody_operational_cert(this.ptr);\n        return OperationalCert.__wrap(ret);\n    }\n    /**\n    * @returns {ProtocolVersion}\n    */\n    protocol_version() {\n        var ret = wasm.headerbody_protocol_version(this.ptr);\n        return ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * This constructor uses outdated slot number format.\n    * Use `.new_headerbody` instead\n    * @param {number} block_number\n    * @param {number} slot\n    * @param {BlockHash | undefined} prev_hash\n    * @param {Vkey} issuer_vkey\n    * @param {VRFVKey} vrf_vkey\n    * @param {VRFCert} vrf_result\n    * @param {number} block_body_size\n    * @param {BlockHash} block_body_hash\n    * @param {OperationalCert} operational_cert\n    * @param {ProtocolVersion} protocol_version\n    * @returns {HeaderBody}\n    */\n    static new(block_number, slot, prev_hash, issuer_vkey, vrf_vkey, vrf_result, block_body_size, block_body_hash, operational_cert, protocol_version) {\n        let ptr0 = 0;\n        if (!isLikeNone(prev_hash)) {\n            _assertClass(prev_hash, BlockHash);\n            ptr0 = prev_hash.ptr;\n            prev_hash.ptr = 0;\n        }\n        _assertClass(issuer_vkey, Vkey);\n        _assertClass(vrf_vkey, VRFVKey);\n        _assertClass(vrf_result, VRFCert);\n        _assertClass(block_body_hash, BlockHash);\n        _assertClass(operational_cert, OperationalCert);\n        _assertClass(protocol_version, ProtocolVersion);\n        var ret = wasm.headerbody_new(block_number, slot, ptr0, issuer_vkey.ptr, vrf_vkey.ptr, vrf_result.ptr, block_body_size, block_body_hash.ptr, operational_cert.ptr, protocol_version.ptr);\n        return HeaderBody.__wrap(ret);\n    }\n    /**\n    * @param {number} block_number\n    * @param {BigNum} slot\n    * @param {BlockHash | undefined} prev_hash\n    * @param {Vkey} issuer_vkey\n    * @param {VRFVKey} vrf_vkey\n    * @param {VRFCert} vrf_result\n    * @param {number} block_body_size\n    * @param {BlockHash} block_body_hash\n    * @param {OperationalCert} operational_cert\n    * @param {ProtocolVersion} protocol_version\n    * @returns {HeaderBody}\n    */\n    static new_headerbody(block_number, slot, prev_hash, issuer_vkey, vrf_vkey, vrf_result, block_body_size, block_body_hash, operational_cert, protocol_version) {\n        _assertClass(slot, BigNum);\n        let ptr0 = 0;\n        if (!isLikeNone(prev_hash)) {\n            _assertClass(prev_hash, BlockHash);\n            ptr0 = prev_hash.ptr;\n            prev_hash.ptr = 0;\n        }\n        _assertClass(issuer_vkey, Vkey);\n        _assertClass(vrf_vkey, VRFVKey);\n        _assertClass(vrf_result, VRFCert);\n        _assertClass(block_body_hash, BlockHash);\n        _assertClass(operational_cert, OperationalCert);\n        _assertClass(protocol_version, ProtocolVersion);\n        var ret = wasm.headerbody_new_headerbody(block_number, slot.ptr, ptr0, issuer_vkey.ptr, vrf_vkey.ptr, vrf_result.ptr, block_body_size, block_body_hash.ptr, operational_cert.ptr, protocol_version.ptr);\n        return HeaderBody.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Int {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Int.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_int_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Int}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.int_from_bytes(ptr0, len0);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Int}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.int_from_hex(ptr0, len0);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.int_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Int}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.int_from_json(ptr0, len0);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} x\n    * @returns {Int}\n    */\n    static new(x) {\n        _assertClass(x, BigNum);\n        var ret = wasm.int_new(x.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} x\n    * @returns {Int}\n    */\n    static new_negative(x) {\n        _assertClass(x, BigNum);\n        var ret = wasm.int_new_negative(x.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {number} x\n    * @returns {Int}\n    */\n    static new_i32(x) {\n        var ret = wasm.int_new_i32(x);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_positive() {\n        var ret = wasm.int_is_positive(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * BigNum can only contain unsigned u64 values\n    *\n    * This function will return the BigNum representation\n    * only in case the underlying i128 value is positive.\n    *\n    * Otherwise nothing will be returned (undefined).\n    * @returns {BigNum | undefined}\n    */\n    as_positive() {\n        var ret = wasm.int_as_positive(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * BigNum can only contain unsigned u64 values\n    *\n    * This function will return the *absolute* BigNum representation\n    * only in case the underlying i128 value is negative.\n    *\n    * Otherwise nothing will be returned (undefined).\n    * @returns {BigNum | undefined}\n    */\n    as_negative() {\n        var ret = wasm.int_as_negative(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Returns an i32 value in case the underlying original i128 value is within the limits.\n    * Otherwise will just return an empty value (undefined).\n    * @returns {number | undefined}\n    */\n    as_i32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_as_i32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the underlying value converted to i32 if possible (within limits)\n    * Otherwise will just return an empty value (undefined).\n    * @returns {number | undefined}\n    */\n    as_i32_or_nothing() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_as_i32_or_nothing(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the underlying value converted to i32 if possible (within limits)\n    * JsError in case of out of boundary overflow\n    * @returns {number}\n    */\n    as_i32_or_fail() {\n        var ret = wasm.int_as_i32_or_fail(this.ptr);\n        return ret;\n    }\n    /**\n    * Returns string representation of the underlying i128 value directly.\n    * Might contain the minus sign (-) in case of negative value.\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} string\n    * @returns {Int}\n    */\n    static from_str(string) {\n        var ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.int_from_str(ptr0, len0);\n        return Int.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Ipv4 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ipv4.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ipv4_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv4_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ipv4}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ipv4_from_bytes(ptr0, len0);\n        return Ipv4.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv4_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Ipv4}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ipv4_from_hex(ptr0, len0);\n        return Ipv4.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv4_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.ipv4_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Ipv4}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ipv4_from_json(ptr0, len0);\n        return Ipv4.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {Ipv4}\n    */\n    static new(data) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ipv4_new(ptr0, len0);\n        return Ipv4.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    ip() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv4_ip(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class Ipv6 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ipv6.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ipv6_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv6_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ipv6}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ipv6_from_bytes(ptr0, len0);\n        return Ipv6.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv6_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Ipv6}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ipv6_from_hex(ptr0, len0);\n        return Ipv6.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv6_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.ipv6_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Ipv6}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ipv6_from_json(ptr0, len0);\n        return Ipv6.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {Ipv6}\n    */\n    static new(data) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ipv6_new(ptr0, len0);\n        return Ipv6.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    ip() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv6_ip(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class KESSignature {\n\n    static __wrap(ptr) {\n        const obj = Object.create(KESSignature.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_kessignature_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.kessignature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {KESSignature}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.kessignature_from_bytes(ptr0, len0);\n        return KESSignature.__wrap(ret);\n    }\n}\n/**\n*/\nexport class KESVKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(KESVKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_kesvkey_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {KESVKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.kesvkey_from_bytes(ptr0, len0);\n        return KESVKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.kesvkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.kesvkey_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {KESVKey}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.kesvkey_from_bech32(ptr0, len0);\n        return KESVKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.kesvkey_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {KESVKey}\n    */\n    static from_hex(hex) {\n        var ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.kesvkey_from_hex(ptr0, len0);\n        return KESVKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Language {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Language.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_language_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.language_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Language}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.language_from_bytes(ptr0, len0);\n        return Language.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.language_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Language}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.language_from_hex(ptr0, len0);\n        return Language.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.language_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.language_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Language}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.language_from_json(ptr0, len0);\n        return Language.__wrap(ret);\n    }\n    /**\n    * @returns {Language}\n    */\n    static new_plutus_v1() {\n        var ret = wasm.language_new_plutus_v1();\n        return Language.__wrap(ret);\n    }\n    /**\n    * @returns {Language}\n    */\n    static new_plutus_v2() {\n        var ret = wasm.language_new_plutus_v2();\n        return Language.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.language_kind(this.ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nexport class Languages {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Languages.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_languages_free(ptr);\n    }\n    /**\n    * @returns {Languages}\n    */\n    static new() {\n        var ret = wasm.languages_new();\n        return Languages.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.languages_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Language}\n    */\n    get(index) {\n        var ret = wasm.languages_get(this.ptr, index);\n        return Language.__wrap(ret);\n    }\n    /**\n    * @param {Language} elem\n    */\n    add(elem) {\n        _assertClass(elem, Language);\n        var ptr0 = elem.ptr;\n        elem.ptr = 0;\n        wasm.languages_add(this.ptr, ptr0);\n    }\n}\n/**\n*/\nexport class LegacyDaedalusPrivateKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(LegacyDaedalusPrivateKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_legacydaedalusprivatekey_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {LegacyDaedalusPrivateKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.legacydaedalusprivatekey_from_bytes(ptr0, len0);\n        return LegacyDaedalusPrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.legacydaedalusprivatekey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chaincode() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.legacydaedalusprivatekey_chaincode(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class LinearFee {\n\n    static __wrap(ptr) {\n        const obj = Object.create(LinearFee.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_linearfee_free(ptr);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    constant() {\n        var ret = wasm.linearfee_constant(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coefficient() {\n        var ret = wasm.linearfee_coefficient(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coefficient\n    * @param {BigNum} constant\n    * @returns {LinearFee}\n    */\n    static new(coefficient, constant) {\n        _assertClass(coefficient, BigNum);\n        _assertClass(constant, BigNum);\n        var ret = wasm.linearfee_new(coefficient.ptr, constant.ptr);\n        return LinearFee.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MIRToStakeCredentials {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MIRToStakeCredentials.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mirtostakecredentials_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mirtostakecredentials_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MIRToStakeCredentials}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.mirtostakecredentials_from_bytes(ptr0, len0);\n        return MIRToStakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mirtostakecredentials_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {MIRToStakeCredentials}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.mirtostakecredentials_from_hex(ptr0, len0);\n        return MIRToStakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mirtostakecredentials_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.mirtostakecredentials_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {MIRToStakeCredentials}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.mirtostakecredentials_from_json(ptr0, len0);\n        return MIRToStakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {MIRToStakeCredentials}\n    */\n    static new() {\n        var ret = wasm.mirtostakecredentials_new();\n        return MIRToStakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.mirtostakecredentials_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {StakeCredential} cred\n    * @param {Int} delta\n    * @returns {Int | undefined}\n    */\n    insert(cred, delta) {\n        _assertClass(cred, StakeCredential);\n        _assertClass(delta, Int);\n        var ret = wasm.mirtostakecredentials_insert(this.ptr, cred.ptr, delta.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} cred\n    * @returns {Int | undefined}\n    */\n    get(cred) {\n        _assertClass(cred, StakeCredential);\n        var ret = wasm.mirtostakecredentials_get(this.ptr, cred.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredentials}\n    */\n    keys() {\n        var ret = wasm.mirtostakecredentials_keys(this.ptr);\n        return StakeCredentials.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MetadataList {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MetadataList.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_metadatalist_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.metadatalist_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MetadataList}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.metadatalist_from_bytes(ptr0, len0);\n        return MetadataList.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.metadatalist_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {MetadataList}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.metadatalist_from_hex(ptr0, len0);\n        return MetadataList.__wrap(ret);\n    }\n    /**\n    * @returns {MetadataList}\n    */\n    static new() {\n        var ret = wasm.metadatalist_new();\n        return MetadataList.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.metadatalist_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionMetadatum}\n    */\n    get(index) {\n        var ret = wasm.metadatalist_get(this.ptr, index);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionMetadatum} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionMetadatum);\n        wasm.metadatalist_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class MetadataMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MetadataMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_metadatamap_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.metadatamap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MetadataMap}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.metadatamap_from_bytes(ptr0, len0);\n        return MetadataMap.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.metadatamap_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {MetadataMap}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.metadatamap_from_hex(ptr0, len0);\n        return MetadataMap.__wrap(ret);\n    }\n    /**\n    * @returns {MetadataMap}\n    */\n    static new() {\n        var ret = wasm.metadatamap_new();\n        return MetadataMap.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.metadatamap_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {TransactionMetadatum} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, TransactionMetadatum);\n        _assertClass(value, TransactionMetadatum);\n        var ret = wasm.metadatamap_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {string} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert_str(key, value) {\n        var ptr0 = passStringToWasm0(key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(value, TransactionMetadatum);\n        var ret = wasm.metadatamap_insert_str(this.ptr, ptr0, len0, value.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {number} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert_i32(key, value) {\n        _assertClass(value, TransactionMetadatum);\n        var ret = wasm.metadatamap_insert_i32(this.ptr, key, value.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionMetadatum} key\n    * @returns {TransactionMetadatum}\n    */\n    get(key) {\n        _assertClass(key, TransactionMetadatum);\n        var ret = wasm.metadatamap_get(this.ptr, key.ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {string} key\n    * @returns {TransactionMetadatum}\n    */\n    get_str(key) {\n        var ptr0 = passStringToWasm0(key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.metadatamap_get_str(this.ptr, ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {number} key\n    * @returns {TransactionMetadatum}\n    */\n    get_i32(key) {\n        var ret = wasm.metadatamap_get_i32(this.ptr, key);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionMetadatum} key\n    * @returns {boolean}\n    */\n    has(key) {\n        _assertClass(key, TransactionMetadatum);\n        var ret = wasm.metadatamap_has(this.ptr, key.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {MetadataList}\n    */\n    keys() {\n        var ret = wasm.metadatamap_keys(this.ptr);\n        return MetadataList.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Mint {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Mint.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mint_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mint_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Mint}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.mint_from_bytes(ptr0, len0);\n        return Mint.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mint_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Mint}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.mint_from_hex(ptr0, len0);\n        return Mint.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mint_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.mint_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Mint}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.mint_from_json(ptr0, len0);\n        return Mint.__wrap(ret);\n    }\n    /**\n    * @returns {Mint}\n    */\n    static new() {\n        var ret = wasm.mint_new();\n        return Mint.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} key\n    * @param {MintAssets} value\n    * @returns {Mint}\n    */\n    static new_from_entry(key, value) {\n        _assertClass(key, ScriptHash);\n        _assertClass(value, MintAssets);\n        var ret = wasm.mint_new_from_entry(key.ptr, value.ptr);\n        return Mint.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.mint_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {ScriptHash} key\n    * @param {MintAssets} value\n    * @returns {MintAssets | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, ScriptHash);\n        _assertClass(value, MintAssets);\n        var ret = wasm.mint_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : MintAssets.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} key\n    * @returns {MintAssets | undefined}\n    */\n    get(key) {\n        _assertClass(key, ScriptHash);\n        var ret = wasm.mint_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : MintAssets.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHashes}\n    */\n    keys() {\n        var ret = wasm.mint_keys(this.ptr);\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * Returns the multiasset where only positive (minting) entries are present\n    * @returns {MultiAsset}\n    */\n    as_positive_multiasset() {\n        var ret = wasm.mint_as_positive_multiasset(this.ptr);\n        return MultiAsset.__wrap(ret);\n    }\n    /**\n    * Returns the multiasset where only negative (burning) entries are present\n    * @returns {MultiAsset}\n    */\n    as_negative_multiasset() {\n        var ret = wasm.mint_as_negative_multiasset(this.ptr);\n        return MultiAsset.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MintAssets {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MintAssets.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mintassets_free(ptr);\n    }\n    /**\n    * @returns {MintAssets}\n    */\n    static new() {\n        var ret = wasm.mintassets_new();\n        return MintAssets.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} key\n    * @param {Int} value\n    * @returns {MintAssets}\n    */\n    static new_from_entry(key, value) {\n        _assertClass(key, AssetName);\n        _assertClass(value, Int);\n        var ptr0 = value.ptr;\n        value.ptr = 0;\n        var ret = wasm.mintassets_new_from_entry(key.ptr, ptr0);\n        return MintAssets.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.mintassets_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {AssetName} key\n    * @param {Int} value\n    * @returns {Int | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, AssetName);\n        _assertClass(value, Int);\n        var ptr0 = value.ptr;\n        value.ptr = 0;\n        var ret = wasm.mintassets_insert(this.ptr, key.ptr, ptr0);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} key\n    * @returns {Int | undefined}\n    */\n    get(key) {\n        _assertClass(key, AssetName);\n        var ret = wasm.mintassets_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @returns {AssetNames}\n    */\n    keys() {\n        var ret = wasm.mintassets_keys(this.ptr);\n        return AssetNames.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MoveInstantaneousReward {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MoveInstantaneousReward.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_moveinstantaneousreward_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousreward_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MoveInstantaneousReward}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.moveinstantaneousreward_from_bytes(ptr0, len0);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousreward_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {MoveInstantaneousReward}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.moveinstantaneousreward_from_hex(ptr0, len0);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousreward_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.moveinstantaneousreward_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {MoveInstantaneousReward}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.moveinstantaneousreward_from_json(ptr0, len0);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @param {number} pot\n    * @param {BigNum} amount\n    * @returns {MoveInstantaneousReward}\n    */\n    static new_to_other_pot(pot, amount) {\n        _assertClass(amount, BigNum);\n        var ret = wasm.moveinstantaneousreward_new_to_other_pot(pot, amount.ptr);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @param {number} pot\n    * @param {MIRToStakeCredentials} amounts\n    * @returns {MoveInstantaneousReward}\n    */\n    static new_to_stake_creds(pot, amounts) {\n        _assertClass(amounts, MIRToStakeCredentials);\n        var ret = wasm.moveinstantaneousreward_new_to_stake_creds(pot, amounts.ptr);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    pot() {\n        var ret = wasm.moveinstantaneousreward_pot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.moveinstantaneousreward_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_to_other_pot() {\n        var ret = wasm.moveinstantaneousreward_as_to_other_pot(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {MIRToStakeCredentials | undefined}\n    */\n    as_to_stake_creds() {\n        var ret = wasm.moveinstantaneousreward_as_to_stake_creds(this.ptr);\n        return ret === 0 ? undefined : MIRToStakeCredentials.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MoveInstantaneousRewardsCert {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MoveInstantaneousRewardsCert.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_moveinstantaneousrewardscert_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousrewardscert_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MoveInstantaneousRewardsCert}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.moveinstantaneousrewardscert_from_bytes(ptr0, len0);\n        return MoveInstantaneousRewardsCert.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousrewardscert_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {MoveInstantaneousRewardsCert}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.moveinstantaneousrewardscert_from_hex(ptr0, len0);\n        return MoveInstantaneousRewardsCert.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousrewardscert_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.moveinstantaneousrewardscert_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {MoveInstantaneousRewardsCert}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.moveinstantaneousrewardscert_from_json(ptr0, len0);\n        return MoveInstantaneousRewardsCert.__wrap(ret);\n    }\n    /**\n    * @returns {MoveInstantaneousReward}\n    */\n    move_instantaneous_reward() {\n        var ret = wasm.moveinstantaneousrewardscert_move_instantaneous_reward(this.ptr);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @param {MoveInstantaneousReward} move_instantaneous_reward\n    * @returns {MoveInstantaneousRewardsCert}\n    */\n    static new(move_instantaneous_reward) {\n        _assertClass(move_instantaneous_reward, MoveInstantaneousReward);\n        var ret = wasm.moveinstantaneousrewardscert_new(move_instantaneous_reward.ptr);\n        return MoveInstantaneousRewardsCert.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MultiAsset {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MultiAsset.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_multiasset_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multiasset_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MultiAsset}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.multiasset_from_bytes(ptr0, len0);\n        return MultiAsset.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multiasset_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {MultiAsset}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.multiasset_from_hex(ptr0, len0);\n        return MultiAsset.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multiasset_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.multiasset_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {MultiAsset}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.multiasset_from_json(ptr0, len0);\n        return MultiAsset.__wrap(ret);\n    }\n    /**\n    * @returns {MultiAsset}\n    */\n    static new() {\n        var ret = wasm.multiasset_new();\n        return MultiAsset.__wrap(ret);\n    }\n    /**\n    * the number of unique policy IDs in the multiasset\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.multiasset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * set (and replace if it exists) all assets with policy {policy_id} to a copy of {assets}\n    * @param {ScriptHash} policy_id\n    * @param {Assets} assets\n    * @returns {Assets | undefined}\n    */\n    insert(policy_id, assets) {\n        _assertClass(policy_id, ScriptHash);\n        _assertClass(assets, Assets);\n        var ret = wasm.multiasset_insert(this.ptr, policy_id.ptr, assets.ptr);\n        return ret === 0 ? undefined : Assets.__wrap(ret);\n    }\n    /**\n    * all assets under {policy_id}, if any exist, or else None (undefined in JS)\n    * @param {ScriptHash} policy_id\n    * @returns {Assets | undefined}\n    */\n    get(policy_id) {\n        _assertClass(policy_id, ScriptHash);\n        var ret = wasm.multiasset_get(this.ptr, policy_id.ptr);\n        return ret === 0 ? undefined : Assets.__wrap(ret);\n    }\n    /**\n    * sets the asset {asset_name} to {value} under policy {policy_id}\n    * returns the previous amount if it was set, or else None (undefined in JS)\n    * @param {ScriptHash} policy_id\n    * @param {AssetName} asset_name\n    * @param {BigNum} value\n    * @returns {BigNum | undefined}\n    */\n    set_asset(policy_id, asset_name, value) {\n        _assertClass(policy_id, ScriptHash);\n        _assertClass(asset_name, AssetName);\n        _assertClass(value, BigNum);\n        var ptr0 = value.ptr;\n        value.ptr = 0;\n        var ret = wasm.multiasset_set_asset(this.ptr, policy_id.ptr, asset_name.ptr, ptr0);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * returns the amount of asset {asset_name} under policy {policy_id}\n    * If such an asset does not exist, 0 is returned.\n    * @param {ScriptHash} policy_id\n    * @param {AssetName} asset_name\n    * @returns {BigNum}\n    */\n    get_asset(policy_id, asset_name) {\n        _assertClass(policy_id, ScriptHash);\n        _assertClass(asset_name, AssetName);\n        var ret = wasm.multiasset_get_asset(this.ptr, policy_id.ptr, asset_name.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * returns all policy IDs used by assets in this multiasset\n    * @returns {ScriptHashes}\n    */\n    keys() {\n        var ret = wasm.multiasset_keys(this.ptr);\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * removes an asset from the list if the result is 0 or less\n    * does not modify this object, instead the result is returned\n    * @param {MultiAsset} rhs_ma\n    * @returns {MultiAsset}\n    */\n    sub(rhs_ma) {\n        _assertClass(rhs_ma, MultiAsset);\n        var ret = wasm.multiasset_sub(this.ptr, rhs_ma.ptr);\n        return MultiAsset.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MultiHostName {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MultiHostName.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_multihostname_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multihostname_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MultiHostName}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.multihostname_from_bytes(ptr0, len0);\n        return MultiHostName.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multihostname_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {MultiHostName}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.multihostname_from_hex(ptr0, len0);\n        return MultiHostName.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multihostname_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.multihostname_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {MultiHostName}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.multihostname_from_json(ptr0, len0);\n        return MultiHostName.__wrap(ret);\n    }\n    /**\n    * @returns {DNSRecordSRV}\n    */\n    dns_name() {\n        var ret = wasm.multihostname_dns_name(this.ptr);\n        return DNSRecordSRV.__wrap(ret);\n    }\n    /**\n    * @param {DNSRecordSRV} dns_name\n    * @returns {MultiHostName}\n    */\n    static new(dns_name) {\n        _assertClass(dns_name, DNSRecordSRV);\n        var ret = wasm.multihostname_new(dns_name.ptr);\n        return MultiHostName.__wrap(ret);\n    }\n}\n/**\n*/\nexport class NativeScript {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NativeScript.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nativescript_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nativescript_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {NativeScript}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.nativescript_from_bytes(ptr0, len0);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nativescript_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {NativeScript}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.nativescript_from_hex(ptr0, len0);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nativescript_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.nativescript_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {NativeScript}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.nativescript_from_json(ptr0, len0);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHash}\n    */\n    hash() {\n        var ret = wasm.nativescript_hash(this.ptr);\n        return ScriptHash.__wrap(ret);\n    }\n    /**\n    * @param {ScriptPubkey} script_pubkey\n    * @returns {NativeScript}\n    */\n    static new_script_pubkey(script_pubkey) {\n        _assertClass(script_pubkey, ScriptPubkey);\n        var ret = wasm.nativescript_new_script_pubkey(script_pubkey.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {ScriptAll} script_all\n    * @returns {NativeScript}\n    */\n    static new_script_all(script_all) {\n        _assertClass(script_all, ScriptAll);\n        var ret = wasm.nativescript_new_script_all(script_all.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {ScriptAny} script_any\n    * @returns {NativeScript}\n    */\n    static new_script_any(script_any) {\n        _assertClass(script_any, ScriptAny);\n        var ret = wasm.nativescript_new_script_any(script_any.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {ScriptNOfK} script_n_of_k\n    * @returns {NativeScript}\n    */\n    static new_script_n_of_k(script_n_of_k) {\n        _assertClass(script_n_of_k, ScriptNOfK);\n        var ret = wasm.nativescript_new_script_n_of_k(script_n_of_k.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {TimelockStart} timelock_start\n    * @returns {NativeScript}\n    */\n    static new_timelock_start(timelock_start) {\n        _assertClass(timelock_start, TimelockStart);\n        var ret = wasm.nativescript_new_timelock_start(timelock_start.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {TimelockExpiry} timelock_expiry\n    * @returns {NativeScript}\n    */\n    static new_timelock_expiry(timelock_expiry) {\n        _assertClass(timelock_expiry, TimelockExpiry);\n        var ret = wasm.nativescript_new_timelock_expiry(timelock_expiry.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.nativescript_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {ScriptPubkey | undefined}\n    */\n    as_script_pubkey() {\n        var ret = wasm.nativescript_as_script_pubkey(this.ptr);\n        return ret === 0 ? undefined : ScriptPubkey.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptAll | undefined}\n    */\n    as_script_all() {\n        var ret = wasm.nativescript_as_script_all(this.ptr);\n        return ret === 0 ? undefined : ScriptAll.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptAny | undefined}\n    */\n    as_script_any() {\n        var ret = wasm.nativescript_as_script_any(this.ptr);\n        return ret === 0 ? undefined : ScriptAny.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptNOfK | undefined}\n    */\n    as_script_n_of_k() {\n        var ret = wasm.nativescript_as_script_n_of_k(this.ptr);\n        return ret === 0 ? undefined : ScriptNOfK.__wrap(ret);\n    }\n    /**\n    * @returns {TimelockStart | undefined}\n    */\n    as_timelock_start() {\n        var ret = wasm.nativescript_as_timelock_start(this.ptr);\n        return ret === 0 ? undefined : TimelockStart.__wrap(ret);\n    }\n    /**\n    * @returns {TimelockExpiry | undefined}\n    */\n    as_timelock_expiry() {\n        var ret = wasm.nativescript_as_timelock_expiry(this.ptr);\n        return ret === 0 ? undefined : TimelockExpiry.__wrap(ret);\n    }\n    /**\n    * Returns an array of unique Ed25519KeyHashes\n    * contained within this script recursively on any depth level.\n    * The order of the keys in the result is not determined in any way.\n    * @returns {Ed25519KeyHashes}\n    */\n    get_required_signers() {\n        var ret = wasm.nativescript_get_required_signers(this.ptr);\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n}\n/**\n*/\nexport class NativeScripts {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NativeScripts.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nativescripts_free(ptr);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    static new() {\n        var ret = wasm.nativescripts_new();\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.nativescripts_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {NativeScript}\n    */\n    get(index) {\n        var ret = wasm.nativescripts_get(this.ptr, index);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {NativeScript} elem\n    */\n    add(elem) {\n        _assertClass(elem, NativeScript);\n        wasm.nativescripts_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class NetworkId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NetworkId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_networkid_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkid_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {NetworkId}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.networkid_from_bytes(ptr0, len0);\n        return NetworkId.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkid_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {NetworkId}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.networkid_from_hex(ptr0, len0);\n        return NetworkId.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkid_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.networkid_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {NetworkId}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.networkid_from_json(ptr0, len0);\n        return NetworkId.__wrap(ret);\n    }\n    /**\n    * @returns {NetworkId}\n    */\n    static testnet() {\n        var ret = wasm.networkid_testnet();\n        return NetworkId.__wrap(ret);\n    }\n    /**\n    * @returns {NetworkId}\n    */\n    static mainnet() {\n        var ret = wasm.networkid_mainnet();\n        return NetworkId.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.networkid_kind(this.ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nexport class NetworkInfo {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NetworkInfo.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_networkinfo_free(ptr);\n    }\n    /**\n    * @param {number} network_id\n    * @param {number} protocol_magic\n    * @returns {NetworkInfo}\n    */\n    static new(network_id, protocol_magic) {\n        var ret = wasm.networkinfo_new(network_id, protocol_magic);\n        return NetworkInfo.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    network_id() {\n        var ret = wasm.networkinfo_network_id(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    protocol_magic() {\n        var ret = wasm.networkinfo_protocol_magic(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {NetworkInfo}\n    */\n    static testnet() {\n        var ret = wasm.networkinfo_testnet();\n        return NetworkInfo.__wrap(ret);\n    }\n    /**\n    * @returns {NetworkInfo}\n    */\n    static mainnet() {\n        var ret = wasm.networkinfo_mainnet();\n        return NetworkInfo.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Nonce {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Nonce.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nonce_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nonce_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Nonce}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.nonce_from_bytes(ptr0, len0);\n        return Nonce.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nonce_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Nonce}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.nonce_from_hex(ptr0, len0);\n        return Nonce.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nonce_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.nonce_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Nonce}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.nonce_from_json(ptr0, len0);\n        return Nonce.__wrap(ret);\n    }\n    /**\n    * @returns {Nonce}\n    */\n    static new_identity() {\n        var ret = wasm.nonce_new_identity();\n        return Nonce.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} hash\n    * @returns {Nonce}\n    */\n    static new_from_hash(hash) {\n        var ptr0 = passArray8ToWasm0(hash, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.nonce_new_from_hash(ptr0, len0);\n        return Nonce.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    get_hash() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nonce_get_hash(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class OperationalCert {\n\n    static __wrap(ptr) {\n        const obj = Object.create(OperationalCert.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_operationalcert_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.operationalcert_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {OperationalCert}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.operationalcert_from_bytes(ptr0, len0);\n        return OperationalCert.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.operationalcert_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {OperationalCert}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.operationalcert_from_hex(ptr0, len0);\n        return OperationalCert.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.operationalcert_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.operationalcert_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {OperationalCert}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.operationalcert_from_json(ptr0, len0);\n        return OperationalCert.__wrap(ret);\n    }\n    /**\n    * @returns {KESVKey}\n    */\n    hot_vkey() {\n        var ret = wasm.operationalcert_hot_vkey(this.ptr);\n        return KESVKey.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    sequence_number() {\n        var ret = wasm.operationalcert_sequence_number(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    kes_period() {\n        var ret = wasm.operationalcert_kes_period(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Ed25519Signature}\n    */\n    sigma() {\n        var ret = wasm.operationalcert_sigma(this.ptr);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @param {KESVKey} hot_vkey\n    * @param {number} sequence_number\n    * @param {number} kes_period\n    * @param {Ed25519Signature} sigma\n    * @returns {OperationalCert}\n    */\n    static new(hot_vkey, sequence_number, kes_period, sigma) {\n        _assertClass(hot_vkey, KESVKey);\n        _assertClass(sigma, Ed25519Signature);\n        var ret = wasm.operationalcert_new(hot_vkey.ptr, sequence_number, kes_period, sigma.ptr);\n        return OperationalCert.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PlutusData {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusData.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusdata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusdata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusData}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusdata_from_bytes(ptr0, len0);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusdata_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PlutusData}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusdata_from_hex(ptr0, len0);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {ConstrPlutusData} constr_plutus_data\n    * @returns {PlutusData}\n    */\n    static new_constr_plutus_data(constr_plutus_data) {\n        _assertClass(constr_plutus_data, ConstrPlutusData);\n        var ret = wasm.plutusdata_new_constr_plutus_data(constr_plutus_data.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * Same as `.new_constr_plutus_data` but creates constr with empty data list\n    * @param {BigNum} alternative\n    * @returns {PlutusData}\n    */\n    static new_empty_constr_plutus_data(alternative) {\n        _assertClass(alternative, BigNum);\n        var ret = wasm.plutusdata_new_empty_constr_plutus_data(alternative.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusMap} map\n    * @returns {PlutusData}\n    */\n    static new_map(map) {\n        _assertClass(map, PlutusMap);\n        var ret = wasm.plutusdata_new_map(map.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusList} list\n    * @returns {PlutusData}\n    */\n    static new_list(list) {\n        _assertClass(list, PlutusList);\n        var ret = wasm.plutusdata_new_list(list.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {BigInt} integer\n    * @returns {PlutusData}\n    */\n    static new_integer(integer) {\n        _assertClass(integer, BigInt);\n        var ret = wasm.plutusdata_new_integer(integer.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusData}\n    */\n    static new_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusdata_new_bytes(ptr0, len0);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.plutusdata_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {ConstrPlutusData | undefined}\n    */\n    as_constr_plutus_data() {\n        var ret = wasm.plutusdata_as_constr_plutus_data(this.ptr);\n        return ret === 0 ? undefined : ConstrPlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusMap | undefined}\n    */\n    as_map() {\n        var ret = wasm.plutusdata_as_map(this.ptr);\n        return ret === 0 ? undefined : PlutusMap.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList | undefined}\n    */\n    as_list() {\n        var ret = wasm.plutusdata_as_list(this.ptr);\n        return ret === 0 ? undefined : PlutusList.__wrap(ret);\n    }\n    /**\n    * @returns {BigInt | undefined}\n    */\n    as_integer() {\n        var ret = wasm.plutusdata_as_integer(this.ptr);\n        return ret === 0 ? undefined : BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusdata_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} schema\n    * @returns {string}\n    */\n    to_json(schema) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusdata_to_json(retptr, this.ptr, schema);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} json\n    * @param {number} schema\n    * @returns {PlutusData}\n    */\n    static from_json(json, schema) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusdata_from_json(ptr0, len0, schema);\n        return PlutusData.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PlutusList {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusList.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutuslist_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutuslist_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusList}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutuslist_from_bytes(ptr0, len0);\n        return PlutusList.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutuslist_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PlutusList}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutuslist_from_hex(ptr0, len0);\n        return PlutusList.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList}\n    */\n    static new() {\n        var ret = wasm.plutuslist_new();\n        return PlutusList.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.plutuslist_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PlutusData}\n    */\n    get(index) {\n        var ret = wasm.plutuslist_get(this.ptr, index);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusData} elem\n    */\n    add(elem) {\n        _assertClass(elem, PlutusData);\n        wasm.plutuslist_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class PlutusMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusmap_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusmap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusMap}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusmap_from_bytes(ptr0, len0);\n        return PlutusMap.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusmap_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PlutusMap}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusmap_from_hex(ptr0, len0);\n        return PlutusMap.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusMap}\n    */\n    static new() {\n        var ret = wasm.plutusmap_new();\n        return PlutusMap.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.plutusmap_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {PlutusData} key\n    * @param {PlutusData} value\n    * @returns {PlutusData | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, PlutusData);\n        _assertClass(value, PlutusData);\n        var ret = wasm.plutusmap_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusData} key\n    * @returns {PlutusData | undefined}\n    */\n    get(key) {\n        _assertClass(key, PlutusData);\n        var ret = wasm.plutusmap_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList}\n    */\n    keys() {\n        var ret = wasm.plutusmap_keys(this.ptr);\n        return PlutusList.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PlutusScript {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusScript.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusscript_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscript_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScript}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusscript_from_bytes(ptr0, len0);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscript_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PlutusScript}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusscript_from_hex(ptr0, len0);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    *\n    *     * Creates a new Plutus script from the RAW bytes of the compiled script.\n    *     * This does NOT include any CBOR encoding around these bytes (e.g. from \"cborBytes\" in cardano-cli)\n    *     * If you creating this from those you should use PlutusScript::from_bytes() instead.\n    *\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScript}\n    */\n    static new(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusscript_new(ptr0, len0);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    *\n    *     * Creates a new Plutus script from the RAW bytes of the compiled script.\n    *     * This does NOT include any CBOR encoding around these bytes (e.g. from \"cborBytes\" in cardano-cli)\n    *     * If you creating this from those you should use PlutusScript::from_bytes() instead.\n    *\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScript}\n    */\n    static new_v2(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusscript_new_v2(ptr0, len0);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    *\n    *     * Creates a new Plutus script from the RAW bytes of the compiled script.\n    *     * This does NOT include any CBOR encoding around these bytes (e.g. from \"cborBytes\" in cardano-cli)\n    *     * If you creating this from those you should use PlutusScript::from_bytes() instead.\n    *\n    * @param {Uint8Array} bytes\n    * @param {Language} language\n    * @returns {PlutusScript}\n    */\n    static new_with_version(bytes, language) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(language, Language);\n        var ret = wasm.plutusscript_new_with_version(ptr0, len0, language.ptr);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    *\n    *     * The raw bytes of this compiled Plutus script.\n    *     * If you need \"cborBytes\" for cardano-cli use PlutusScript::to_bytes() instead.\n    *\n    * @returns {Uint8Array}\n    */\n    bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscript_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Same as `.from_bytes` but will consider the script as requiring the Plutus Language V2\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScript}\n    */\n    static from_bytes_v2(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusscript_from_bytes_v2(ptr0, len0);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    * Same as `.from_bytes` but will consider the script as requiring the specified language version\n    * @param {Uint8Array} bytes\n    * @param {Language} language\n    * @returns {PlutusScript}\n    */\n    static from_bytes_with_version(bytes, language) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(language, Language);\n        var ret = wasm.plutusscript_from_bytes_with_version(ptr0, len0, language.ptr);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    * Same as .from_hex but will consider the script as requiring the specified language version\n    * @param {string} hex_str\n    * @param {Language} language\n    * @returns {PlutusScript}\n    */\n    static from_hex_with_version(hex_str, language) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(language, Language);\n        var ret = wasm.plutusscript_from_hex_with_version(ptr0, len0, language.ptr);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHash}\n    */\n    hash() {\n        var ret = wasm.plutusscript_hash(this.ptr);\n        return ScriptHash.__wrap(ret);\n    }\n    /**\n    * @returns {Language}\n    */\n    language_version() {\n        var ret = wasm.plutusscript_language_version(this.ptr);\n        return Language.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PlutusScriptSource {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusScriptSource.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusscriptsource_free(ptr);\n    }\n    /**\n    * @param {PlutusScript} script\n    * @returns {PlutusScriptSource}\n    */\n    static new(script) {\n        _assertClass(script, PlutusScript);\n        var ret = wasm.plutusscriptsource_new(script.ptr);\n        return PlutusScriptSource.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} script_hash\n    * @param {TransactionInput} input\n    * @returns {PlutusScriptSource}\n    */\n    static new_ref_input(script_hash, input) {\n        _assertClass(script_hash, ScriptHash);\n        _assertClass(input, TransactionInput);\n        var ret = wasm.plutusscriptsource_new_ref_input(script_hash.ptr, input.ptr);\n        return PlutusScriptSource.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PlutusScripts {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusScripts.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusscripts_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscripts_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScripts}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusscripts_from_bytes(ptr0, len0);\n        return PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscripts_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PlutusScripts}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusscripts_from_hex(ptr0, len0);\n        return PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscripts_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.plutusscripts_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {PlutusScripts}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusscripts_from_json(ptr0, len0);\n        return PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusScripts}\n    */\n    static new() {\n        var ret = wasm.plutusscripts_new();\n        return PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.plutusscripts_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PlutusScript}\n    */\n    get(index) {\n        var ret = wasm.plutusscripts_get(this.ptr, index);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScript} elem\n    */\n    add(elem) {\n        _assertClass(elem, PlutusScript);\n        wasm.plutusscripts_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class PlutusWitness {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusWitness.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutuswitness_free(ptr);\n    }\n    /**\n    * @param {PlutusScript} script\n    * @param {PlutusData} datum\n    * @param {Redeemer} redeemer\n    * @returns {PlutusWitness}\n    */\n    static new(script, datum, redeemer) {\n        _assertClass(script, PlutusScript);\n        _assertClass(datum, PlutusData);\n        _assertClass(redeemer, Redeemer);\n        var ret = wasm.plutuswitness_new(script.ptr, datum.ptr, redeemer.ptr);\n        return PlutusWitness.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScriptSource} script\n    * @param {DatumSource} datum\n    * @param {Redeemer} redeemer\n    * @returns {PlutusWitness}\n    */\n    static new_with_ref(script, datum, redeemer) {\n        _assertClass(script, PlutusScriptSource);\n        _assertClass(datum, DatumSource);\n        _assertClass(redeemer, Redeemer);\n        var ret = wasm.plutuswitness_new_with_ref(script.ptr, datum.ptr, redeemer.ptr);\n        return PlutusWitness.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusScript | undefined}\n    */\n    script() {\n        var ret = wasm.plutuswitness_script(this.ptr);\n        return ret === 0 ? undefined : PlutusScript.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusData | undefined}\n    */\n    datum() {\n        var ret = wasm.plutuswitness_datum(this.ptr);\n        return ret === 0 ? undefined : PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {Redeemer}\n    */\n    redeemer() {\n        var ret = wasm.plutuswitness_redeemer(this.ptr);\n        return Redeemer.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PlutusWitnesses {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusWitnesses.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutuswitnesses_free(ptr);\n    }\n    /**\n    * @returns {PlutusWitnesses}\n    */\n    static new() {\n        var ret = wasm.plutuswitnesses_new();\n        return PlutusWitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.plutuswitnesses_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PlutusWitness}\n    */\n    get(index) {\n        var ret = wasm.plutuswitnesses_get(this.ptr, index);\n        return PlutusWitness.__wrap(ret);\n    }\n    /**\n    * @param {PlutusWitness} elem\n    */\n    add(elem) {\n        _assertClass(elem, PlutusWitness);\n        wasm.plutuswitnesses_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class Pointer {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Pointer.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pointer_free(ptr);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * This constructor uses outdated slot number format for the ttl value, tx_index and cert_index.\n    * Use `.new_pointer` instead\n    * @param {number} slot\n    * @param {number} tx_index\n    * @param {number} cert_index\n    * @returns {Pointer}\n    */\n    static new(slot, tx_index, cert_index) {\n        var ret = wasm.pointer_new(slot, tx_index, cert_index);\n        return Pointer.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} slot\n    * @param {BigNum} tx_index\n    * @param {BigNum} cert_index\n    * @returns {Pointer}\n    */\n    static new_pointer(slot, tx_index, cert_index) {\n        _assertClass(slot, BigNum);\n        _assertClass(tx_index, BigNum);\n        _assertClass(cert_index, BigNum);\n        var ret = wasm.pointer_new_pointer(slot.ptr, tx_index.ptr, cert_index.ptr);\n        return Pointer.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    slot() {\n        var ret = wasm.pointer_slot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    tx_index() {\n        var ret = wasm.pointer_tx_index(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    cert_index() {\n        var ret = wasm.pointer_cert_index(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BigNum}\n    */\n    slot_bignum() {\n        var ret = wasm.pointer_slot_bignum(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    tx_index_bignum() {\n        var ret = wasm.pointer_tx_index_bignum(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    cert_index_bignum() {\n        var ret = wasm.pointer_cert_index_bignum(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PointerAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PointerAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pointeraddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {StakeCredential} payment\n    * @param {Pointer} stake\n    * @returns {PointerAddress}\n    */\n    static new(network, payment, stake) {\n        _assertClass(payment, StakeCredential);\n        _assertClass(stake, Pointer);\n        var ret = wasm.pointeraddress_new(network, payment.ptr, stake.ptr);\n        return PointerAddress.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    payment_cred() {\n        var ret = wasm.pointeraddress_payment_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Pointer}\n    */\n    stake_pointer() {\n        var ret = wasm.pointeraddress_stake_pointer(this.ptr);\n        return Pointer.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.pointeraddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {PointerAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = wasm.pointeraddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : PointerAddress.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PoolMetadata {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolMetadata.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolmetadata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolmetadata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolMetadata}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolmetadata_from_bytes(ptr0, len0);\n        return PoolMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolmetadata_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PoolMetadata}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolmetadata_from_hex(ptr0, len0);\n        return PoolMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolmetadata_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.poolmetadata_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {PoolMetadata}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolmetadata_from_json(ptr0, len0);\n        return PoolMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {URL}\n    */\n    url() {\n        var ret = wasm.poolmetadata_url(this.ptr);\n        return URL.__wrap(ret);\n    }\n    /**\n    * @returns {PoolMetadataHash}\n    */\n    pool_metadata_hash() {\n        var ret = wasm.poolmetadata_pool_metadata_hash(this.ptr);\n        return PoolMetadataHash.__wrap(ret);\n    }\n    /**\n    * @param {URL} url\n    * @param {PoolMetadataHash} pool_metadata_hash\n    * @returns {PoolMetadata}\n    */\n    static new(url, pool_metadata_hash) {\n        _assertClass(url, URL);\n        _assertClass(pool_metadata_hash, PoolMetadataHash);\n        var ret = wasm.poolmetadata_new(url.ptr, pool_metadata_hash.ptr);\n        return PoolMetadata.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PoolMetadataHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolMetadataHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolmetadatahash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolMetadataHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolmetadatahash_from_bytes(ptr0, len0);\n        return PoolMetadataHash.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolmetadatahash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.poolmetadatahash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {PoolMetadataHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolmetadatahash_from_bech32(ptr0, len0);\n        return PoolMetadataHash.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolmetadatahash_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {PoolMetadataHash}\n    */\n    static from_hex(hex) {\n        var ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolmetadatahash_from_hex(ptr0, len0);\n        return PoolMetadataHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PoolParams {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolParams.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolparams_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolparams_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolParams}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolparams_from_bytes(ptr0, len0);\n        return PoolParams.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolparams_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PoolParams}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolparams_from_hex(ptr0, len0);\n        return PoolParams.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolparams_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.poolparams_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {PoolParams}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolparams_from_json(ptr0, len0);\n        return PoolParams.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    operator() {\n        var ret = wasm.poolparams_operator(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {VRFKeyHash}\n    */\n    vrf_keyhash() {\n        var ret = wasm.poolparams_vrf_keyhash(this.ptr);\n        return VRFKeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    pledge() {\n        var ret = wasm.poolparams_pledge(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    cost() {\n        var ret = wasm.poolparams_cost(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    margin() {\n        var ret = wasm.poolparams_margin(this.ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {RewardAddress}\n    */\n    reward_account() {\n        var ret = wasm.poolparams_reward_account(this.ptr);\n        return RewardAddress.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHashes}\n    */\n    pool_owners() {\n        var ret = wasm.poolparams_pool_owners(this.ptr);\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @returns {Relays}\n    */\n    relays() {\n        var ret = wasm.poolparams_relays(this.ptr);\n        return Relays.__wrap(ret);\n    }\n    /**\n    * @returns {PoolMetadata | undefined}\n    */\n    pool_metadata() {\n        var ret = wasm.poolparams_pool_metadata(this.ptr);\n        return ret === 0 ? undefined : PoolMetadata.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHash} operator\n    * @param {VRFKeyHash} vrf_keyhash\n    * @param {BigNum} pledge\n    * @param {BigNum} cost\n    * @param {UnitInterval} margin\n    * @param {RewardAddress} reward_account\n    * @param {Ed25519KeyHashes} pool_owners\n    * @param {Relays} relays\n    * @param {PoolMetadata | undefined} pool_metadata\n    * @returns {PoolParams}\n    */\n    static new(operator, vrf_keyhash, pledge, cost, margin, reward_account, pool_owners, relays, pool_metadata) {\n        _assertClass(operator, Ed25519KeyHash);\n        _assertClass(vrf_keyhash, VRFKeyHash);\n        _assertClass(pledge, BigNum);\n        _assertClass(cost, BigNum);\n        _assertClass(margin, UnitInterval);\n        _assertClass(reward_account, RewardAddress);\n        _assertClass(pool_owners, Ed25519KeyHashes);\n        _assertClass(relays, Relays);\n        let ptr0 = 0;\n        if (!isLikeNone(pool_metadata)) {\n            _assertClass(pool_metadata, PoolMetadata);\n            ptr0 = pool_metadata.ptr;\n            pool_metadata.ptr = 0;\n        }\n        var ret = wasm.poolparams_new(operator.ptr, vrf_keyhash.ptr, pledge.ptr, cost.ptr, margin.ptr, reward_account.ptr, pool_owners.ptr, relays.ptr, ptr0);\n        return PoolParams.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PoolRegistration {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolRegistration.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolregistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolregistration_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolRegistration}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolregistration_from_bytes(ptr0, len0);\n        return PoolRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolregistration_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PoolRegistration}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolregistration_from_hex(ptr0, len0);\n        return PoolRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolregistration_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.poolregistration_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {PoolRegistration}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolregistration_from_json(ptr0, len0);\n        return PoolRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {PoolParams}\n    */\n    pool_params() {\n        var ret = wasm.poolregistration_pool_params(this.ptr);\n        return PoolParams.__wrap(ret);\n    }\n    /**\n    * @param {PoolParams} pool_params\n    * @returns {PoolRegistration}\n    */\n    static new(pool_params) {\n        _assertClass(pool_params, PoolParams);\n        var ret = wasm.poolregistration_new(pool_params.ptr);\n        return PoolRegistration.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PoolRetirement {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolRetirement.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolretirement_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolretirement_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolRetirement}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolretirement_from_bytes(ptr0, len0);\n        return PoolRetirement.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolretirement_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PoolRetirement}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolretirement_from_hex(ptr0, len0);\n        return PoolRetirement.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolretirement_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.poolretirement_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {PoolRetirement}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolretirement_from_json(ptr0, len0);\n        return PoolRetirement.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    pool_keyhash() {\n        var ret = wasm.poolretirement_pool_keyhash(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    epoch() {\n        var ret = wasm.poolretirement_epoch(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {Ed25519KeyHash} pool_keyhash\n    * @param {number} epoch\n    * @returns {PoolRetirement}\n    */\n    static new(pool_keyhash, epoch) {\n        _assertClass(pool_keyhash, Ed25519KeyHash);\n        var ret = wasm.poolretirement_new(pool_keyhash.ptr, epoch);\n        return PoolRetirement.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PrivateKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PrivateKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_privatekey_free(ptr);\n    }\n    /**\n    * @returns {PublicKey}\n    */\n    to_public() {\n        var ret = wasm.privatekey_to_public(this.ptr);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {PrivateKey}\n    */\n    static generate_ed25519() {\n        var ret = wasm.privatekey_generate_ed25519();\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {PrivateKey}\n    */\n    static generate_ed25519extended() {\n        var ret = wasm.privatekey_generate_ed25519extended();\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * Get private key from its bech32 representation\n    * ```javascript\n    * PrivateKey.from_bech32(&#39;ed25519_sk1ahfetf02qwwg4dkq7mgp4a25lx5vh9920cr5wnxmpzz9906qvm8qwvlts0&#39;);\n    * ```\n    * For an extended 25519 key\n    * ```javascript\n    * PrivateKey.from_bech32(&#39;ed25519e_sk1gqwl4szuwwh6d0yk3nsqcc6xxc3fpvjlevgwvt60df59v8zd8f8prazt8ln3lmz096ux3xvhhvm3ca9wj2yctdh3pnw0szrma07rt5gl748fp&#39;);\n    * ```\n    * @param {string} bech32_str\n    * @returns {PrivateKey}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.privatekey_from_bech32(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PrivateKey}\n    */\n    static from_extended_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.privatekey_from_extended_bytes(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PrivateKey}\n    */\n    static from_normal_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.privatekey_from_normal_bytes(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} message\n    * @returns {Ed25519Signature}\n    */\n    sign(message) {\n        var ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.privatekey_sign(this.ptr, ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PrivateKey}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.privatekey_from_hex(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ProposedProtocolParameterUpdates {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProposedProtocolParameterUpdates.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_proposedprotocolparameterupdates_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proposedprotocolparameterupdates_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.proposedprotocolparameterupdates_from_bytes(ptr0, len0);\n        return ProposedProtocolParameterUpdates.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proposedprotocolparameterupdates_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.proposedprotocolparameterupdates_from_hex(ptr0, len0);\n        return ProposedProtocolParameterUpdates.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proposedprotocolparameterupdates_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.proposedprotocolparameterupdates_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.proposedprotocolparameterupdates_from_json(ptr0, len0);\n        return ProposedProtocolParameterUpdates.__wrap(ret);\n    }\n    /**\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    static new() {\n        var ret = wasm.proposedprotocolparameterupdates_new();\n        return ProposedProtocolParameterUpdates.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.proposedprotocolparameterupdates_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {GenesisHash} key\n    * @param {ProtocolParamUpdate} value\n    * @returns {ProtocolParamUpdate | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, GenesisHash);\n        _assertClass(value, ProtocolParamUpdate);\n        var ret = wasm.proposedprotocolparameterupdates_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @param {GenesisHash} key\n    * @returns {ProtocolParamUpdate | undefined}\n    */\n    get(key) {\n        _assertClass(key, GenesisHash);\n        var ret = wasm.proposedprotocolparameterupdates_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisHashes}\n    */\n    keys() {\n        var ret = wasm.proposedprotocolparameterupdates_keys(this.ptr);\n        return GenesisHashes.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ProtocolParamUpdate {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProtocolParamUpdate.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_protocolparamupdate_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProtocolParamUpdate}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.protocolparamupdate_from_bytes(ptr0, len0);\n        return ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ProtocolParamUpdate}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.protocolparamupdate_from_hex(ptr0, len0);\n        return ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.protocolparamupdate_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {ProtocolParamUpdate}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.protocolparamupdate_from_json(ptr0, len0);\n        return ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} minfee_a\n    */\n    set_minfee_a(minfee_a) {\n        _assertClass(minfee_a, BigNum);\n        wasm.protocolparamupdate_set_minfee_a(this.ptr, minfee_a.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    minfee_a() {\n        var ret = wasm.protocolparamupdate_minfee_a(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} minfee_b\n    */\n    set_minfee_b(minfee_b) {\n        _assertClass(minfee_b, BigNum);\n        wasm.protocolparamupdate_set_minfee_b(this.ptr, minfee_b.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    minfee_b() {\n        var ret = wasm.protocolparamupdate_minfee_b(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {number} max_block_body_size\n    */\n    set_max_block_body_size(max_block_body_size) {\n        wasm.protocolparamupdate_set_max_block_body_size(this.ptr, max_block_body_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_block_body_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_block_body_size(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} max_tx_size\n    */\n    set_max_tx_size(max_tx_size) {\n        wasm.protocolparamupdate_set_max_tx_size(this.ptr, max_tx_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_tx_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_tx_size(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} max_block_header_size\n    */\n    set_max_block_header_size(max_block_header_size) {\n        wasm.protocolparamupdate_set_max_block_header_size(this.ptr, max_block_header_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_block_header_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_block_header_size(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {BigNum} key_deposit\n    */\n    set_key_deposit(key_deposit) {\n        _assertClass(key_deposit, BigNum);\n        wasm.protocolparamupdate_set_key_deposit(this.ptr, key_deposit.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    key_deposit() {\n        var ret = wasm.protocolparamupdate_key_deposit(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} pool_deposit\n    */\n    set_pool_deposit(pool_deposit) {\n        _assertClass(pool_deposit, BigNum);\n        wasm.protocolparamupdate_set_pool_deposit(this.ptr, pool_deposit.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    pool_deposit() {\n        var ret = wasm.protocolparamupdate_pool_deposit(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {number} max_epoch\n    */\n    set_max_epoch(max_epoch) {\n        wasm.protocolparamupdate_set_max_epoch(this.ptr, max_epoch);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_epoch() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_epoch(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} n_opt\n    */\n    set_n_opt(n_opt) {\n        wasm.protocolparamupdate_set_n_opt(this.ptr, n_opt);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    n_opt() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_n_opt(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {UnitInterval} pool_pledge_influence\n    */\n    set_pool_pledge_influence(pool_pledge_influence) {\n        _assertClass(pool_pledge_influence, UnitInterval);\n        wasm.protocolparamupdate_set_pool_pledge_influence(this.ptr, pool_pledge_influence.ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    pool_pledge_influence() {\n        var ret = wasm.protocolparamupdate_pool_pledge_influence(this.ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} expansion_rate\n    */\n    set_expansion_rate(expansion_rate) {\n        _assertClass(expansion_rate, UnitInterval);\n        wasm.protocolparamupdate_set_expansion_rate(this.ptr, expansion_rate.ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    expansion_rate() {\n        var ret = wasm.protocolparamupdate_expansion_rate(this.ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} treasury_growth_rate\n    */\n    set_treasury_growth_rate(treasury_growth_rate) {\n        _assertClass(treasury_growth_rate, UnitInterval);\n        wasm.protocolparamupdate_set_treasury_growth_rate(this.ptr, treasury_growth_rate.ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    treasury_growth_rate() {\n        var ret = wasm.protocolparamupdate_treasury_growth_rate(this.ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Since babbage era this param is outdated. But this param you can meet in a pre-babbage block.\n    * @returns {UnitInterval | undefined}\n    */\n    d() {\n        var ret = wasm.protocolparamupdate_d(this.ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Since babbage era this param is outdated. But this param you can meet in a pre-babbage block.\n    * @returns {Nonce | undefined}\n    */\n    extra_entropy() {\n        var ret = wasm.protocolparamupdate_extra_entropy(this.ptr);\n        return ret === 0 ? undefined : Nonce.__wrap(ret);\n    }\n    /**\n    * @param {ProtocolVersion} protocol_version\n    */\n    set_protocol_version(protocol_version) {\n        _assertClass(protocol_version, ProtocolVersion);\n        wasm.protocolparamupdate_set_protocol_version(this.ptr, protocol_version.ptr);\n    }\n    /**\n    * @returns {ProtocolVersion | undefined}\n    */\n    protocol_version() {\n        var ret = wasm.protocolparamupdate_protocol_version(this.ptr);\n        return ret === 0 ? undefined : ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} min_pool_cost\n    */\n    set_min_pool_cost(min_pool_cost) {\n        _assertClass(min_pool_cost, BigNum);\n        wasm.protocolparamupdate_set_min_pool_cost(this.ptr, min_pool_cost.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    min_pool_cost() {\n        var ret = wasm.protocolparamupdate_min_pool_cost(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} ada_per_utxo_byte\n    */\n    set_ada_per_utxo_byte(ada_per_utxo_byte) {\n        _assertClass(ada_per_utxo_byte, BigNum);\n        wasm.protocolparamupdate_set_ada_per_utxo_byte(this.ptr, ada_per_utxo_byte.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    ada_per_utxo_byte() {\n        var ret = wasm.protocolparamupdate_ada_per_utxo_byte(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {Costmdls} cost_models\n    */\n    set_cost_models(cost_models) {\n        _assertClass(cost_models, Costmdls);\n        wasm.protocolparamupdate_set_cost_models(this.ptr, cost_models.ptr);\n    }\n    /**\n    * @returns {Costmdls | undefined}\n    */\n    cost_models() {\n        var ret = wasm.protocolparamupdate_cost_models(this.ptr);\n        return ret === 0 ? undefined : Costmdls.__wrap(ret);\n    }\n    /**\n    * @param {ExUnitPrices} execution_costs\n    */\n    set_execution_costs(execution_costs) {\n        _assertClass(execution_costs, ExUnitPrices);\n        wasm.protocolparamupdate_set_execution_costs(this.ptr, execution_costs.ptr);\n    }\n    /**\n    * @returns {ExUnitPrices | undefined}\n    */\n    execution_costs() {\n        var ret = wasm.protocolparamupdate_execution_costs(this.ptr);\n        return ret === 0 ? undefined : ExUnitPrices.__wrap(ret);\n    }\n    /**\n    * @param {ExUnits} max_tx_ex_units\n    */\n    set_max_tx_ex_units(max_tx_ex_units) {\n        _assertClass(max_tx_ex_units, ExUnits);\n        wasm.protocolparamupdate_set_max_tx_ex_units(this.ptr, max_tx_ex_units.ptr);\n    }\n    /**\n    * @returns {ExUnits | undefined}\n    */\n    max_tx_ex_units() {\n        var ret = wasm.protocolparamupdate_max_tx_ex_units(this.ptr);\n        return ret === 0 ? undefined : ExUnits.__wrap(ret);\n    }\n    /**\n    * @param {ExUnits} max_block_ex_units\n    */\n    set_max_block_ex_units(max_block_ex_units) {\n        _assertClass(max_block_ex_units, ExUnits);\n        wasm.protocolparamupdate_set_max_block_ex_units(this.ptr, max_block_ex_units.ptr);\n    }\n    /**\n    * @returns {ExUnits | undefined}\n    */\n    max_block_ex_units() {\n        var ret = wasm.protocolparamupdate_max_block_ex_units(this.ptr);\n        return ret === 0 ? undefined : ExUnits.__wrap(ret);\n    }\n    /**\n    * @param {number} max_value_size\n    */\n    set_max_value_size(max_value_size) {\n        wasm.protocolparamupdate_set_max_value_size(this.ptr, max_value_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_value_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_value_size(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} collateral_percentage\n    */\n    set_collateral_percentage(collateral_percentage) {\n        wasm.protocolparamupdate_set_collateral_percentage(this.ptr, collateral_percentage);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    collateral_percentage() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_collateral_percentage(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} max_collateral_inputs\n    */\n    set_max_collateral_inputs(max_collateral_inputs) {\n        wasm.protocolparamupdate_set_max_collateral_inputs(this.ptr, max_collateral_inputs);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_collateral_inputs() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_collateral_inputs(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {ProtocolParamUpdate}\n    */\n    static new() {\n        var ret = wasm.protocolparamupdate_new();\n        return ProtocolParamUpdate.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ProtocolVersion {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProtocolVersion.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_protocolversion_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolversion_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProtocolVersion}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.protocolversion_from_bytes(ptr0, len0);\n        return ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolversion_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ProtocolVersion}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.protocolversion_from_hex(ptr0, len0);\n        return ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolversion_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.protocolversion_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {ProtocolVersion}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.protocolversion_from_json(ptr0, len0);\n        return ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    major() {\n        var ret = wasm.protocolversion_major(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    minor() {\n        var ret = wasm.protocolversion_minor(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} major\n    * @param {number} minor\n    * @returns {ProtocolVersion}\n    */\n    static new(major, minor) {\n        var ret = wasm.protocolversion_new(major, minor);\n        return ProtocolVersion.__wrap(ret);\n    }\n}\n/**\n* ED25519 key used as public key\n*/\nexport class PublicKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PublicKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_publickey_free(ptr);\n    }\n    /**\n    * Get public key from its bech32 representation\n    * Example:\n    * ```javascript\n    * const pkey = PublicKey.from_bech32(&#39;ed25519_pk1dgaagyh470y66p899txcl3r0jaeaxu6yd7z2dxyk55qcycdml8gszkxze2&#39;);\n    * ```\n    * @param {string} bech32_str\n    * @returns {PublicKey}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.publickey_from_bech32(ptr0, len0);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.publickey_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.publickey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PublicKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.publickey_from_bytes(ptr0, len0);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @param {Ed25519Signature} signature\n    * @returns {boolean}\n    */\n    verify(data, signature) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(signature, Ed25519Signature);\n        var ret = wasm.publickey_verify(this.ptr, ptr0, len0, signature.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    hash() {\n        var ret = wasm.publickey_hash(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.publickey_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {PublicKey}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.publickey_from_hex(ptr0, len0);\n        return PublicKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PublicKeys {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PublicKeys.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_publickeys_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        var ret = wasm.publickeys_new();\n        return PublicKeys.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    size() {\n        var ret = wasm.publickeys_size(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PublicKey}\n    */\n    get(index) {\n        var ret = wasm.publickeys_get(this.ptr, index);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {PublicKey} key\n    */\n    add(key) {\n        _assertClass(key, PublicKey);\n        wasm.publickeys_add(this.ptr, key.ptr);\n    }\n}\n/**\n*/\nexport class Redeemer {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Redeemer.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_redeemer_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemer_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Redeemer}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.redeemer_from_bytes(ptr0, len0);\n        return Redeemer.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemer_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Redeemer}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.redeemer_from_hex(ptr0, len0);\n        return Redeemer.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemer_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.redeemer_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Redeemer}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.redeemer_from_json(ptr0, len0);\n        return Redeemer.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    tag() {\n        var ret = wasm.redeemer_tag(this.ptr);\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    index() {\n        var ret = wasm.redeemer_index(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusData}\n    */\n    data() {\n        var ret = wasm.redeemer_data(this.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {ExUnits}\n    */\n    ex_units() {\n        var ret = wasm.redeemer_ex_units(this.ptr);\n        return ExUnits.__wrap(ret);\n    }\n    /**\n    * @param {RedeemerTag} tag\n    * @param {BigNum} index\n    * @param {PlutusData} data\n    * @param {ExUnits} ex_units\n    * @returns {Redeemer}\n    */\n    static new(tag, index, data, ex_units) {\n        _assertClass(tag, RedeemerTag);\n        _assertClass(index, BigNum);\n        _assertClass(data, PlutusData);\n        _assertClass(ex_units, ExUnits);\n        var ret = wasm.redeemer_new(tag.ptr, index.ptr, data.ptr, ex_units.ptr);\n        return Redeemer.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RedeemerTag {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RedeemerTag.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_redeemertag_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemertag_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {RedeemerTag}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.redeemertag_from_bytes(ptr0, len0);\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemertag_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {RedeemerTag}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.redeemertag_from_hex(ptr0, len0);\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemertag_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.redeemertag_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {RedeemerTag}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.redeemertag_from_json(ptr0, len0);\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_spend() {\n        var ret = wasm.redeemertag_new_spend();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_mint() {\n        var ret = wasm.redeemertag_new_mint();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_cert() {\n        var ret = wasm.redeemertag_new_cert();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_reward() {\n        var ret = wasm.redeemertag_new_reward();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.redeemertag_kind(this.ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nexport class Redeemers {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Redeemers.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_redeemers_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemers_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Redeemers}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.redeemers_from_bytes(ptr0, len0);\n        return Redeemers.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemers_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Redeemers}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.redeemers_from_hex(ptr0, len0);\n        return Redeemers.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemers_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.redeemers_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Redeemers}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.redeemers_from_json(ptr0, len0);\n        return Redeemers.__wrap(ret);\n    }\n    /**\n    * @returns {Redeemers}\n    */\n    static new() {\n        var ret = wasm.redeemers_new();\n        return Redeemers.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.redeemers_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Redeemer}\n    */\n    get(index) {\n        var ret = wasm.redeemers_get(this.ptr, index);\n        return Redeemer.__wrap(ret);\n    }\n    /**\n    * @param {Redeemer} elem\n    */\n    add(elem) {\n        _assertClass(elem, Redeemer);\n        wasm.redeemers_add(this.ptr, elem.ptr);\n    }\n    /**\n    * @returns {ExUnits}\n    */\n    total_ex_units() {\n        var ret = wasm.redeemers_total_ex_units(this.ptr);\n        return ExUnits.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Relay {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Relay.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_relay_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relay_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Relay}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.relay_from_bytes(ptr0, len0);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relay_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Relay}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.relay_from_hex(ptr0, len0);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relay_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.relay_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Relay}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.relay_from_json(ptr0, len0);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {SingleHostAddr} single_host_addr\n    * @returns {Relay}\n    */\n    static new_single_host_addr(single_host_addr) {\n        _assertClass(single_host_addr, SingleHostAddr);\n        var ret = wasm.relay_new_single_host_addr(single_host_addr.ptr);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {SingleHostName} single_host_name\n    * @returns {Relay}\n    */\n    static new_single_host_name(single_host_name) {\n        _assertClass(single_host_name, SingleHostName);\n        var ret = wasm.relay_new_single_host_name(single_host_name.ptr);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {MultiHostName} multi_host_name\n    * @returns {Relay}\n    */\n    static new_multi_host_name(multi_host_name) {\n        _assertClass(multi_host_name, MultiHostName);\n        var ret = wasm.relay_new_multi_host_name(multi_host_name.ptr);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.relay_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {SingleHostAddr | undefined}\n    */\n    as_single_host_addr() {\n        var ret = wasm.relay_as_single_host_addr(this.ptr);\n        return ret === 0 ? undefined : SingleHostAddr.__wrap(ret);\n    }\n    /**\n    * @returns {SingleHostName | undefined}\n    */\n    as_single_host_name() {\n        var ret = wasm.relay_as_single_host_name(this.ptr);\n        return ret === 0 ? undefined : SingleHostName.__wrap(ret);\n    }\n    /**\n    * @returns {MultiHostName | undefined}\n    */\n    as_multi_host_name() {\n        var ret = wasm.relay_as_multi_host_name(this.ptr);\n        return ret === 0 ? undefined : MultiHostName.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Relays {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Relays.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_relays_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relays_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Relays}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.relays_from_bytes(ptr0, len0);\n        return Relays.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relays_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Relays}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.relays_from_hex(ptr0, len0);\n        return Relays.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relays_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.relays_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Relays}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.relays_from_json(ptr0, len0);\n        return Relays.__wrap(ret);\n    }\n    /**\n    * @returns {Relays}\n    */\n    static new() {\n        var ret = wasm.relays_new();\n        return Relays.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.relays_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Relay}\n    */\n    get(index) {\n        var ret = wasm.relays_get(this.ptr, index);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {Relay} elem\n    */\n    add(elem) {\n        _assertClass(elem, Relay);\n        wasm.relays_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class RewardAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RewardAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rewardaddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {StakeCredential} payment\n    * @returns {RewardAddress}\n    */\n    static new(network, payment) {\n        _assertClass(payment, StakeCredential);\n        var ret = wasm.rewardaddress_new(network, payment.ptr);\n        return RewardAddress.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    payment_cred() {\n        var ret = wasm.rewardaddress_payment_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.rewardaddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {RewardAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = wasm.rewardaddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : RewardAddress.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RewardAddresses {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RewardAddresses.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rewardaddresses_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rewardaddresses_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {RewardAddresses}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.rewardaddresses_from_bytes(ptr0, len0);\n        return RewardAddresses.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rewardaddresses_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {RewardAddresses}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.rewardaddresses_from_hex(ptr0, len0);\n        return RewardAddresses.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rewardaddresses_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.rewardaddresses_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {RewardAddresses}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.rewardaddresses_from_json(ptr0, len0);\n        return RewardAddresses.__wrap(ret);\n    }\n    /**\n    * @returns {RewardAddresses}\n    */\n    static new() {\n        var ret = wasm.rewardaddresses_new();\n        return RewardAddresses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.rewardaddresses_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {RewardAddress}\n    */\n    get(index) {\n        var ret = wasm.rewardaddresses_get(this.ptr, index);\n        return RewardAddress.__wrap(ret);\n    }\n    /**\n    * @param {RewardAddress} elem\n    */\n    add(elem) {\n        _assertClass(elem, RewardAddress);\n        wasm.rewardaddresses_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class ScriptAll {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptAll.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptall_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptall_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptAll}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptall_from_bytes(ptr0, len0);\n        return ScriptAll.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptall_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ScriptAll}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptall_from_hex(ptr0, len0);\n        return ScriptAll.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptall_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.scriptall_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {ScriptAll}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptall_from_json(ptr0, len0);\n        return ScriptAll.__wrap(ret);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    native_scripts() {\n        var ret = wasm.scriptall_native_scripts(this.ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    * @returns {ScriptAll}\n    */\n    static new(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        var ret = wasm.scriptall_new(native_scripts.ptr);\n        return ScriptAll.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ScriptAny {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptAny.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptany_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptany_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptAny}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptany_from_bytes(ptr0, len0);\n        return ScriptAny.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptany_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ScriptAny}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptany_from_hex(ptr0, len0);\n        return ScriptAny.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptany_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.scriptany_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {ScriptAny}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptany_from_json(ptr0, len0);\n        return ScriptAny.__wrap(ret);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    native_scripts() {\n        var ret = wasm.scriptany_native_scripts(this.ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    * @returns {ScriptAny}\n    */\n    static new(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        var ret = wasm.scriptany_new(native_scripts.ptr);\n        return ScriptAny.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ScriptDataHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptDataHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptdatahash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptDataHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptdatahash_from_bytes(ptr0, len0);\n        return ScriptDataHash.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptdatahash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.scriptdatahash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {ScriptDataHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptdatahash_from_bech32(ptr0, len0);\n        return ScriptDataHash.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptdatahash_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {ScriptDataHash}\n    */\n    static from_hex(hex) {\n        var ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptdatahash_from_hex(ptr0, len0);\n        return ScriptDataHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ScriptHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scripthash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scripthash_from_bytes(ptr0, len0);\n        return ScriptHash.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scripthash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.scripthash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {ScriptHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scripthash_from_bech32(ptr0, len0);\n        return ScriptHash.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scripthash_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {ScriptHash}\n    */\n    static from_hex(hex) {\n        var ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scripthash_from_hex(ptr0, len0);\n        return ScriptHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ScriptHashes {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptHashes.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scripthashes_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scripthashes_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptHashes}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scripthashes_from_bytes(ptr0, len0);\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scripthashes_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ScriptHashes}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scripthashes_from_hex(ptr0, len0);\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scripthashes_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.scripthashes_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {ScriptHashes}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scripthashes_from_json(ptr0, len0);\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHashes}\n    */\n    static new() {\n        var ret = wasm.scripthashes_new();\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.scripthashes_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {ScriptHash}\n    */\n    get(index) {\n        var ret = wasm.scripthashes_get(this.ptr, index);\n        return ScriptHash.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} elem\n    */\n    add(elem) {\n        _assertClass(elem, ScriptHash);\n        wasm.scripthashes_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class ScriptNOfK {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptNOfK.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptnofk_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptnofk_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptNOfK}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptnofk_from_bytes(ptr0, len0);\n        return ScriptNOfK.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptnofk_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ScriptNOfK}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptnofk_from_hex(ptr0, len0);\n        return ScriptNOfK.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptnofk_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.scriptnofk_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {ScriptNOfK}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptnofk_from_json(ptr0, len0);\n        return ScriptNOfK.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    n() {\n        var ret = wasm.scriptnofk_n(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    native_scripts() {\n        var ret = wasm.scriptnofk_native_scripts(this.ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {number} n\n    * @param {NativeScripts} native_scripts\n    * @returns {ScriptNOfK}\n    */\n    static new(n, native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        var ret = wasm.scriptnofk_new(n, native_scripts.ptr);\n        return ScriptNOfK.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ScriptPubkey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptPubkey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptpubkey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptpubkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptPubkey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptpubkey_from_bytes(ptr0, len0);\n        return ScriptPubkey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptpubkey_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ScriptPubkey}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptpubkey_from_hex(ptr0, len0);\n        return ScriptPubkey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptpubkey_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.scriptpubkey_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {ScriptPubkey}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptpubkey_from_json(ptr0, len0);\n        return ScriptPubkey.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    addr_keyhash() {\n        var ret = wasm.scriptpubkey_addr_keyhash(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHash} addr_keyhash\n    * @returns {ScriptPubkey}\n    */\n    static new(addr_keyhash) {\n        _assertClass(addr_keyhash, Ed25519KeyHash);\n        var ret = wasm.scriptpubkey_new(addr_keyhash.ptr);\n        return ScriptPubkey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ScriptRef {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptRef.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptref_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptref_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptRef}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptref_from_bytes(ptr0, len0);\n        return ScriptRef.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptref_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {ScriptRef}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptref_from_hex(ptr0, len0);\n        return ScriptRef.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptref_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.scriptref_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {ScriptRef}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptref_from_json(ptr0, len0);\n        return ScriptRef.__wrap(ret);\n    }\n    /**\n    * @param {NativeScript} native_script\n    * @returns {ScriptRef}\n    */\n    static new_native_script(native_script) {\n        _assertClass(native_script, NativeScript);\n        var ret = wasm.scriptref_new_native_script(native_script.ptr);\n        return ScriptRef.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScript} plutus_script\n    * @returns {ScriptRef}\n    */\n    static new_plutus_script(plutus_script) {\n        _assertClass(plutus_script, PlutusScript);\n        var ret = wasm.scriptref_new_plutus_script(plutus_script.ptr);\n        return ScriptRef.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_native_script() {\n        var ret = wasm.scriptref_is_native_script(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_plutus_script() {\n        var ret = wasm.scriptref_is_plutus_script(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {NativeScript | undefined}\n    */\n    native_script() {\n        var ret = wasm.scriptref_native_script(this.ptr);\n        return ret === 0 ? undefined : NativeScript.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusScript | undefined}\n    */\n    plutus_script() {\n        var ret = wasm.scriptref_plutus_script(this.ptr);\n        return ret === 0 ? undefined : PlutusScript.__wrap(ret);\n    }\n}\n/**\n*/\nexport class SingleHostAddr {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SingleHostAddr.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_singlehostaddr_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostaddr_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {SingleHostAddr}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.singlehostaddr_from_bytes(ptr0, len0);\n        return SingleHostAddr.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostaddr_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {SingleHostAddr}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.singlehostaddr_from_hex(ptr0, len0);\n        return SingleHostAddr.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostaddr_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.singlehostaddr_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {SingleHostAddr}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.singlehostaddr_from_json(ptr0, len0);\n        return SingleHostAddr.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    port() {\n        var ret = wasm.singlehostaddr_port(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n    /**\n    * @returns {Ipv4 | undefined}\n    */\n    ipv4() {\n        var ret = wasm.singlehostaddr_ipv4(this.ptr);\n        return ret === 0 ? undefined : Ipv4.__wrap(ret);\n    }\n    /**\n    * @returns {Ipv6 | undefined}\n    */\n    ipv6() {\n        var ret = wasm.singlehostaddr_ipv6(this.ptr);\n        return ret === 0 ? undefined : Ipv6.__wrap(ret);\n    }\n    /**\n    * @param {number | undefined} port\n    * @param {Ipv4 | undefined} ipv4\n    * @param {Ipv6 | undefined} ipv6\n    * @returns {SingleHostAddr}\n    */\n    static new(port, ipv4, ipv6) {\n        let ptr0 = 0;\n        if (!isLikeNone(ipv4)) {\n            _assertClass(ipv4, Ipv4);\n            ptr0 = ipv4.ptr;\n            ipv4.ptr = 0;\n        }\n        let ptr1 = 0;\n        if (!isLikeNone(ipv6)) {\n            _assertClass(ipv6, Ipv6);\n            ptr1 = ipv6.ptr;\n            ipv6.ptr = 0;\n        }\n        var ret = wasm.singlehostaddr_new(isLikeNone(port) ? 0xFFFFFF : port, ptr0, ptr1);\n        return SingleHostAddr.__wrap(ret);\n    }\n}\n/**\n*/\nexport class SingleHostName {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SingleHostName.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_singlehostname_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostname_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {SingleHostName}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.singlehostname_from_bytes(ptr0, len0);\n        return SingleHostName.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostname_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {SingleHostName}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.singlehostname_from_hex(ptr0, len0);\n        return SingleHostName.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostname_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.singlehostname_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {SingleHostName}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.singlehostname_from_json(ptr0, len0);\n        return SingleHostName.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    port() {\n        var ret = wasm.singlehostname_port(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n    /**\n    * @returns {DNSRecordAorAAAA}\n    */\n    dns_name() {\n        var ret = wasm.singlehostname_dns_name(this.ptr);\n        return DNSRecordAorAAAA.__wrap(ret);\n    }\n    /**\n    * @param {number | undefined} port\n    * @param {DNSRecordAorAAAA} dns_name\n    * @returns {SingleHostName}\n    */\n    static new(port, dns_name) {\n        _assertClass(dns_name, DNSRecordAorAAAA);\n        var ret = wasm.singlehostname_new(isLikeNone(port) ? 0xFFFFFF : port, dns_name.ptr);\n        return SingleHostName.__wrap(ret);\n    }\n}\n/**\n*/\nexport class StakeCredential {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeCredential.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakecredential_free(ptr);\n    }\n    /**\n    * @param {Ed25519KeyHash} hash\n    * @returns {StakeCredential}\n    */\n    static from_keyhash(hash) {\n        _assertClass(hash, Ed25519KeyHash);\n        var ret = wasm.stakecredential_from_keyhash(hash.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} hash\n    * @returns {StakeCredential}\n    */\n    static from_scripthash(hash) {\n        _assertClass(hash, ScriptHash);\n        var ret = wasm.stakecredential_from_scripthash(hash.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash | undefined}\n    */\n    to_keyhash() {\n        var ret = wasm.stakecredential_to_keyhash(this.ptr);\n        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHash | undefined}\n    */\n    to_scripthash() {\n        var ret = wasm.stakecredential_to_scripthash(this.ptr);\n        return ret === 0 ? undefined : ScriptHash.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.stakecredential_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakecredential_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeCredential}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakecredential_from_bytes(ptr0, len0);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakecredential_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {StakeCredential}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakecredential_from_hex(ptr0, len0);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakecredential_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.stakecredential_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {StakeCredential}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakecredential_from_json(ptr0, len0);\n        return StakeCredential.__wrap(ret);\n    }\n}\n/**\n*/\nexport class StakeCredentials {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeCredentials.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakecredentials_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakecredentials_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeCredentials}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakecredentials_from_bytes(ptr0, len0);\n        return StakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakecredentials_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {StakeCredentials}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakecredentials_from_hex(ptr0, len0);\n        return StakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakecredentials_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.stakecredentials_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {StakeCredentials}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakecredentials_from_json(ptr0, len0);\n        return StakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredentials}\n    */\n    static new() {\n        var ret = wasm.stakecredentials_new();\n        return StakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.stakecredentials_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {StakeCredential}\n    */\n    get(index) {\n        var ret = wasm.stakecredentials_get(this.ptr, index);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} elem\n    */\n    add(elem) {\n        _assertClass(elem, StakeCredential);\n        wasm.stakecredentials_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class StakeDelegation {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeDelegation.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakedelegation_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakedelegation_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeDelegation}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakedelegation_from_bytes(ptr0, len0);\n        return StakeDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakedelegation_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {StakeDelegation}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakedelegation_from_hex(ptr0, len0);\n        return StakeDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakedelegation_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.stakedelegation_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {StakeDelegation}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakedelegation_from_json(ptr0, len0);\n        return StakeDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    stake_credential() {\n        var ret = wasm.stakedelegation_stake_credential(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    pool_keyhash() {\n        var ret = wasm.stakedelegation_pool_keyhash(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} stake_credential\n    * @param {Ed25519KeyHash} pool_keyhash\n    * @returns {StakeDelegation}\n    */\n    static new(stake_credential, pool_keyhash) {\n        _assertClass(stake_credential, StakeCredential);\n        _assertClass(pool_keyhash, Ed25519KeyHash);\n        var ret = wasm.stakedelegation_new(stake_credential.ptr, pool_keyhash.ptr);\n        return StakeDelegation.__wrap(ret);\n    }\n}\n/**\n*/\nexport class StakeDeregistration {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeDeregistration.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakederegistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakederegistration_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeDeregistration}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakederegistration_from_bytes(ptr0, len0);\n        return StakeDeregistration.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakederegistration_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {StakeDeregistration}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakederegistration_from_hex(ptr0, len0);\n        return StakeDeregistration.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakederegistration_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.stakederegistration_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {StakeDeregistration}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakederegistration_from_json(ptr0, len0);\n        return StakeDeregistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    stake_credential() {\n        var ret = wasm.stakederegistration_stake_credential(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} stake_credential\n    * @returns {StakeDeregistration}\n    */\n    static new(stake_credential) {\n        _assertClass(stake_credential, StakeCredential);\n        var ret = wasm.stakederegistration_new(stake_credential.ptr);\n        return StakeDeregistration.__wrap(ret);\n    }\n}\n/**\n*/\nexport class StakeRegistration {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeRegistration.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakeregistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakeregistration_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeRegistration}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakeregistration_from_bytes(ptr0, len0);\n        return StakeRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakeregistration_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {StakeRegistration}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakeregistration_from_hex(ptr0, len0);\n        return StakeRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakeregistration_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.stakeregistration_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {StakeRegistration}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakeregistration_from_json(ptr0, len0);\n        return StakeRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    stake_credential() {\n        var ret = wasm.stakeregistration_stake_credential(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} stake_credential\n    * @returns {StakeRegistration}\n    */\n    static new(stake_credential) {\n        _assertClass(stake_credential, StakeCredential);\n        var ret = wasm.stakeregistration_new(stake_credential.ptr);\n        return StakeRegistration.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Strings {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Strings.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_strings_free(ptr);\n    }\n    /**\n    * @returns {Strings}\n    */\n    static new() {\n        var ret = wasm.strings_new();\n        return Strings.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.strings_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {string}\n    */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.strings_get(retptr, this.ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} elem\n    */\n    add(elem) {\n        var ptr0 = passStringToWasm0(elem, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.strings_add(this.ptr, ptr0, len0);\n    }\n}\n/**\n*/\nexport class TimelockExpiry {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TimelockExpiry.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_timelockexpiry_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockexpiry_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TimelockExpiry}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.timelockexpiry_from_bytes(ptr0, len0);\n        return TimelockExpiry.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockexpiry_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TimelockExpiry}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.timelockexpiry_from_hex(ptr0, len0);\n        return TimelockExpiry.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockexpiry_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.timelockexpiry_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {TimelockExpiry}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.timelockexpiry_from_json(ptr0, len0);\n        return TimelockExpiry.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    slot() {\n        var ret = wasm.timelockexpiry_slot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BigNum}\n    */\n    slot_bignum() {\n        var ret = wasm.timelockexpiry_slot_bignum(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * This constructor uses outdated slot number format.\n    * Use `.new_timelockexpiry` instead\n    * @param {number} slot\n    * @returns {TimelockExpiry}\n    */\n    static new(slot) {\n        var ret = wasm.timelockexpiry_new(slot);\n        return TimelockExpiry.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} slot\n    * @returns {TimelockExpiry}\n    */\n    static new_timelockexpiry(slot) {\n        _assertClass(slot, BigNum);\n        var ret = wasm.timelockexpiry_new_timelockexpiry(slot.ptr);\n        return TimelockExpiry.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TimelockStart {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TimelockStart.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_timelockstart_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockstart_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TimelockStart}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.timelockstart_from_bytes(ptr0, len0);\n        return TimelockStart.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockstart_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TimelockStart}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.timelockstart_from_hex(ptr0, len0);\n        return TimelockStart.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockstart_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.timelockstart_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {TimelockStart}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.timelockstart_from_json(ptr0, len0);\n        return TimelockStart.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Returns a Slot32 (u32) value in case the underlying original BigNum (u64) value is within the limits.\n    * Otherwise will just raise an error.\n    * Use `.slot_bignum` instead\n    * @returns {number}\n    */\n    slot() {\n        var ret = wasm.timelockstart_slot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BigNum}\n    */\n    slot_bignum() {\n        var ret = wasm.timelockstart_slot_bignum(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * This constructor uses outdated slot number format.\n    * Use `.new_timelockstart` instead.\n    * @param {number} slot\n    * @returns {TimelockStart}\n    */\n    static new(slot) {\n        var ret = wasm.timelockstart_new(slot);\n        return TimelockStart.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} slot\n    * @returns {TimelockStart}\n    */\n    static new_timelockstart(slot) {\n        _assertClass(slot, BigNum);\n        var ret = wasm.timelockstart_new_timelockstart(slot.ptr);\n        return TimelockStart.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Transaction {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Transaction.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transaction_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Transaction}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transaction_from_bytes(ptr0, len0);\n        return Transaction.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Transaction}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transaction_from_hex(ptr0, len0);\n        return Transaction.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.transaction_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Transaction}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transaction_from_json(ptr0, len0);\n        return Transaction.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionBody}\n    */\n    body() {\n        var ret = wasm.transaction_body(this.ptr);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSet}\n    */\n    witness_set() {\n        var ret = wasm.transaction_witness_set(this.ptr);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_valid() {\n        var ret = wasm.transaction_is_valid(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {AuxiliaryData | undefined}\n    */\n    auxiliary_data() {\n        var ret = wasm.transaction_auxiliary_data(this.ptr);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @param {boolean} valid\n    */\n    set_is_valid(valid) {\n        wasm.transaction_set_is_valid(this.ptr, valid);\n    }\n    /**\n    * @param {TransactionBody} body\n    * @param {TransactionWitnessSet} witness_set\n    * @param {AuxiliaryData | undefined} auxiliary_data\n    * @returns {Transaction}\n    */\n    static new(body, witness_set, auxiliary_data) {\n        _assertClass(body, TransactionBody);\n        _assertClass(witness_set, TransactionWitnessSet);\n        let ptr0 = 0;\n        if (!isLikeNone(auxiliary_data)) {\n            _assertClass(auxiliary_data, AuxiliaryData);\n            ptr0 = auxiliary_data.ptr;\n            auxiliary_data.ptr = 0;\n        }\n        var ret = wasm.transaction_new(body.ptr, witness_set.ptr, ptr0);\n        return Transaction.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionBodies {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionBodies.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbodies_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbodies_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionBodies}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionbodies_from_bytes(ptr0, len0);\n        return TransactionBodies.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbodies_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionBodies}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionbodies_from_hex(ptr0, len0);\n        return TransactionBodies.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbodies_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.transactionbodies_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionBodies}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionbodies_from_json(ptr0, len0);\n        return TransactionBodies.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionBodies}\n    */\n    static new() {\n        var ret = wasm.transactionbodies_new();\n        return TransactionBodies.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.transactionbodies_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionBody}\n    */\n    get(index) {\n        var ret = wasm.transactionbodies_get(this.ptr, index);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @param {TransactionBody} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionBody);\n        wasm.transactionbodies_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class TransactionBody {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionBody.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbody_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionBody}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionbody_from_bytes(ptr0, len0);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionBody}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionbody_from_hex(ptr0, len0);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.transactionbody_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionBody}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionbody_from_json(ptr0, len0);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    inputs() {\n        var ret = wasm.transactionbody_inputs(this.ptr);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutputs}\n    */\n    outputs() {\n        var ret = wasm.transactionbody_outputs(this.ptr);\n        return TransactionOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    fee() {\n        var ret = wasm.transactionbody_fee(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Returns a Slot32 (u32) value in case the underlying original BigNum (u64) value is within the limits.\n    * Otherwise will just raise an error.\n    * @returns {number | undefined}\n    */\n    ttl() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_ttl(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    ttl_bignum() {\n        var ret = wasm.transactionbody_ttl_bignum(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} ttl\n    */\n    set_ttl(ttl) {\n        _assertClass(ttl, BigNum);\n        wasm.transactionbody_set_ttl(this.ptr, ttl.ptr);\n    }\n    /**\n    */\n    remove_ttl() {\n        wasm.transactionbody_remove_ttl(this.ptr);\n    }\n    /**\n    * @param {Certificates} certs\n    */\n    set_certs(certs) {\n        _assertClass(certs, Certificates);\n        wasm.transactionbody_set_certs(this.ptr, certs.ptr);\n    }\n    /**\n    * @returns {Certificates | undefined}\n    */\n    certs() {\n        var ret = wasm.transactionbody_certs(this.ptr);\n        return ret === 0 ? undefined : Certificates.__wrap(ret);\n    }\n    /**\n    * @param {Withdrawals} withdrawals\n    */\n    set_withdrawals(withdrawals) {\n        _assertClass(withdrawals, Withdrawals);\n        wasm.transactionbody_set_withdrawals(this.ptr, withdrawals.ptr);\n    }\n    /**\n    * @returns {Withdrawals | undefined}\n    */\n    withdrawals() {\n        var ret = wasm.transactionbody_withdrawals(this.ptr);\n        return ret === 0 ? undefined : Withdrawals.__wrap(ret);\n    }\n    /**\n    * @param {Update} update\n    */\n    set_update(update) {\n        _assertClass(update, Update);\n        wasm.transactionbody_set_update(this.ptr, update.ptr);\n    }\n    /**\n    * @returns {Update | undefined}\n    */\n    update() {\n        var ret = wasm.transactionbody_update(this.ptr);\n        return ret === 0 ? undefined : Update.__wrap(ret);\n    }\n    /**\n    * @param {AuxiliaryDataHash} auxiliary_data_hash\n    */\n    set_auxiliary_data_hash(auxiliary_data_hash) {\n        _assertClass(auxiliary_data_hash, AuxiliaryDataHash);\n        wasm.transactionbody_set_auxiliary_data_hash(this.ptr, auxiliary_data_hash.ptr);\n    }\n    /**\n    * @returns {AuxiliaryDataHash | undefined}\n    */\n    auxiliary_data_hash() {\n        var ret = wasm.transactionbody_auxiliary_data_hash(this.ptr);\n        return ret === 0 ? undefined : AuxiliaryDataHash.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Uses outdated slot number format.\n    * @param {number} validity_start_interval\n    */\n    set_validity_start_interval(validity_start_interval) {\n        wasm.transactionbody_set_validity_start_interval(this.ptr, validity_start_interval);\n    }\n    /**\n    * @param {BigNum} validity_start_interval\n    */\n    set_validity_start_interval_bignum(validity_start_interval) {\n        _assertClass(validity_start_interval, BigNum);\n        var ptr0 = validity_start_interval.ptr;\n        validity_start_interval.ptr = 0;\n        wasm.transactionbody_set_validity_start_interval_bignum(this.ptr, ptr0);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    validity_start_interval_bignum() {\n        var ret = wasm.transactionbody_validity_start_interval_bignum(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Returns a Option<Slot32> (u32) value in case the underlying original Option<BigNum> (u64) value is within the limits.\n    * Otherwise will just raise an error.\n    * Use `.validity_start_interval_bignum` instead.\n    * @returns {number | undefined}\n    */\n    validity_start_interval() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_validity_start_interval(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Mint} mint\n    */\n    set_mint(mint) {\n        _assertClass(mint, Mint);\n        wasm.transactionbody_set_mint(this.ptr, mint.ptr);\n    }\n    /**\n    * @returns {Mint | undefined}\n    */\n    mint() {\n        var ret = wasm.transactionbody_mint(this.ptr);\n        return ret === 0 ? undefined : Mint.__wrap(ret);\n    }\n    /**\n    * This function returns the mint value of the transaction\n    * Use `.mint()` instead.\n    * @returns {Mint | undefined}\n    */\n    multiassets() {\n        var ret = wasm.transactionbody_multiassets(this.ptr);\n        return ret === 0 ? undefined : Mint.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInputs} reference_inputs\n    */\n    set_reference_inputs(reference_inputs) {\n        _assertClass(reference_inputs, TransactionInputs);\n        wasm.transactionbody_set_reference_inputs(this.ptr, reference_inputs.ptr);\n    }\n    /**\n    * @returns {TransactionInputs | undefined}\n    */\n    reference_inputs() {\n        var ret = wasm.transactionbody_reference_inputs(this.ptr);\n        return ret === 0 ? undefined : TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @param {ScriptDataHash} script_data_hash\n    */\n    set_script_data_hash(script_data_hash) {\n        _assertClass(script_data_hash, ScriptDataHash);\n        wasm.transactionbody_set_script_data_hash(this.ptr, script_data_hash.ptr);\n    }\n    /**\n    * @returns {ScriptDataHash | undefined}\n    */\n    script_data_hash() {\n        var ret = wasm.transactionbody_script_data_hash(this.ptr);\n        return ret === 0 ? undefined : ScriptDataHash.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInputs} collateral\n    */\n    set_collateral(collateral) {\n        _assertClass(collateral, TransactionInputs);\n        wasm.transactionbody_set_collateral(this.ptr, collateral.ptr);\n    }\n    /**\n    * @returns {TransactionInputs | undefined}\n    */\n    collateral() {\n        var ret = wasm.transactionbody_collateral(this.ptr);\n        return ret === 0 ? undefined : TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHashes} required_signers\n    */\n    set_required_signers(required_signers) {\n        _assertClass(required_signers, Ed25519KeyHashes);\n        wasm.transactionbody_set_required_signers(this.ptr, required_signers.ptr);\n    }\n    /**\n    * @returns {Ed25519KeyHashes | undefined}\n    */\n    required_signers() {\n        var ret = wasm.transactionbody_required_signers(this.ptr);\n        return ret === 0 ? undefined : Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @param {NetworkId} network_id\n    */\n    set_network_id(network_id) {\n        _assertClass(network_id, NetworkId);\n        wasm.transactionbody_set_network_id(this.ptr, network_id.ptr);\n    }\n    /**\n    * @returns {NetworkId | undefined}\n    */\n    network_id() {\n        var ret = wasm.transactionbody_network_id(this.ptr);\n        return ret === 0 ? undefined : NetworkId.__wrap(ret);\n    }\n    /**\n    * @param {TransactionOutput} collateral_return\n    */\n    set_collateral_return(collateral_return) {\n        _assertClass(collateral_return, TransactionOutput);\n        wasm.transactionbody_set_collateral_return(this.ptr, collateral_return.ptr);\n    }\n    /**\n    * @returns {TransactionOutput | undefined}\n    */\n    collateral_return() {\n        var ret = wasm.transactionbody_collateral_return(this.ptr);\n        return ret === 0 ? undefined : TransactionOutput.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} total_collateral\n    */\n    set_total_collateral(total_collateral) {\n        _assertClass(total_collateral, BigNum);\n        wasm.transactionbody_set_total_collateral(this.ptr, total_collateral.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    total_collateral() {\n        var ret = wasm.transactionbody_total_collateral(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * This constructor uses outdated slot number format for the ttl value.\n    * Use `.new_tx_body` and then `.set_ttl` instead\n    * @param {TransactionInputs} inputs\n    * @param {TransactionOutputs} outputs\n    * @param {BigNum} fee\n    * @param {number | undefined} ttl\n    * @returns {TransactionBody}\n    */\n    static new(inputs, outputs, fee, ttl) {\n        _assertClass(inputs, TransactionInputs);\n        _assertClass(outputs, TransactionOutputs);\n        _assertClass(fee, BigNum);\n        var ret = wasm.transactionbody_new(inputs.ptr, outputs.ptr, fee.ptr, !isLikeNone(ttl), isLikeNone(ttl) ? 0 : ttl);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * Returns a new TransactionBody.\n    * In the new version of \"new\" we removed optional ttl for support it by wasm_bingen.\n    * Your can use \"set_ttl\" and \"remove_ttl\" to set a new value for ttl or set it as None.\n    * @param {TransactionInputs} inputs\n    * @param {TransactionOutputs} outputs\n    * @param {BigNum} fee\n    * @returns {TransactionBody}\n    */\n    static new_tx_body(inputs, outputs, fee) {\n        _assertClass(inputs, TransactionInputs);\n        _assertClass(outputs, TransactionOutputs);\n        _assertClass(fee, BigNum);\n        var ret = wasm.transactionbody_new_tx_body(inputs.ptr, outputs.ptr, fee.ptr);\n        return TransactionBody.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbuilder_free(ptr);\n    }\n    /**\n    * This automatically selects and adds inputs from {inputs} consisting of just enough to cover\n    * the outputs that have already been added.\n    * This should be called after adding all certs/outputs/etc and will be an error otherwise.\n    * Uses CIP2: https://github.com/cardano-foundation/CIPs/blob/master/CIP-0002/CIP-0002.md\n    * Adding a change output must be called after via TransactionBuilder::add_change_if_needed()\n    * This function, diverging from CIP2, takes into account fees and will attempt to add additional\n    * inputs to cover the minimum fees. This does not, however, set the txbuilder's fee.\n    * @param {TransactionUnspentOutputs} inputs\n    * @param {number} strategy\n    */\n    add_inputs_from(inputs, strategy) {\n        _assertClass(inputs, TransactionUnspentOutputs);\n        wasm.transactionbuilder_add_inputs_from(this.ptr, inputs.ptr, strategy);\n    }\n    /**\n    * @param {TxInputsBuilder} inputs\n    */\n    set_inputs(inputs) {\n        _assertClass(inputs, TxInputsBuilder);\n        wasm.transactionbuilder_set_inputs(this.ptr, inputs.ptr);\n    }\n    /**\n    * @param {TxInputsBuilder} collateral\n    */\n    set_collateral(collateral) {\n        _assertClass(collateral, TxInputsBuilder);\n        wasm.transactionbuilder_set_collateral(this.ptr, collateral.ptr);\n    }\n    /**\n    * @param {TransactionOutput} collateral_return\n    */\n    set_collateral_return(collateral_return) {\n        _assertClass(collateral_return, TransactionOutput);\n        wasm.transactionbuilder_set_collateral_return(this.ptr, collateral_return.ptr);\n    }\n    /**\n    * This function will set the collateral-return value and then auto-calculate and assign\n    * the total collateral coin value. Will raise an error in case no collateral inputs are set\n    * or in case the total collateral value will have any assets in it except coin.\n    * @param {TransactionOutput} collateral_return\n    */\n    set_collateral_return_and_total(collateral_return) {\n        _assertClass(collateral_return, TransactionOutput);\n        wasm.transactionbuilder_set_collateral_return_and_total(this.ptr, collateral_return.ptr);\n    }\n    /**\n    * @param {BigNum} total_collateral\n    */\n    set_total_collateral(total_collateral) {\n        _assertClass(total_collateral, BigNum);\n        wasm.transactionbuilder_set_total_collateral(this.ptr, total_collateral.ptr);\n    }\n    /**\n    * This function will set the total-collateral coin and then auto-calculate and assign\n    * the collateral return value. Will raise an error in case no collateral inputs are set.\n    * The specified address will be the received of the collateral return\n    * @param {BigNum} total_collateral\n    * @param {Address} return_address\n    */\n    set_total_collateral_and_return(total_collateral, return_address) {\n        _assertClass(total_collateral, BigNum);\n        _assertClass(return_address, Address);\n        wasm.transactionbuilder_set_total_collateral_and_return(this.ptr, total_collateral.ptr, return_address.ptr);\n    }\n    /**\n    * @param {TransactionInput} reference_input\n    */\n    add_reference_input(reference_input) {\n        _assertClass(reference_input, TransactionInput);\n        wasm.transactionbuilder_add_reference_input(this.ptr, reference_input.ptr);\n    }\n    /**\n    * We have to know what kind of inputs these are to know what kind of mock witnesses to create since\n    * 1) mock witnesses have different lengths depending on the type which changes the expecting fee\n    * 2) Witnesses are a set so we need to get rid of duplicates to avoid over-estimating the fee\n    * @param {Ed25519KeyHash} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_key_input(hash, input, amount) {\n        _assertClass(hash, Ed25519KeyHash);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_key_input(this.ptr, hash.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * This method adds the input to the builder BUT leaves a missing spot for the witness native script\n    *\n    * After adding the input with this method, use `.add_required_native_input_scripts`\n    * and `.add_required_plutus_input_scripts` to add the witness scripts\n    *\n    * Or instead use `.add_native_script_input` and `.add_plutus_script_input`\n    * to add inputs right along with the script, instead of the script hash\n    * @param {ScriptHash} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_script_input(hash, input, amount) {\n        _assertClass(hash, ScriptHash);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_script_input(this.ptr, hash.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * This method will add the input to the builder and also register the required native script witness\n    * @param {NativeScript} script\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_native_script_input(script, input, amount) {\n        _assertClass(script, NativeScript);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_native_script_input(this.ptr, script.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * This method will add the input to the builder and also register the required plutus witness\n    * @param {PlutusWitness} witness\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_plutus_script_input(witness, input, amount) {\n        _assertClass(witness, PlutusWitness);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_plutus_script_input(this.ptr, witness.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * @param {ByronAddress} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_bootstrap_input(hash, input, amount) {\n        _assertClass(hash, ByronAddress);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_bootstrap_input(this.ptr, hash.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * Note that for script inputs this method will use underlying generic `.add_script_input`\n    * which leaves a required empty spot for the script witness (or witnesses in case of Plutus).\n    * You can use `.add_native_script_input` or `.add_plutus_script_input` directly to register the input along with the witness.\n    * @param {Address} address\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_input(address, input, amount) {\n        _assertClass(address, Address);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_input(this.ptr, address.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * Returns the number of still missing input scripts (either native or plutus)\n    * Use `.add_required_native_input_scripts` or `.add_required_plutus_input_scripts` to add the missing scripts\n    * @returns {number}\n    */\n    count_missing_input_scripts() {\n        var ret = wasm.transactionbuilder_count_missing_input_scripts(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Try adding the specified scripts as witnesses for ALREADY ADDED script inputs\n    * Any scripts that don't match any of the previously added inputs will be ignored\n    * Returns the number of remaining required missing witness scripts\n    * Use `.count_missing_input_scripts` to find the number of still missing scripts\n    * @param {NativeScripts} scripts\n    * @returns {number}\n    */\n    add_required_native_input_scripts(scripts) {\n        _assertClass(scripts, NativeScripts);\n        var ret = wasm.transactionbuilder_add_required_native_input_scripts(this.ptr, scripts.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Try adding the specified scripts as witnesses for ALREADY ADDED script inputs\n    * Any scripts that don't match any of the previously added inputs will be ignored\n    * Returns the number of remaining required missing witness scripts\n    * Use `.count_missing_input_scripts` to find the number of still missing scripts\n    * @param {PlutusWitnesses} scripts\n    * @returns {number}\n    */\n    add_required_plutus_input_scripts(scripts) {\n        _assertClass(scripts, PlutusWitnesses);\n        var ret = wasm.transactionbuilder_add_required_plutus_input_scripts(this.ptr, scripts.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a copy of the current script input witness scripts in the builder\n    * @returns {NativeScripts | undefined}\n    */\n    get_native_input_scripts() {\n        var ret = wasm.transactionbuilder_get_native_input_scripts(this.ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * Returns a copy of the current plutus input witness scripts in the builder.\n    * NOTE: each plutus witness will be cloned with a specific corresponding input index\n    * @returns {PlutusWitnesses | undefined}\n    */\n    get_plutus_input_scripts() {\n        var ret = wasm.transactionbuilder_get_plutus_input_scripts(this.ptr);\n        return ret === 0 ? undefined : PlutusWitnesses.__wrap(ret);\n    }\n    /**\n    * calculates how much the fee would increase if you added a given output\n    * @param {Address} address\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    * @returns {BigNum}\n    */\n    fee_for_input(address, input, amount) {\n        _assertClass(address, Address);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        var ret = wasm.transactionbuilder_fee_for_input(this.ptr, address.ptr, input.ptr, amount.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * Add explicit output via a TransactionOutput object\n    * @param {TransactionOutput} output\n    */\n    add_output(output) {\n        _assertClass(output, TransactionOutput);\n        wasm.transactionbuilder_add_output(this.ptr, output.ptr);\n    }\n    /**\n    * calculates how much the fee would increase if you added a given output\n    * @param {TransactionOutput} output\n    * @returns {BigNum}\n    */\n    fee_for_output(output) {\n        _assertClass(output, TransactionOutput);\n        var ret = wasm.transactionbuilder_fee_for_output(this.ptr, output.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} fee\n    */\n    set_fee(fee) {\n        _assertClass(fee, BigNum);\n        wasm.transactionbuilder_set_fee(this.ptr, fee.ptr);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Set ttl value.\n    * @param {number} ttl\n    */\n    set_ttl(ttl) {\n        wasm.transactionbuilder_set_ttl(this.ptr, ttl);\n    }\n    /**\n    * @param {BigNum} ttl\n    */\n    set_ttl_bignum(ttl) {\n        _assertClass(ttl, BigNum);\n        wasm.transactionbuilder_set_ttl_bignum(this.ptr, ttl.ptr);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Uses outdated slot number format.\n    * @param {number} validity_start_interval\n    */\n    set_validity_start_interval(validity_start_interval) {\n        wasm.transactionbuilder_set_validity_start_interval(this.ptr, validity_start_interval);\n    }\n    /**\n    * @param {BigNum} validity_start_interval\n    */\n    set_validity_start_interval_bignum(validity_start_interval) {\n        _assertClass(validity_start_interval, BigNum);\n        var ptr0 = validity_start_interval.ptr;\n        validity_start_interval.ptr = 0;\n        wasm.transactionbuilder_set_validity_start_interval_bignum(this.ptr, ptr0);\n    }\n    /**\n    * @param {Certificates} certs\n    */\n    set_certs(certs) {\n        _assertClass(certs, Certificates);\n        wasm.transactionbuilder_set_certs(this.ptr, certs.ptr);\n    }\n    /**\n    * @param {Withdrawals} withdrawals\n    */\n    set_withdrawals(withdrawals) {\n        _assertClass(withdrawals, Withdrawals);\n        wasm.transactionbuilder_set_withdrawals(this.ptr, withdrawals.ptr);\n    }\n    /**\n    * @returns {AuxiliaryData | undefined}\n    */\n    get_auxiliary_data() {\n        var ret = wasm.transactionbuilder_get_auxiliary_data(this.ptr);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * Set explicit auxiliary data via an AuxiliaryData object\n    * It might contain some metadata plus native or Plutus scripts\n    * @param {AuxiliaryData} auxiliary_data\n    */\n    set_auxiliary_data(auxiliary_data) {\n        _assertClass(auxiliary_data, AuxiliaryData);\n        wasm.transactionbuilder_set_auxiliary_data(this.ptr, auxiliary_data.ptr);\n    }\n    /**\n    * Set metadata using a GeneralTransactionMetadata object\n    * It will be set to the existing or new auxiliary data in this builder\n    * @param {GeneralTransactionMetadata} metadata\n    */\n    set_metadata(metadata) {\n        _assertClass(metadata, GeneralTransactionMetadata);\n        wasm.transactionbuilder_set_metadata(this.ptr, metadata.ptr);\n    }\n    /**\n    * Add a single metadatum using TransactionMetadatumLabel and TransactionMetadatum objects\n    * It will be securely added to existing or new metadata in this builder\n    * @param {BigNum} key\n    * @param {TransactionMetadatum} val\n    */\n    add_metadatum(key, val) {\n        _assertClass(key, BigNum);\n        _assertClass(val, TransactionMetadatum);\n        wasm.transactionbuilder_add_metadatum(this.ptr, key.ptr, val.ptr);\n    }\n    /**\n    * Add a single JSON metadatum using a TransactionMetadatumLabel and a String\n    * It will be securely added to existing or new metadata in this builder\n    * @param {BigNum} key\n    * @param {string} val\n    */\n    add_json_metadatum(key, val) {\n        _assertClass(key, BigNum);\n        var ptr0 = passStringToWasm0(val, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.transactionbuilder_add_json_metadatum(this.ptr, key.ptr, ptr0, len0);\n    }\n    /**\n    * Add a single JSON metadatum using a TransactionMetadatumLabel, a String, and a MetadataJsonSchema object\n    * It will be securely added to existing or new metadata in this builder\n    * @param {BigNum} key\n    * @param {string} val\n    * @param {number} schema\n    */\n    add_json_metadatum_with_schema(key, val, schema) {\n        _assertClass(key, BigNum);\n        var ptr0 = passStringToWasm0(val, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.transactionbuilder_add_json_metadatum_with_schema(this.ptr, key.ptr, ptr0, len0, schema);\n    }\n    /**\n    * Set explicit Mint object and the required witnesses to this builder\n    * it will replace any previously existing mint and mint scripts\n    * NOTE! Error will be returned in case a mint policy does not have a matching script\n    * @param {Mint} mint\n    * @param {NativeScripts} mint_scripts\n    */\n    set_mint(mint, mint_scripts) {\n        _assertClass(mint, Mint);\n        _assertClass(mint_scripts, NativeScripts);\n        wasm.transactionbuilder_set_mint(this.ptr, mint.ptr, mint_scripts.ptr);\n    }\n    /**\n    * Returns a copy of the current mint state in the builder\n    * @returns {Mint | undefined}\n    */\n    get_mint() {\n        var ret = wasm.transactionbuilder_get_mint(this.ptr);\n        return ret === 0 ? undefined : Mint.__wrap(ret);\n    }\n    /**\n    * Returns a copy of the current mint witness scripts in the builder\n    * @returns {NativeScripts | undefined}\n    */\n    get_mint_scripts() {\n        var ret = wasm.transactionbuilder_get_mint_scripts(this.ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * Add a mint entry to this builder using a PolicyID and MintAssets object\n    * It will be securely added to existing or new Mint in this builder\n    * It will replace any existing mint assets with the same PolicyID\n    * @param {NativeScript} policy_script\n    * @param {MintAssets} mint_assets\n    */\n    set_mint_asset(policy_script, mint_assets) {\n        _assertClass(policy_script, NativeScript);\n        _assertClass(mint_assets, MintAssets);\n        wasm.transactionbuilder_set_mint_asset(this.ptr, policy_script.ptr, mint_assets.ptr);\n    }\n    /**\n    * Add a mint entry to this builder using a PolicyID, AssetName, and Int object for amount\n    * It will be securely added to existing or new Mint in this builder\n    * It will replace any previous existing amount same PolicyID and AssetName\n    * @param {NativeScript} policy_script\n    * @param {AssetName} asset_name\n    * @param {Int} amount\n    */\n    add_mint_asset(policy_script, asset_name, amount) {\n        _assertClass(policy_script, NativeScript);\n        _assertClass(asset_name, AssetName);\n        _assertClass(amount, Int);\n        var ptr0 = amount.ptr;\n        amount.ptr = 0;\n        wasm.transactionbuilder_add_mint_asset(this.ptr, policy_script.ptr, asset_name.ptr, ptr0);\n    }\n    /**\n    * Add a mint entry together with an output to this builder\n    * Using a PolicyID, AssetName, Int for amount, Address, and Coin (BigNum) objects\n    * The asset will be securely added to existing or new Mint in this builder\n    * A new output will be added with the specified Address, the Coin value, and the minted asset\n    * @param {NativeScript} policy_script\n    * @param {AssetName} asset_name\n    * @param {Int} amount\n    * @param {TransactionOutputAmountBuilder} output_builder\n    * @param {BigNum} output_coin\n    */\n    add_mint_asset_and_output(policy_script, asset_name, amount, output_builder, output_coin) {\n        _assertClass(policy_script, NativeScript);\n        _assertClass(asset_name, AssetName);\n        _assertClass(amount, Int);\n        var ptr0 = amount.ptr;\n        amount.ptr = 0;\n        _assertClass(output_builder, TransactionOutputAmountBuilder);\n        _assertClass(output_coin, BigNum);\n        wasm.transactionbuilder_add_mint_asset_and_output(this.ptr, policy_script.ptr, asset_name.ptr, ptr0, output_builder.ptr, output_coin.ptr);\n    }\n    /**\n    * Add a mint entry together with an output to this builder\n    * Using a PolicyID, AssetName, Int for amount, and Address objects\n    * The asset will be securely added to existing or new Mint in this builder\n    * A new output will be added with the specified Address and the minted asset\n    * The output will be set to contain the minimum required amount of Coin\n    * @param {NativeScript} policy_script\n    * @param {AssetName} asset_name\n    * @param {Int} amount\n    * @param {TransactionOutputAmountBuilder} output_builder\n    */\n    add_mint_asset_and_output_min_required_coin(policy_script, asset_name, amount, output_builder) {\n        _assertClass(policy_script, NativeScript);\n        _assertClass(asset_name, AssetName);\n        _assertClass(amount, Int);\n        var ptr0 = amount.ptr;\n        amount.ptr = 0;\n        _assertClass(output_builder, TransactionOutputAmountBuilder);\n        wasm.transactionbuilder_add_mint_asset_and_output_min_required_coin(this.ptr, policy_script.ptr, asset_name.ptr, ptr0, output_builder.ptr);\n    }\n    /**\n    * @param {TransactionBuilderConfig} cfg\n    * @returns {TransactionBuilder}\n    */\n    static new(cfg) {\n        _assertClass(cfg, TransactionBuilderConfig);\n        var ret = wasm.transactionbuilder_new(cfg.ptr);\n        return TransactionBuilder.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    get_reference_inputs() {\n        var ret = wasm.transactionbuilder_get_reference_inputs(this.ptr);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * does not include refunds or withdrawals\n    * @returns {Value}\n    */\n    get_explicit_input() {\n        var ret = wasm.transactionbuilder_get_explicit_input(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * withdrawals and refunds\n    * @returns {Value}\n    */\n    get_implicit_input() {\n        var ret = wasm.transactionbuilder_get_implicit_input(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * Return explicit input plus implicit input plus mint\n    * @returns {Value}\n    */\n    get_total_input() {\n        var ret = wasm.transactionbuilder_get_total_input(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * Return explicit output plus deposit plus burn\n    * @returns {Value}\n    */\n    get_total_output() {\n        var ret = wasm.transactionbuilder_get_total_output(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * does not include fee\n    * @returns {Value}\n    */\n    get_explicit_output() {\n        var ret = wasm.transactionbuilder_get_explicit_output(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    get_deposit() {\n        var ret = wasm.transactionbuilder_get_deposit(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    get_fee_if_set() {\n        var ret = wasm.transactionbuilder_get_fee_if_set(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * Warning: this function will mutate the /fee/ field\n    * Make sure to call this function last after setting all other tx-body properties\n    * Editing inputs, outputs, mint, etc. after change been calculated\n    * might cause a mismatch in calculated fee versus the required fee\n    * @param {Address} address\n    * @returns {boolean}\n    */\n    add_change_if_needed(address) {\n        _assertClass(address, Address);\n        var ret = wasm.transactionbuilder_add_change_if_needed(this.ptr, address.ptr);\n        return ret !== 0;\n    }\n    /**\n    * This method will calculate the script hash data\n    * using the plutus datums and redeemers already present in the builder\n    * along with the provided cost model, and will register the calculated value\n    * in the builder to be used when building the tx body.\n    * In case there are no plutus input witnesses present - nothing will change\n    * You can set specific hash value using `.set_script_data_hash`\n    * NOTE: this function will check which language versions are used in the present scripts\n    * and will assert and require for a corresponding cost-model to be present in the passed map.\n    * Only the cost-models for the present language versions will be used in the hash calculation.\n    * @param {Costmdls} cost_models\n    */\n    calc_script_data_hash(cost_models) {\n        _assertClass(cost_models, Costmdls);\n        wasm.transactionbuilder_calc_script_data_hash(this.ptr, cost_models.ptr);\n    }\n    /**\n    * Sets the specified hash value.\n    * Alternatively you can use `.calc_script_data_hash` to calculate the hash automatically.\n    * Or use `.remove_script_data_hash` to delete the previously set value\n    * @param {ScriptDataHash} hash\n    */\n    set_script_data_hash(hash) {\n        _assertClass(hash, ScriptDataHash);\n        wasm.transactionbuilder_set_script_data_hash(this.ptr, hash.ptr);\n    }\n    /**\n    * Deletes any previously set plutus data hash value.\n    * Use `.set_script_data_hash` or `.calc_script_data_hash` to set it.\n    */\n    remove_script_data_hash() {\n        wasm.transactionbuilder_remove_script_data_hash(this.ptr);\n    }\n    /**\n    * @param {Ed25519KeyHash} key\n    */\n    add_required_signer(key) {\n        _assertClass(key, Ed25519KeyHash);\n        wasm.transactionbuilder_add_required_signer(this.ptr, key.ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    full_size() {\n        var ret = wasm.transactionbuilder_full_size(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    output_sizes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbuilder_output_sizes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns object the body of the new transaction\n    * Auxiliary data itself is not included\n    * You can use `get_auxiliary_data` or `build_tx`\n    * @returns {TransactionBody}\n    */\n    build() {\n        var ret = wasm.transactionbuilder_build(this.ptr);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * Returns full Transaction object with the body and the auxiliary data\n    * NOTE: witness_set will contain all mint_scripts if any been added or set\n    * NOTE: is_valid set to true\n    * NOTE: Will fail in case there are any script inputs added with no corresponding witness\n    * @returns {Transaction}\n    */\n    build_tx() {\n        var ret = wasm.transactionbuilder_build_tx(this.ptr);\n        return Transaction.__wrap(ret);\n    }\n    /**\n    * Similar to `.build_tx()` but will NOT fail in case there are missing script witnesses\n    * @returns {Transaction}\n    */\n    build_tx_unsafe() {\n        var ret = wasm.transactionbuilder_build_tx_unsafe(this.ptr);\n        return Transaction.__wrap(ret);\n    }\n    /**\n    * warning: sum of all parts of a transaction must equal 0. You cannot just set the fee to the min value and forget about it\n    * warning: min_fee may be slightly larger than the actual minimum fee (ex: a few lovelaces)\n    * this is done to simplify the library code, but can be fixed later\n    * @returns {BigNum}\n    */\n    min_fee() {\n        var ret = wasm.transactionbuilder_min_fee(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionBuilderConfig {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionBuilderConfig.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbuilderconfig_free(ptr);\n    }\n}\n/**\n*/\nexport class TransactionBuilderConfigBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionBuilderConfigBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbuilderconfigbuilder_free(ptr);\n    }\n    /**\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    static new() {\n        var ret = wasm.transactionbuilderconfigbuilder_new();\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {LinearFee} fee_algo\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    fee_algo(fee_algo) {\n        _assertClass(fee_algo, LinearFee);\n        var ret = wasm.transactionbuilderconfigbuilder_fee_algo(this.ptr, fee_algo.ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Since babbage era cardano nodes use coins per byte. Use '.coins_per_utxo_byte' instead.\n    * @param {BigNum} coins_per_utxo_word\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    coins_per_utxo_word(coins_per_utxo_word) {\n        _assertClass(coins_per_utxo_word, BigNum);\n        var ret = wasm.transactionbuilderconfigbuilder_coins_per_utxo_word(this.ptr, coins_per_utxo_word.ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coins_per_utxo_byte\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    coins_per_utxo_byte(coins_per_utxo_byte) {\n        _assertClass(coins_per_utxo_byte, BigNum);\n        var ret = wasm.transactionbuilderconfigbuilder_coins_per_utxo_byte(this.ptr, coins_per_utxo_byte.ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {ExUnitPrices} ex_unit_prices\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    ex_unit_prices(ex_unit_prices) {\n        _assertClass(ex_unit_prices, ExUnitPrices);\n        var ret = wasm.transactionbuilderconfigbuilder_ex_unit_prices(this.ptr, ex_unit_prices.ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} pool_deposit\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    pool_deposit(pool_deposit) {\n        _assertClass(pool_deposit, BigNum);\n        var ret = wasm.transactionbuilderconfigbuilder_pool_deposit(this.ptr, pool_deposit.ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} key_deposit\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    key_deposit(key_deposit) {\n        _assertClass(key_deposit, BigNum);\n        var ret = wasm.transactionbuilderconfigbuilder_key_deposit(this.ptr, key_deposit.ptr);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {number} max_value_size\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    max_value_size(max_value_size) {\n        var ret = wasm.transactionbuilderconfigbuilder_max_value_size(this.ptr, max_value_size);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {number} max_tx_size\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    max_tx_size(max_tx_size) {\n        var ret = wasm.transactionbuilderconfigbuilder_max_tx_size(this.ptr, max_tx_size);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @param {boolean} prefer_pure_change\n    * @returns {TransactionBuilderConfigBuilder}\n    */\n    prefer_pure_change(prefer_pure_change) {\n        var ret = wasm.transactionbuilderconfigbuilder_prefer_pure_change(this.ptr, prefer_pure_change);\n        return TransactionBuilderConfigBuilder.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionBuilderConfig}\n    */\n    build() {\n        var ret = wasm.transactionbuilderconfigbuilder_build(this.ptr);\n        return TransactionBuilderConfig.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionhash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionhash_from_bytes(ptr0, len0);\n        return TransactionHash.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionhash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.transactionhash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {TransactionHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionhash_from_bech32(ptr0, len0);\n        return TransactionHash.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionhash_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {TransactionHash}\n    */\n    static from_hex(hex) {\n        var ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionhash_from_hex(ptr0, len0);\n        return TransactionHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionInput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionInput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactioninput_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninput_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionInput}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactioninput_from_bytes(ptr0, len0);\n        return TransactionInput.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninput_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionInput}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactioninput_from_hex(ptr0, len0);\n        return TransactionInput.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninput_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.transactioninput_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionInput}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactioninput_from_json(ptr0, len0);\n        return TransactionInput.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionHash}\n    */\n    transaction_id() {\n        var ret = wasm.transactioninput_transaction_id(this.ptr);\n        return TransactionHash.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    index() {\n        var ret = wasm.transactioninput_index(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {TransactionHash} transaction_id\n    * @param {number} index\n    * @returns {TransactionInput}\n    */\n    static new(transaction_id, index) {\n        _assertClass(transaction_id, TransactionHash);\n        var ret = wasm.transactioninput_new(transaction_id.ptr, index);\n        return TransactionInput.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionInputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionInputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactioninputs_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninputs_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionInputs}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactioninputs_from_bytes(ptr0, len0);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninputs_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionInputs}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactioninputs_from_hex(ptr0, len0);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninputs_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.transactioninputs_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionInputs}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactioninputs_from_json(ptr0, len0);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    static new() {\n        var ret = wasm.transactioninputs_new();\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.transactioninputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionInput}\n    */\n    get(index) {\n        var ret = wasm.transactioninputs_get(this.ptr, index);\n        return TransactionInput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInput} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionInput);\n        wasm.transactioninputs_add(this.ptr, elem.ptr);\n    }\n    /**\n    * @returns {TransactionInputs | undefined}\n    */\n    to_option() {\n        var ret = wasm.transactioninputs_to_option(this.ptr);\n        return ret === 0 ? undefined : TransactionInputs.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionMetadatum {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionMetadatum.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionmetadatum_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionMetadatum}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionmetadatum_from_bytes(ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionMetadatum}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionmetadatum_from_hex(ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {MetadataMap} map\n    * @returns {TransactionMetadatum}\n    */\n    static new_map(map) {\n        _assertClass(map, MetadataMap);\n        var ret = wasm.transactionmetadatum_new_map(map.ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {MetadataList} list\n    * @returns {TransactionMetadatum}\n    */\n    static new_list(list) {\n        _assertClass(list, MetadataList);\n        var ret = wasm.transactionmetadatum_new_list(list.ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {Int} int\n    * @returns {TransactionMetadatum}\n    */\n    static new_int(int) {\n        _assertClass(int, Int);\n        var ret = wasm.transactionmetadatum_new_int(int.ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionMetadatum}\n    */\n    static new_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionmetadatum_new_bytes(ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {string} text\n    * @returns {TransactionMetadatum}\n    */\n    static new_text(text) {\n        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionmetadatum_new_text(ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.transactionmetadatum_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {MetadataMap}\n    */\n    as_map() {\n        var ret = wasm.transactionmetadatum_as_map(this.ptr);\n        return MetadataMap.__wrap(ret);\n    }\n    /**\n    * @returns {MetadataList}\n    */\n    as_list() {\n        var ret = wasm.transactionmetadatum_as_list(this.ptr);\n        return MetadataList.__wrap(ret);\n    }\n    /**\n    * @returns {Int}\n    */\n    as_int() {\n        var ret = wasm.transactionmetadatum_as_int(this.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    as_text() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_as_text(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nexport class TransactionMetadatumLabels {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionMetadatumLabels.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionmetadatumlabels_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatumlabels_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionMetadatumLabels}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionmetadatumlabels_from_bytes(ptr0, len0);\n        return TransactionMetadatumLabels.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatumlabels_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionMetadatumLabels}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionmetadatumlabels_from_hex(ptr0, len0);\n        return TransactionMetadatumLabels.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionMetadatumLabels}\n    */\n    static new() {\n        var ret = wasm.transactionmetadatumlabels_new();\n        return TransactionMetadatumLabels.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.transactionmetadatumlabels_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {BigNum}\n    */\n    get(index) {\n        var ret = wasm.transactionmetadatumlabels_get(this.ptr, index);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} elem\n    */\n    add(elem) {\n        _assertClass(elem, BigNum);\n        wasm.transactionmetadatumlabels_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class TransactionOutput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionOutput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionoutput_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutput_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionOutput}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionoutput_from_bytes(ptr0, len0);\n        return TransactionOutput.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutput_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionOutput}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionoutput_from_hex(ptr0, len0);\n        return TransactionOutput.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutput_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.transactionoutput_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionOutput}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionoutput_from_json(ptr0, len0);\n        return TransactionOutput.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    address() {\n        var ret = wasm.transactionoutput_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {Value}\n    */\n    amount() {\n        var ret = wasm.transactionoutput_amount(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {DataHash | undefined}\n    */\n    data_hash() {\n        var ret = wasm.transactionoutput_data_hash(this.ptr);\n        return ret === 0 ? undefined : DataHash.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusData | undefined}\n    */\n    plutus_data() {\n        var ret = wasm.transactionoutput_plutus_data(this.ptr);\n        return ret === 0 ? undefined : PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptRef | undefined}\n    */\n    script_ref() {\n        var ret = wasm.transactionoutput_script_ref(this.ptr);\n        return ret === 0 ? undefined : ScriptRef.__wrap(ret);\n    }\n    /**\n    * @param {ScriptRef} script_ref\n    */\n    set_script_ref(script_ref) {\n        _assertClass(script_ref, ScriptRef);\n        wasm.transactionoutput_set_script_ref(this.ptr, script_ref.ptr);\n    }\n    /**\n    * @param {PlutusData} data\n    */\n    set_plutus_data(data) {\n        _assertClass(data, PlutusData);\n        wasm.transactionoutput_set_plutus_data(this.ptr, data.ptr);\n    }\n    /**\n    * @param {DataHash} data_hash\n    */\n    set_data_hash(data_hash) {\n        _assertClass(data_hash, DataHash);\n        wasm.transactionoutput_set_data_hash(this.ptr, data_hash.ptr);\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_plutus_data() {\n        var ret = wasm.transactionoutput_has_plutus_data(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_data_hash() {\n        var ret = wasm.transactionoutput_has_data_hash(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    has_script_ref() {\n        var ret = wasm.transactionoutput_has_script_ref(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {Address} address\n    * @param {Value} amount\n    * @returns {TransactionOutput}\n    */\n    static new(address, amount) {\n        _assertClass(address, Address);\n        _assertClass(amount, Value);\n        var ret = wasm.transactionoutput_new(address.ptr, amount.ptr);\n        return TransactionOutput.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionOutputAmountBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionOutputAmountBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionoutputamountbuilder_free(ptr);\n    }\n    /**\n    * @param {Value} amount\n    * @returns {TransactionOutputAmountBuilder}\n    */\n    with_value(amount) {\n        _assertClass(amount, Value);\n        var ret = wasm.transactionoutputamountbuilder_with_value(this.ptr, amount.ptr);\n        return TransactionOutputAmountBuilder.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coin\n    * @returns {TransactionOutputAmountBuilder}\n    */\n    with_coin(coin) {\n        _assertClass(coin, BigNum);\n        var ret = wasm.transactionoutputamountbuilder_with_coin(this.ptr, coin.ptr);\n        return TransactionOutputAmountBuilder.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coin\n    * @param {MultiAsset} multiasset\n    * @returns {TransactionOutputAmountBuilder}\n    */\n    with_coin_and_asset(coin, multiasset) {\n        _assertClass(coin, BigNum);\n        _assertClass(multiasset, MultiAsset);\n        var ret = wasm.transactionoutputamountbuilder_with_coin_and_asset(this.ptr, coin.ptr, multiasset.ptr);\n        return TransactionOutputAmountBuilder.__wrap(ret);\n    }\n    /**\n    * !!! DEPRECATED !!!\n    * Since babbage era cardano nodes use coins per byte. Use '.with_asset_and_min_required_coin_by_utxo_cost' instead.\n    * @param {MultiAsset} multiasset\n    * @param {BigNum} coins_per_utxo_word\n    * @returns {TransactionOutputAmountBuilder}\n    */\n    with_asset_and_min_required_coin(multiasset, coins_per_utxo_word) {\n        _assertClass(multiasset, MultiAsset);\n        _assertClass(coins_per_utxo_word, BigNum);\n        var ret = wasm.transactionoutputamountbuilder_with_asset_and_min_required_coin(this.ptr, multiasset.ptr, coins_per_utxo_word.ptr);\n        return TransactionOutputAmountBuilder.__wrap(ret);\n    }\n    /**\n    * @param {MultiAsset} multiasset\n    * @param {DataCost} data_cost\n    * @returns {TransactionOutputAmountBuilder}\n    */\n    with_asset_and_min_required_coin_by_utxo_cost(multiasset, data_cost) {\n        _assertClass(multiasset, MultiAsset);\n        _assertClass(data_cost, DataCost);\n        var ret = wasm.transactionoutputamountbuilder_with_asset_and_min_required_coin_by_utxo_cost(this.ptr, multiasset.ptr, data_cost.ptr);\n        return TransactionOutputAmountBuilder.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutput}\n    */\n    build() {\n        var ret = wasm.transactionoutputamountbuilder_build(this.ptr);\n        return TransactionOutput.__wrap(ret);\n    }\n}\n/**\n* We introduce a builder-pattern format for creating transaction outputs\n* This is because:\n* 1. Some fields (i.e. data hash) are optional, and we can't easily expose Option<> in WASM\n* 2. Some fields like amounts have many ways it could be set (some depending on other field values being known)\n* 3. Easier to adapt as the output format gets more complicated in future Cardano releases\n*/\nexport class TransactionOutputBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionOutputBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionoutputbuilder_free(ptr);\n    }\n    /**\n    * @returns {TransactionOutputBuilder}\n    */\n    static new() {\n        var ret = wasm.transactionoutputbuilder_new();\n        return TransactionOutputBuilder.__wrap(ret);\n    }\n    /**\n    * @param {Address} address\n    * @returns {TransactionOutputBuilder}\n    */\n    with_address(address) {\n        _assertClass(address, Address);\n        var ret = wasm.transactionoutputbuilder_with_address(this.ptr, address.ptr);\n        return TransactionOutputBuilder.__wrap(ret);\n    }\n    /**\n    * @param {DataHash} data_hash\n    * @returns {TransactionOutputBuilder}\n    */\n    with_data_hash(data_hash) {\n        _assertClass(data_hash, DataHash);\n        var ret = wasm.transactionoutputbuilder_with_data_hash(this.ptr, data_hash.ptr);\n        return TransactionOutputBuilder.__wrap(ret);\n    }\n    /**\n    * @param {PlutusData} data\n    * @returns {TransactionOutputBuilder}\n    */\n    with_plutus_data(data) {\n        _assertClass(data, PlutusData);\n        var ret = wasm.transactionoutputbuilder_with_plutus_data(this.ptr, data.ptr);\n        return TransactionOutputBuilder.__wrap(ret);\n    }\n    /**\n    * @param {ScriptRef} script_ref\n    * @returns {TransactionOutputBuilder}\n    */\n    with_script_ref(script_ref) {\n        _assertClass(script_ref, ScriptRef);\n        var ret = wasm.transactionoutputbuilder_with_script_ref(this.ptr, script_ref.ptr);\n        return TransactionOutputBuilder.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutputAmountBuilder}\n    */\n    next() {\n        var ret = wasm.transactionoutputbuilder_next(this.ptr);\n        return TransactionOutputAmountBuilder.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionOutputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionOutputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionoutputs_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutputs_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionOutputs}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionoutputs_from_bytes(ptr0, len0);\n        return TransactionOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutputs_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionOutputs}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionoutputs_from_hex(ptr0, len0);\n        return TransactionOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutputs_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.transactionoutputs_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionOutputs}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionoutputs_from_json(ptr0, len0);\n        return TransactionOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutputs}\n    */\n    static new() {\n        var ret = wasm.transactionoutputs_new();\n        return TransactionOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.transactionoutputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionOutput}\n    */\n    get(index) {\n        var ret = wasm.transactionoutputs_get(this.ptr, index);\n        return TransactionOutput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionOutput} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionOutput);\n        wasm.transactionoutputs_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class TransactionUnspentOutput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionUnspentOutput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionunspentoutput_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionunspentoutput_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionUnspentOutput}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionunspentoutput_from_bytes(ptr0, len0);\n        return TransactionUnspentOutput.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionunspentoutput_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionUnspentOutput}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionunspentoutput_from_hex(ptr0, len0);\n        return TransactionUnspentOutput.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionunspentoutput_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.transactionunspentoutput_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionUnspentOutput}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionunspentoutput_from_json(ptr0, len0);\n        return TransactionUnspentOutput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInput} input\n    * @param {TransactionOutput} output\n    * @returns {TransactionUnspentOutput}\n    */\n    static new(input, output) {\n        _assertClass(input, TransactionInput);\n        _assertClass(output, TransactionOutput);\n        var ret = wasm.transactionunspentoutput_new(input.ptr, output.ptr);\n        return TransactionUnspentOutput.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInput}\n    */\n    input() {\n        var ret = wasm.transactionunspentoutput_input(this.ptr);\n        return TransactionInput.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutput}\n    */\n    output() {\n        var ret = wasm.transactionunspentoutput_output(this.ptr);\n        return TransactionOutput.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionUnspentOutputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionUnspentOutputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionunspentoutputs_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionunspentoutputs_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.transactionunspentoutputs_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionUnspentOutputs}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionunspentoutputs_from_json(ptr0, len0);\n        return TransactionUnspentOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionUnspentOutputs}\n    */\n    static new() {\n        var ret = wasm.transactionunspentoutputs_new();\n        return TransactionUnspentOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.transactionunspentoutputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionUnspentOutput}\n    */\n    get(index) {\n        var ret = wasm.transactionunspentoutputs_get(this.ptr, index);\n        return TransactionUnspentOutput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionUnspentOutput} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionUnspentOutput);\n        wasm.transactionunspentoutputs_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class TransactionWitnessSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionWitnessSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionwitnessset_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnessset_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionWitnessSet}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionwitnessset_from_bytes(ptr0, len0);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnessset_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionWitnessSet}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionwitnessset_from_hex(ptr0, len0);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnessset_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.transactionwitnessset_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionWitnessSet}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionwitnessset_from_json(ptr0, len0);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @param {Vkeywitnesses} vkeys\n    */\n    set_vkeys(vkeys) {\n        _assertClass(vkeys, Vkeywitnesses);\n        wasm.transactionwitnessset_set_vkeys(this.ptr, vkeys.ptr);\n    }\n    /**\n    * @returns {Vkeywitnesses | undefined}\n    */\n    vkeys() {\n        var ret = wasm.transactionwitnessset_vkeys(this.ptr);\n        return ret === 0 ? undefined : Vkeywitnesses.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    */\n    set_native_scripts(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        wasm.transactionwitnessset_set_native_scripts(this.ptr, native_scripts.ptr);\n    }\n    /**\n    * @returns {NativeScripts | undefined}\n    */\n    native_scripts() {\n        var ret = wasm.transactionwitnessset_native_scripts(this.ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {BootstrapWitnesses} bootstraps\n    */\n    set_bootstraps(bootstraps) {\n        _assertClass(bootstraps, BootstrapWitnesses);\n        wasm.transactionwitnessset_set_bootstraps(this.ptr, bootstraps.ptr);\n    }\n    /**\n    * @returns {BootstrapWitnesses | undefined}\n    */\n    bootstraps() {\n        var ret = wasm.transactionwitnessset_bootstraps(this.ptr);\n        return ret === 0 ? undefined : BootstrapWitnesses.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScripts} plutus_scripts\n    */\n    set_plutus_scripts(plutus_scripts) {\n        _assertClass(plutus_scripts, PlutusScripts);\n        wasm.transactionwitnessset_set_plutus_scripts(this.ptr, plutus_scripts.ptr);\n    }\n    /**\n    * @returns {PlutusScripts | undefined}\n    */\n    plutus_scripts() {\n        var ret = wasm.transactionwitnessset_plutus_scripts(this.ptr);\n        return ret === 0 ? undefined : PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @param {PlutusList} plutus_data\n    */\n    set_plutus_data(plutus_data) {\n        _assertClass(plutus_data, PlutusList);\n        wasm.transactionwitnessset_set_plutus_data(this.ptr, plutus_data.ptr);\n    }\n    /**\n    * @returns {PlutusList | undefined}\n    */\n    plutus_data() {\n        var ret = wasm.transactionwitnessset_plutus_data(this.ptr);\n        return ret === 0 ? undefined : PlutusList.__wrap(ret);\n    }\n    /**\n    * @param {Redeemers} redeemers\n    */\n    set_redeemers(redeemers) {\n        _assertClass(redeemers, Redeemers);\n        wasm.transactionwitnessset_set_redeemers(this.ptr, redeemers.ptr);\n    }\n    /**\n    * @returns {Redeemers | undefined}\n    */\n    redeemers() {\n        var ret = wasm.transactionwitnessset_redeemers(this.ptr);\n        return ret === 0 ? undefined : Redeemers.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSet}\n    */\n    static new() {\n        var ret = wasm.transactionwitnessset_new();\n        return TransactionWitnessSet.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionWitnessSets {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionWitnessSets.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionwitnesssets_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnesssets_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionWitnessSets}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionwitnesssets_from_bytes(ptr0, len0);\n        return TransactionWitnessSets.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnesssets_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {TransactionWitnessSets}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionwitnesssets_from_hex(ptr0, len0);\n        return TransactionWitnessSets.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnesssets_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.transactionwitnesssets_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {TransactionWitnessSets}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionwitnesssets_from_json(ptr0, len0);\n        return TransactionWitnessSets.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSets}\n    */\n    static new() {\n        var ret = wasm.transactionwitnesssets_new();\n        return TransactionWitnessSets.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.transactionwitnesssets_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionWitnessSet}\n    */\n    get(index) {\n        var ret = wasm.transactionwitnesssets_get(this.ptr, index);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @param {TransactionWitnessSet} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionWitnessSet);\n        wasm.transactionwitnesssets_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class TxBuilderConstants {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_txbuilderconstants_free(ptr);\n    }\n    /**\n    * @returns {Costmdls}\n    */\n    static plutus_default_cost_models() {\n        var ret = wasm.txbuilderconstants_plutus_default_cost_models();\n        return Costmdls.__wrap(ret);\n    }\n    /**\n    * @returns {Costmdls}\n    */\n    static plutus_alonzo_cost_models() {\n        var ret = wasm.txbuilderconstants_plutus_alonzo_cost_models();\n        return Costmdls.__wrap(ret);\n    }\n    /**\n    * @returns {Costmdls}\n    */\n    static plutus_vasil_cost_models() {\n        var ret = wasm.txbuilderconstants_plutus_vasil_cost_models();\n        return Costmdls.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TxInputsBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TxInputsBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_txinputsbuilder_free(ptr);\n    }\n    /**\n    * @returns {TxInputsBuilder}\n    */\n    static new() {\n        var ret = wasm.txinputsbuilder_new();\n        return TxInputsBuilder.__wrap(ret);\n    }\n    /**\n    * We have to know what kind of inputs these are to know what kind of mock witnesses to create since\n    * 1) mock witnesses have different lengths depending on the type which changes the expecting fee\n    * 2) Witnesses are a set so we need to get rid of duplicates to avoid over-estimating the fee\n    * @param {Ed25519KeyHash} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_key_input(hash, input, amount) {\n        _assertClass(hash, Ed25519KeyHash);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.txinputsbuilder_add_key_input(this.ptr, hash.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * This method adds the input to the builder BUT leaves a missing spot for the witness native script\n    *\n    * After adding the input with this method, use `.add_required_native_input_scripts`\n    * and `.add_required_plutus_input_scripts` to add the witness scripts\n    *\n    * Or instead use `.add_native_script_input` and `.add_plutus_script_input`\n    * to add inputs right along with the script, instead of the script hash\n    * @param {ScriptHash} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_script_input(hash, input, amount) {\n        _assertClass(hash, ScriptHash);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.txinputsbuilder_add_script_input(this.ptr, hash.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * This method will add the input to the builder and also register the required native script witness\n    * @param {NativeScript} script\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_native_script_input(script, input, amount) {\n        _assertClass(script, NativeScript);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.txinputsbuilder_add_native_script_input(this.ptr, script.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * This method will add the input to the builder and also register the required plutus witness\n    * @param {PlutusWitness} witness\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_plutus_script_input(witness, input, amount) {\n        _assertClass(witness, PlutusWitness);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.txinputsbuilder_add_plutus_script_input(this.ptr, witness.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * @param {ByronAddress} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_bootstrap_input(hash, input, amount) {\n        _assertClass(hash, ByronAddress);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.txinputsbuilder_add_bootstrap_input(this.ptr, hash.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * Note that for script inputs this method will use underlying generic `.add_script_input`\n    * which leaves a required empty spot for the script witness (or witnesses in case of Plutus).\n    * You can use `.add_native_script_input` or `.add_plutus_script_input` directly to register the input along with the witness.\n    * @param {Address} address\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_input(address, input, amount) {\n        _assertClass(address, Address);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.txinputsbuilder_add_input(this.ptr, address.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * Returns the number of still missing input scripts (either native or plutus)\n    * Use `.add_required_native_input_scripts` or `.add_required_plutus_input_scripts` to add the missing scripts\n    * @returns {number}\n    */\n    count_missing_input_scripts() {\n        var ret = wasm.txinputsbuilder_count_missing_input_scripts(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Try adding the specified scripts as witnesses for ALREADY ADDED script inputs\n    * Any scripts that don't match any of the previously added inputs will be ignored\n    * Returns the number of remaining required missing witness scripts\n    * Use `.count_missing_input_scripts` to find the number of still missing scripts\n    * @param {NativeScripts} scripts\n    * @returns {number}\n    */\n    add_required_native_input_scripts(scripts) {\n        _assertClass(scripts, NativeScripts);\n        var ret = wasm.txinputsbuilder_add_required_native_input_scripts(this.ptr, scripts.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Try adding the specified scripts as witnesses for ALREADY ADDED script inputs\n    * Any scripts that don't match any of the previously added inputs will be ignored\n    * Returns the number of remaining required missing witness scripts\n    * Use `.count_missing_input_scripts` to find the number of still missing scripts\n    * @param {PlutusWitnesses} scripts\n    * @returns {number}\n    */\n    add_required_plutus_input_scripts(scripts) {\n        _assertClass(scripts, PlutusWitnesses);\n        var ret = wasm.txinputsbuilder_add_required_plutus_input_scripts(this.ptr, scripts.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    get_ref_inputs() {\n        var ret = wasm.txinputsbuilder_get_ref_inputs(this.ptr);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * Returns a copy of the current script input witness scripts in the builder\n    * @returns {NativeScripts | undefined}\n    */\n    get_native_input_scripts() {\n        var ret = wasm.txinputsbuilder_get_native_input_scripts(this.ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * Returns a copy of the current plutus input witness scripts in the builder.\n    * NOTE: each plutus witness will be cloned with a specific corresponding input index\n    * @returns {PlutusWitnesses | undefined}\n    */\n    get_plutus_input_scripts() {\n        var ret = wasm.txinputsbuilder_get_plutus_input_scripts(this.ptr);\n        return ret === 0 ? undefined : PlutusWitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.txinputsbuilder_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {Ed25519KeyHash} key\n    */\n    add_required_signer(key) {\n        _assertClass(key, Ed25519KeyHash);\n        wasm.txinputsbuilder_add_required_signer(this.ptr, key.ptr);\n    }\n    /**\n    * @param {Ed25519KeyHashes} keys\n    */\n    add_required_signers(keys) {\n        _assertClass(keys, Ed25519KeyHashes);\n        wasm.txinputsbuilder_add_required_signers(this.ptr, keys.ptr);\n    }\n    /**\n    * @returns {Value}\n    */\n    total_value() {\n        var ret = wasm.txinputsbuilder_total_value(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    inputs() {\n        var ret = wasm.txinputsbuilder_inputs(this.ptr);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs | undefined}\n    */\n    inputs_option() {\n        var ret = wasm.txinputsbuilder_inputs_option(this.ptr);\n        return ret === 0 ? undefined : TransactionInputs.__wrap(ret);\n    }\n}\n/**\n*/\nexport class URL {\n\n    static __wrap(ptr) {\n        const obj = Object.create(URL.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_url_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.url_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {URL}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.url_from_bytes(ptr0, len0);\n        return URL.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.url_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {URL}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.url_from_hex(ptr0, len0);\n        return URL.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.url_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.url_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {URL}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.url_from_json(ptr0, len0);\n        return URL.__wrap(ret);\n    }\n    /**\n    * @param {string} url\n    * @returns {URL}\n    */\n    static new(url) {\n        var ptr0 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.url_new(ptr0, len0);\n        return URL.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    url() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.url_url(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nexport class UnitInterval {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnitInterval.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unitinterval_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unitinterval_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {UnitInterval}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.unitinterval_from_bytes(ptr0, len0);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unitinterval_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {UnitInterval}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.unitinterval_from_hex(ptr0, len0);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unitinterval_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.unitinterval_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {UnitInterval}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.unitinterval_from_json(ptr0, len0);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    numerator() {\n        var ret = wasm.unitinterval_numerator(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    denominator() {\n        var ret = wasm.unitinterval_denominator(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} numerator\n    * @param {BigNum} denominator\n    * @returns {UnitInterval}\n    */\n    static new(numerator, denominator) {\n        _assertClass(numerator, BigNum);\n        _assertClass(denominator, BigNum);\n        var ret = wasm.unitinterval_new(numerator.ptr, denominator.ptr);\n        return UnitInterval.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Update {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Update.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_update_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.update_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Update}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.update_from_bytes(ptr0, len0);\n        return Update.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.update_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Update}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.update_from_hex(ptr0, len0);\n        return Update.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.update_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.update_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Update}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.update_from_json(ptr0, len0);\n        return Update.__wrap(ret);\n    }\n    /**\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    proposed_protocol_parameter_updates() {\n        var ret = wasm.update_proposed_protocol_parameter_updates(this.ptr);\n        return ProposedProtocolParameterUpdates.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    epoch() {\n        var ret = wasm.update_epoch(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {ProposedProtocolParameterUpdates} proposed_protocol_parameter_updates\n    * @param {number} epoch\n    * @returns {Update}\n    */\n    static new(proposed_protocol_parameter_updates, epoch) {\n        _assertClass(proposed_protocol_parameter_updates, ProposedProtocolParameterUpdates);\n        var ret = wasm.update_new(proposed_protocol_parameter_updates.ptr, epoch);\n        return Update.__wrap(ret);\n    }\n}\n/**\n*/\nexport class VRFCert {\n\n    static __wrap(ptr) {\n        const obj = Object.create(VRFCert.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vrfcert_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfcert_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VRFCert}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfcert_from_bytes(ptr0, len0);\n        return VRFCert.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfcert_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {VRFCert}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfcert_from_hex(ptr0, len0);\n        return VRFCert.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfcert_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.vrfcert_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {VRFCert}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfcert_from_json(ptr0, len0);\n        return VRFCert.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    output() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfcert_output(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    proof() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfcert_proof(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} output\n    * @param {Uint8Array} proof\n    * @returns {VRFCert}\n    */\n    static new(output, proof) {\n        var ptr0 = passArray8ToWasm0(output, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(proof, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfcert_new(ptr0, len0, ptr1, len1);\n        return VRFCert.__wrap(ret);\n    }\n}\n/**\n*/\nexport class VRFKeyHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(VRFKeyHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vrfkeyhash_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VRFKeyHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfkeyhash_from_bytes(ptr0, len0);\n        return VRFKeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfkeyhash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.vrfkeyhash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {VRFKeyHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfkeyhash_from_bech32(ptr0, len0);\n        return VRFKeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfkeyhash_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {VRFKeyHash}\n    */\n    static from_hex(hex) {\n        var ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfkeyhash_from_hex(ptr0, len0);\n        return VRFKeyHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class VRFVKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(VRFVKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vrfvkey_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VRFVKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfvkey_from_bytes(ptr0, len0);\n        return VRFVKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfvkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.vrfvkey_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {VRFVKey}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfvkey_from_bech32(ptr0, len0);\n        return VRFVKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfvkey_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex\n    * @returns {VRFVKey}\n    */\n    static from_hex(hex) {\n        var ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfvkey_from_hex(ptr0, len0);\n        return VRFVKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Value {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Value.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_value_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.value_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Value}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.value_from_bytes(ptr0, len0);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.value_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Value}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.value_from_hex(ptr0, len0);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.value_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.value_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Value}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.value_from_json(ptr0, len0);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coin\n    * @returns {Value}\n    */\n    static new(coin) {\n        _assertClass(coin, BigNum);\n        var ret = wasm.value_new(coin.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {MultiAsset} multiasset\n    * @returns {Value}\n    */\n    static new_from_assets(multiasset) {\n        _assertClass(multiasset, MultiAsset);\n        var ret = wasm.value_new_from_assets(multiasset.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coin\n    * @param {MultiAsset} multiasset\n    * @returns {Value}\n    */\n    static new_with_assets(coin, multiasset) {\n        _assertClass(coin, BigNum);\n        _assertClass(multiasset, MultiAsset);\n        var ret = wasm.value_new_with_assets(coin.ptr, multiasset.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {Value}\n    */\n    static zero() {\n        var ret = wasm.value_zero();\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_zero() {\n        var ret = wasm.value_is_zero(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coin() {\n        var ret = wasm.value_coin(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coin\n    */\n    set_coin(coin) {\n        _assertClass(coin, BigNum);\n        wasm.value_set_coin(this.ptr, coin.ptr);\n    }\n    /**\n    * @returns {MultiAsset | undefined}\n    */\n    multiasset() {\n        var ret = wasm.value_multiasset(this.ptr);\n        return ret === 0 ? undefined : MultiAsset.__wrap(ret);\n    }\n    /**\n    * @param {MultiAsset} multiasset\n    */\n    set_multiasset(multiasset) {\n        _assertClass(multiasset, MultiAsset);\n        wasm.value_set_multiasset(this.ptr, multiasset.ptr);\n    }\n    /**\n    * @param {Value} rhs\n    * @returns {Value}\n    */\n    checked_add(rhs) {\n        _assertClass(rhs, Value);\n        var ret = wasm.value_checked_add(this.ptr, rhs.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {Value} rhs_value\n    * @returns {Value}\n    */\n    checked_sub(rhs_value) {\n        _assertClass(rhs_value, Value);\n        var ret = wasm.value_checked_sub(this.ptr, rhs_value.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {Value} rhs_value\n    * @returns {Value}\n    */\n    clamped_sub(rhs_value) {\n        _assertClass(rhs_value, Value);\n        var ret = wasm.value_clamped_sub(this.ptr, rhs_value.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * note: values are only partially comparable\n    * @param {Value} rhs_value\n    * @returns {number | undefined}\n    */\n    compare(rhs_value) {\n        _assertClass(rhs_value, Value);\n        var ret = wasm.value_compare(this.ptr, rhs_value.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n}\n/**\n*/\nexport class Vkey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Vkey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vkey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Vkey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vkey_from_bytes(ptr0, len0);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkey_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Vkey}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vkey_from_hex(ptr0, len0);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkey_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.vkey_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Vkey}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vkey_from_json(ptr0, len0);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @param {PublicKey} pk\n    * @returns {Vkey}\n    */\n    static new(pk) {\n        _assertClass(pk, PublicKey);\n        var ret = wasm.vkey_new(pk.ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {PublicKey}\n    */\n    public_key() {\n        var ret = wasm.vkey_public_key(this.ptr);\n        return PublicKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Vkeys {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Vkeys.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vkeys_free(ptr);\n    }\n    /**\n    * @returns {Vkeys}\n    */\n    static new() {\n        var ret = wasm.vkeys_new();\n        return Vkeys.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.vkeys_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Vkey}\n    */\n    get(index) {\n        var ret = wasm.vkeys_get(this.ptr, index);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @param {Vkey} elem\n    */\n    add(elem) {\n        _assertClass(elem, Vkey);\n        wasm.vkeys_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class Vkeywitness {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Vkeywitness.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vkeywitness_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkeywitness_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Vkeywitness}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vkeywitness_from_bytes(ptr0, len0);\n        return Vkeywitness.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkeywitness_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Vkeywitness}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vkeywitness_from_hex(ptr0, len0);\n        return Vkeywitness.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkeywitness_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.vkeywitness_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Vkeywitness}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vkeywitness_from_json(ptr0, len0);\n        return Vkeywitness.__wrap(ret);\n    }\n    /**\n    * @param {Vkey} vkey\n    * @param {Ed25519Signature} signature\n    * @returns {Vkeywitness}\n    */\n    static new(vkey, signature) {\n        _assertClass(vkey, Vkey);\n        _assertClass(signature, Ed25519Signature);\n        var ret = wasm.vkeywitness_new(vkey.ptr, signature.ptr);\n        return Vkeywitness.__wrap(ret);\n    }\n    /**\n    * @returns {Vkey}\n    */\n    vkey() {\n        var ret = wasm.vkeywitness_vkey(this.ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519Signature}\n    */\n    signature() {\n        var ret = wasm.vkeywitness_signature(this.ptr);\n        return Ed25519Signature.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Vkeywitnesses {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Vkeywitnesses.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vkeywitnesses_free(ptr);\n    }\n    /**\n    * @returns {Vkeywitnesses}\n    */\n    static new() {\n        var ret = wasm.vkeywitnesses_new();\n        return Vkeywitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.vkeywitnesses_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Vkeywitness}\n    */\n    get(index) {\n        var ret = wasm.vkeywitnesses_get(this.ptr, index);\n        return Vkeywitness.__wrap(ret);\n    }\n    /**\n    * @param {Vkeywitness} elem\n    */\n    add(elem) {\n        _assertClass(elem, Vkeywitness);\n        wasm.vkeywitnesses_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class Withdrawals {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Withdrawals.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_withdrawals_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.withdrawals_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Withdrawals}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.withdrawals_from_bytes(ptr0, len0);\n        return Withdrawals.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.withdrawals_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} hex_str\n    * @returns {Withdrawals}\n    */\n    static from_hex(hex_str) {\n        var ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.withdrawals_from_hex(ptr0, len0);\n        return Withdrawals.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.withdrawals_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    to_js_value() {\n        var ret = wasm.withdrawals_to_js_value(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string} json\n    * @returns {Withdrawals}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.withdrawals_from_json(ptr0, len0);\n        return Withdrawals.__wrap(ret);\n    }\n    /**\n    * @returns {Withdrawals}\n    */\n    static new() {\n        var ret = wasm.withdrawals_new();\n        return Withdrawals.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.withdrawals_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {RewardAddress} key\n    * @param {BigNum} value\n    * @returns {BigNum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, RewardAddress);\n        _assertClass(value, BigNum);\n        var ret = wasm.withdrawals_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {RewardAddress} key\n    * @returns {BigNum | undefined}\n    */\n    get(key) {\n        _assertClass(key, RewardAddress);\n        var ret = wasm.withdrawals_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {RewardAddresses}\n    */\n    keys() {\n        var ret = wasm.withdrawals_keys(this.ptr);\n        return RewardAddresses.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_string_new(arg0, arg1) {\n    var ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_string_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = typeof(obj) === 'string' ? obj : undefined;\n    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_number_new(arg0) {\n    var ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_object_clone_ref(arg0) {\n    var ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_object(arg0) {\n    const val = getObject(arg0);\n    var ret = typeof(val) === 'object' && val !== null;\n    return ret;\n};\n\nexport function __wbindgen_is_undefined(arg0) {\n    var ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nexport function __wbg_String_7462bcc0fcdbaf7d(arg0, arg1) {\n    var ret = String(getObject(arg1));\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbg_set_e93b31d47b90bff6(arg0, arg1, arg2) {\n    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n};\n\nexport function __wbg_process_2f24d6544ea7b200(arg0) {\n    var ret = getObject(arg0).process;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_versions_6164651e75405d4a(arg0) {\n    var ret = getObject(arg0).versions;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_node_4b517d861cbcb3bc(arg0) {\n    var ret = getObject(arg0).node;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_string(arg0) {\n    var ret = typeof(getObject(arg0)) === 'string';\n    return ret;\n};\n\nexport function __wbg_modulerequire_3440a4bcf44437db() { return handleError(function (arg0, arg1) {\n    var ret = module.require(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_crypto_98fc271021c7d2ad(arg0) {\n    var ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_msCrypto_a2cdb043d2bfe57f(arg0) {\n    var ret = getObject(arg0).msCrypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_getRandomValues_98117e9a7e993920() { return handleError(function (arg0, arg1) {\n    getObject(arg0).getRandomValues(getObject(arg1));\n}, arguments) };\n\nexport function __wbg_randomFillSync_64cc7d048f228ca8() { return handleError(function (arg0, arg1, arg2) {\n    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n}, arguments) };\n\nexport function __wbg_new_949bbc1147195c4e() {\n    var ret = new Array();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newnoargs_be86524d73f67598(arg0, arg1) {\n    var ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_ac32179a660db4bb() {\n    var ret = new Map();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_888d259a5fefc347() { return handleError(function (arg0, arg1) {\n    var ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_new_0b83d3df67ecb33e() {\n    var ret = new Object();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_self_c6fbdfc2918d5e58() { return handleError(function () {\n    var ret = self.self;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_window_baec038b5ab35c54() { return handleError(function () {\n    var ret = window.window;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_globalThis_3f735a5746d41fbd() { return handleError(function () {\n    var ret = globalThis.globalThis;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_global_1bc0b39582740e95() { return handleError(function () {\n    var ret = global.global;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_set_1820441f7fb79aad(arg0, arg1, arg2) {\n    getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n};\n\nexport function __wbg_new_342a24ca698edd87(arg0, arg1) {\n    var ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_a46091b120cc63e9(arg0, arg1, arg2) {\n    var ret = getObject(arg0).set(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_buffer_397eaa4d72ee94dd(arg0) {\n    var ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_a7ce447f15ff496f(arg0) {\n    var ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_969ad0a60e51d320(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_1eb8fc608a0d4cdb(arg0) {\n    var ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithlength_929232475839a482(arg0) {\n    var ret = new Uint8Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_subarray_8b658422a224f479(arg0, arg1, arg2) {\n    var ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_3a746f2619705add(arg0, arg1) {\n    var ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_f54d3a6dadb199ca(arg0, arg1) {\n    var ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_jsval_eq(arg0, arg1) {\n    var ret = getObject(arg0) === getObject(arg1);\n    return ret;\n};\n\nexport function __wbg_self_ac379e780a0d8b94(arg0) {\n    var ret = getObject(arg0).self;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_crypto_1e4302b85d4f64a2(arg0) {\n    var ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_getRandomValues_1b4ba144162a5c9e(arg0) {\n    var ret = getObject(arg0).getRandomValues;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_require_6461b1e9a0d7c34a(arg0, arg1) {\n    var ret = require(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_randomFillSync_1b52c8482374c55b(arg0, arg1, arg2) {\n    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n};\n\nexport function __wbg_getRandomValues_1ef11e888e5228e9(arg0, arg1, arg2) {\n    getObject(arg0).getRandomValues(getArrayU8FromWasm0(arg1, arg2));\n};\n\nexport function __wbindgen_debug_string(arg0, arg1) {\n    var ret = debugString(getObject(arg1));\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_rethrow(arg0) {\n    throw takeObject(arg0);\n};\n\nexport function __wbindgen_memory() {\n    var ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n","import * as CardanoWasm from '@emurgo/cardano-serialization-lib-asmjs';\nexport const CertificateType = {\n    STAKE_REGISTRATION: 0,\n    STAKE_DEREGISTRATION: 1,\n    STAKE_DELEGATION: 2,\n    STAKE_POOL_REGISTRATION: 3,\n};\nexport const ERROR = {\n    UTXO_BALANCE_INSUFFICIENT: {\n        code: 'UTXO_BALANCE_INSUFFICIENT',\n        message: 'UTxO balance insufficient',\n    },\n    UTXO_VALUE_TOO_SMALL: {\n        code: 'UTXO_VALUE_TOO_SMALL',\n        message: 'UTxO value too small',\n    },\n    UNSUPPORTED_CERTIFICATE_TYPE: {\n        code: 'UNSUPPORTED_CERTIFICATE_TYPE',\n        message: 'Unsupported certificate type',\n    },\n    UTXO_NOT_FRAGMENTED_ENOUGH: {\n        code: 'UTXO_NOT_FRAGMENTED_ENOUGH',\n        message: 'UTxO Not fragmented enough.',\n    },\n};\nexport const CARDANO_PARAMS = {\n    PROTOCOL_MAGICS: {\n        mainnet: CardanoWasm.NetworkInfo.mainnet().protocol_magic(),\n        testnet: CardanoWasm.NetworkInfo.testnet().protocol_magic(),\n    },\n    NETWORK_IDS: {\n        mainnet: CardanoWasm.NetworkInfo.mainnet().network_id(),\n        testnet: CardanoWasm.NetworkInfo.testnet().network_id(),\n    },\n    COINS_PER_UTXO_BYTE: '4310',\n    MAX_TX_SIZE: 16384,\n    MAX_VALUE_SIZE: 5000,\n};\n// https://github.com/vacuumlabs/adalite/blob/d8ba3bb1ff439ae8e02abd99163435a989d97961/app/frontend/wallet/shelley/transaction/constants.ts\n// policyId is 28 bytes, assetName max 32 bytes, together with quantity makes\n// max token size about 70 bytes, max output size is 4000 => 4000 / 70 ~ 50\nexport const MAX_TOKENS_PER_OUTPUT = 50;\nexport const DATA_COST_PER_UTXO_BYTE = CardanoWasm.DataCost.new_coins_per_byte(CardanoWasm.BigNum.from_str(CARDANO_PARAMS.COINS_PER_UTXO_BYTE));\n","export class CoinSelectionError extends Error {\n    constructor(errorObject) {\n        super(errorObject.message);\n        this.name = 'CoinSelectionError';\n        this.code = errorObject.code;\n        this.message = errorObject.message;\n        Object.setPrototypeOf(this, CoinSelectionError.prototype);\n    }\n}\n","import * as CardanoWasm from '@emurgo/cardano-serialization-lib-asmjs';\nimport { CARDANO_PARAMS, CertificateType, DATA_COST_PER_UTXO_BYTE, ERROR, MAX_TOKENS_PER_OUTPUT, } from '../constants';\nimport { CoinSelectionError } from './errors';\nexport const bigNumFromStr = (num) => CardanoWasm.BigNum.from_str(num);\nexport const getProtocolMagic = (tesnet) => tesnet\n    ? CARDANO_PARAMS.PROTOCOL_MAGICS.testnet\n    : CARDANO_PARAMS.PROTOCOL_MAGICS.mainnet;\nexport const getNetworkId = (testnet) => testnet\n    ? CARDANO_PARAMS.NETWORK_IDS.testnet\n    : CARDANO_PARAMS.NETWORK_IDS.mainnet;\nexport const parseAsset = (hex) => {\n    const policyIdSize = 56;\n    const policyId = hex.slice(0, policyIdSize);\n    const assetNameInHex = hex.slice(policyIdSize);\n    return {\n        policyId,\n        assetNameInHex,\n    };\n};\nexport const buildMultiAsset = (assets) => {\n    const multiAsset = CardanoWasm.MultiAsset.new();\n    const assetsGroupedByPolicy = {};\n    assets.forEach(assetEntry => {\n        const { policyId, assetNameInHex } = parseAsset(assetEntry.unit);\n        if (!assetsGroupedByPolicy[policyId]) {\n            assetsGroupedByPolicy[policyId] = CardanoWasm.Assets.new();\n        }\n        const assets = assetsGroupedByPolicy[policyId];\n        assets.insert(CardanoWasm.AssetName.new(Buffer.from(assetNameInHex, 'hex')), bigNumFromStr(assetEntry.quantity || '0'));\n    });\n    Object.keys(assetsGroupedByPolicy).forEach(policyId => {\n        const scriptHash = CardanoWasm.ScriptHash.from_bytes(Buffer.from(policyId, 'hex'));\n        multiAsset.insert(scriptHash, assetsGroupedByPolicy[policyId]);\n    });\n    return multiAsset;\n};\nexport const multiAssetToArray = (multiAsset) => {\n    if (!multiAsset)\n        return [];\n    const assetsArray = [];\n    const policyHashes = multiAsset.keys();\n    for (let i = 0; i < policyHashes.len(); i++) {\n        const policyId = policyHashes.get(i);\n        const assetsInPolicy = multiAsset.get(policyId);\n        if (!assetsInPolicy)\n            continue;\n        const assetNames = assetsInPolicy.keys();\n        for (let j = 0; j < assetNames.len(); j++) {\n            const assetName = assetNames.get(j);\n            const amount = assetsInPolicy.get(assetName);\n            if (!amount)\n                continue;\n            const policyIdHex = Buffer.from(policyId.to_bytes()).toString('hex');\n            const assetNameHex = Buffer.from(assetName.name()).toString('hex');\n            assetsArray.push({\n                quantity: amount.to_str(),\n                unit: `${policyIdHex}${assetNameHex}`,\n            });\n        }\n    }\n    return assetsArray;\n};\nexport const getAssetAmount = (obj, asset = 'lovelace') => { var _a, _b; return (_b = (_a = obj.amount.find(a => a.unit === asset)) === null || _a === void 0 ? void 0 : _a.quantity) !== null && _b !== void 0 ? _b : '0'; };\nexport const getUtxoQuantity = (utxos, asset = 'lovelace') => utxos.reduce((acc, utxo) => acc.checked_add(bigNumFromStr(getAssetAmount(utxo, asset))), bigNumFromStr('0'));\nexport const getOutputQuantity = (outputs, asset = 'lovelace') => {\n    if (asset === 'lovelace') {\n        return outputs.reduce((acc, output) => { var _a; return acc.checked_add(bigNumFromStr((_a = output.amount) !== null && _a !== void 0 ? _a : '0')); }, bigNumFromStr('0'));\n    }\n    return outputs.reduce((acc, output) => {\n        var _a, _b, _c;\n        return acc.checked_add(bigNumFromStr((_c = (_b = (_a = output.assets) === null || _a === void 0 ? void 0 : _a.find(a => a.unit === asset)) === null || _b === void 0 ? void 0 : _b.quantity) !== null && _c !== void 0 ? _c : '0'));\n    }, bigNumFromStr('0'));\n};\nexport const sortUtxos = (utxos, asset = 'lovelace') => {\n    const copy = JSON.parse(JSON.stringify(utxos));\n    return copy.sort((u1, u2) => bigNumFromStr(getAssetAmount(u2, asset)).compare(bigNumFromStr(getAssetAmount(u1, asset))));\n};\nexport const buildTxInput = (utxo) => {\n    const input = CardanoWasm.TransactionInput.new(CardanoWasm.TransactionHash.from_bytes(Buffer.from(utxo.txHash, 'hex')), utxo.outputIndex);\n    const amount = CardanoWasm.Value.new(bigNumFromStr(getAssetAmount(utxo)));\n    const assets = utxo.amount.filter(a => a.unit !== 'lovelace');\n    if (assets.length > 0) {\n        const multiAsset = buildMultiAsset(assets);\n        amount.set_multiasset(multiAsset);\n    }\n    const address = CardanoWasm.Address.from_bech32(utxo.address);\n    return { input, address, amount };\n};\nexport const buildTxOutput = (output, dummyAddress) => {\n    var _a;\n    // If output.address was not defined fallback to bech32 address (useful for \"precompose\" tx\n    // which doesn't have all necessary data, but we can fill in the blanks and return some info such as fee)\n    const outputAddr = output.address && CardanoWasm.ByronAddress.is_valid(output.address)\n        ? CardanoWasm.ByronAddress.from_base58(output.address).to_address()\n        : CardanoWasm.Address.from_bech32((_a = output.address) !== null && _a !== void 0 ? _a : dummyAddress);\n    // Set initial amount\n    const outputAmount = output.amount\n        ? bigNumFromStr(output.amount)\n        : bigNumFromStr('0');\n    // Create Value including assets\n    let outputValue = CardanoWasm.Value.new(outputAmount);\n    const multiAsset = output.assets.length > 0 ? buildMultiAsset(output.assets) : null;\n    if (multiAsset) {\n        outputValue.set_multiasset(multiAsset);\n    }\n    // Calculate min required ADA for the output\n    let txOutput = CardanoWasm.TransactionOutput.new(outputAddr, outputValue);\n    const minAdaRequired = CardanoWasm.min_ada_for_output(txOutput, DATA_COST_PER_UTXO_BYTE);\n    // If calculated min required ada is greater than current output value than adjust it\n    if (outputAmount.compare(minAdaRequired) < 0) {\n        outputValue = CardanoWasm.Value.new(minAdaRequired);\n        if (multiAsset) {\n            outputValue.set_multiasset(multiAsset);\n        }\n        txOutput = CardanoWasm.TransactionOutput.new(outputAddr, outputValue);\n    }\n    return txOutput;\n};\nexport const getOutputCost = (txBuilder, output, dummyAddress) => {\n    const txOutput = buildTxOutput(output, dummyAddress);\n    const outputFee = txBuilder.fee_for_output(txOutput);\n    const minAda = CardanoWasm.min_ada_for_output(txOutput, DATA_COST_PER_UTXO_BYTE);\n    return {\n        output: txOutput,\n        outputFee,\n        minOutputAmount: minAda, // should match https://cardano-ledger.readthedocs.io/en/latest/explanations/min-utxo.html\n    };\n};\nexport const prepareWithdrawals = (withdrawals) => {\n    const preparedWithdrawals = CardanoWasm.Withdrawals.new();\n    withdrawals.forEach(withdrawal => {\n        const rewardAddress = CardanoWasm.RewardAddress.from_address(CardanoWasm.Address.from_bech32(withdrawal.stakeAddress));\n        if (rewardAddress) {\n            preparedWithdrawals.insert(rewardAddress, bigNumFromStr(withdrawal.amount));\n        }\n    });\n    return preparedWithdrawals;\n};\nexport const prepareCertificates = (certificates, accountKey) => {\n    const preparedCertificates = CardanoWasm.Certificates.new();\n    if (certificates.length === 0)\n        return preparedCertificates;\n    const stakeKey = accountKey.derive(2).derive(0);\n    const stakeCred = CardanoWasm.StakeCredential.from_keyhash(stakeKey.to_raw_key().hash());\n    certificates.forEach(cert => {\n        if (cert.type === CertificateType.STAKE_REGISTRATION) {\n            preparedCertificates.add(CardanoWasm.Certificate.new_stake_registration(CardanoWasm.StakeRegistration.new(stakeCred)));\n        }\n        else if (cert.type === CertificateType.STAKE_DELEGATION) {\n            preparedCertificates.add(CardanoWasm.Certificate.new_stake_delegation(CardanoWasm.StakeDelegation.new(stakeCred, CardanoWasm.Ed25519KeyHash.from_bytes(Buffer.from(cert.pool, 'hex')))));\n        }\n        else if (cert.type === CertificateType.STAKE_DEREGISTRATION) {\n            preparedCertificates.add(CardanoWasm.Certificate.new_stake_deregistration(CardanoWasm.StakeDeregistration.new(stakeCred)));\n        }\n        else {\n            throw new CoinSelectionError(ERROR.UNSUPPORTED_CERTIFICATE_TYPE);\n        }\n    });\n    return preparedCertificates;\n};\nexport const calculateRequiredDeposit = (certificates) => {\n    const CertificateDeposit = {\n        [CertificateType.STAKE_DELEGATION]: 0,\n        [CertificateType.STAKE_POOL_REGISTRATION]: 500000000,\n        [CertificateType.STAKE_REGISTRATION]: 2000000,\n        [CertificateType.STAKE_DEREGISTRATION]: -2000000,\n    };\n    return certificates.reduce((acc, cert) => (acc += CertificateDeposit[cert.type]), 0);\n};\nexport const setMinUtxoValueForOutputs = (txBuilder, outputs, dummyAddress) => {\n    const preparedOutputs = outputs.map(output => {\n        // sets minimal output ADA amount in case of multi-asset output\n        const { minOutputAmount } = getOutputCost(txBuilder, output, dummyAddress);\n        const outputAmount = bigNumFromStr(output.amount || '0');\n        let amount;\n        if (output.assets.length > 0 && outputAmount.compare(minOutputAmount) < 0) {\n            // output with an asset(s) adjust minimum ADA to met network requirements\n            amount = minOutputAmount.to_str();\n        }\n        else {\n            amount = output.amount;\n        }\n        if (!output.setMax &&\n            output.assets.length === 0 &&\n            output.amount &&\n            outputAmount.compare(minOutputAmount) < 0) {\n            // Case of an output without any asset, and without setMax = true\n            // If the user entered less than min utxo val then throw an error (won't throw if there is no amount yet)\n            // (On outputs with setMax flag we set '0' on purpose)\n            // (On outputs with an asset we automatically adjust ADA amount if it is below required minimum)\n            throw new CoinSelectionError(ERROR.UTXO_VALUE_TOO_SMALL);\n        }\n        if (output.setMax) {\n            // if setMax is active set initial value to 0\n            if (output.assets.length > 0) {\n                output.assets[0].quantity = '0';\n            }\n            else {\n                amount = '0';\n            }\n        }\n        return Object.assign(Object.assign({}, output), { \n            // if output contains assets make sure that minUtxoValue is at least minOutputAmount (even for output where we want to setMax)\n            amount });\n    });\n    return preparedOutputs;\n};\nexport const splitChangeOutput = (txBuilder, singleChangeOutput, changeAddress, maxTokensPerOutput = MAX_TOKENS_PER_OUTPUT) => {\n    // TODO: https://github.com/Emurgo/cardano-serialization-lib/pull/236\n    const multiAsset = singleChangeOutput.output.amount().multiasset();\n    if (!multiAsset || (multiAsset && multiAsset.len() < maxTokensPerOutput)) {\n        return [singleChangeOutput];\n    }\n    let lovelaceAvailable = singleChangeOutput.output\n        .amount()\n        .coin()\n        .checked_add(singleChangeOutput.outputFee);\n    const allAssets = multiAssetToArray(singleChangeOutput.output.amount().multiasset());\n    const nAssetBundles = Math.ceil(allAssets.length / maxTokensPerOutput);\n    const changeOutputs = [];\n    // split change output to multiple outputs, where each bundle has maximum of maxTokensPerOutput assets\n    for (let i = 0; i < nAssetBundles; i++) {\n        const assetsBundle = allAssets.slice(i * maxTokensPerOutput, (i + 1) * maxTokensPerOutput);\n        const outputValue = CardanoWasm.Value.new_from_assets(buildMultiAsset(assetsBundle));\n        const txOutput = CardanoWasm.TransactionOutput.new(CardanoWasm.Address.from_bech32(changeAddress), outputValue);\n        const minAdaRequired = CardanoWasm.min_ada_for_output(txOutput, DATA_COST_PER_UTXO_BYTE);\n        changeOutputs.push({\n            isChange: true,\n            address: changeAddress,\n            amount: minAdaRequired.to_str(),\n            assets: assetsBundle,\n        });\n    }\n    const changeOutputsCost = changeOutputs.map((partialChange, i) => {\n        let changeOutputCost = getOutputCost(txBuilder, partialChange, changeAddress);\n        lovelaceAvailable = lovelaceAvailable.clamped_sub(bigNumFromStr(partialChange.amount).checked_add(changeOutputCost.outputFee));\n        if (i === changeOutputs.length - 1) {\n            // add all unused ADA to the last change output\n            let changeOutputAmount = lovelaceAvailable.checked_add(bigNumFromStr(partialChange.amount));\n            if (changeOutputAmount.compare(changeOutputCost.minOutputAmount) < 0) {\n                // computed change amount would be below minUtxoValue\n                // set change output amount to met minimum requirements for minUtxoValue\n                changeOutputAmount = changeOutputCost.minOutputAmount;\n            }\n            partialChange.amount = changeOutputAmount.to_str();\n            changeOutputCost = getOutputCost(txBuilder, partialChange, changeAddress);\n        }\n        return changeOutputCost;\n    });\n    return changeOutputsCost;\n};\nexport const prepareChangeOutput = (txBuilder, usedUtxos, preparedOutputs, changeAddress, utxosTotalAmount, totalOutputAmount, totalFeesAmount, pickAdditionalUtxo) => {\n    // change output amount should be lowered by the cost of the change output (fee + minUtxoVal)\n    // The cost will be subtracted once we calculate it.\n    const placeholderChangeOutputAmount = utxosTotalAmount.clamped_sub(totalFeesAmount.checked_add(totalOutputAmount));\n    const uniqueAssets = [];\n    usedUtxos.forEach(utxo => {\n        const assets = utxo.amount.filter(a => a.unit !== 'lovelace');\n        assets.forEach(asset => {\n            if (!uniqueAssets.includes(asset.unit)) {\n                uniqueAssets.push(asset.unit);\n            }\n        });\n    });\n    const changeOutputAssets = uniqueAssets\n        .map(assetUnit => {\n        const assetInputAmount = getUtxoQuantity(usedUtxos, assetUnit);\n        const assetSpentAmount = getOutputQuantity(preparedOutputs, assetUnit);\n        return {\n            unit: assetUnit,\n            quantity: assetInputAmount.clamped_sub(assetSpentAmount).to_str(),\n        };\n    })\n        .filter(asset => asset.quantity !== '0');\n    const changeOutputCost = getOutputCost(txBuilder, {\n        address: changeAddress,\n        amount: placeholderChangeOutputAmount.to_str(),\n        assets: changeOutputAssets,\n    }, changeAddress);\n    // calculate change output amount as utxosTotalAmount - totalOutputAmount - totalFeesAmount - change output fee\n    const totalSpent = totalOutputAmount\n        .checked_add(totalFeesAmount)\n        .checked_add(changeOutputCost.outputFee);\n    let changeOutputAmount = utxosTotalAmount.clamped_sub(totalSpent);\n    // Sum of all tokens in utxos must be same as sum of the tokens in external + change outputs\n    // If computed change output doesn't contain any tokens then it makes sense to add it only if the fee + minUtxoValue is less then the amount\n    let isChangeOutputNeeded = false;\n    if (changeOutputAssets.length > 0 ||\n        changeOutputAmount.compare(changeOutputCost.minOutputAmount) >= 0) {\n        isChangeOutputNeeded = true;\n    }\n    else if (pickAdditionalUtxo &&\n        changeOutputAmount.compare(bigNumFromStr('5000')) >= 0) {\n        // change amount is above our constant (0.005 ADA), but still less than required minUtxoValue\n        // try to add another utxo recalculate change again\n        const utxo = pickAdditionalUtxo();\n        if (utxo) {\n            utxo.addUtxo();\n            const newTotalFee = txBuilder.min_fee();\n            return prepareChangeOutput(txBuilder, usedUtxos, preparedOutputs, changeAddress, getUtxoQuantity(usedUtxos, 'lovelace'), totalOutputAmount, newTotalFee, pickAdditionalUtxo);\n        }\n    }\n    if (isChangeOutputNeeded) {\n        if (changeOutputAmount.compare(changeOutputCost.minOutputAmount) < 0) {\n            // computed change amount would be below minUtxoValue\n            // set change output amount to met minimum requirements for minUtxoValue\n            changeOutputAmount = changeOutputCost.minOutputAmount;\n        }\n        // TODO: changeOutputCost.output.amount().set_coin(changeOutputAmount)?\n        const txOutput = buildTxOutput({\n            amount: changeOutputAmount.to_str(),\n            address: changeAddress,\n            assets: changeOutputAssets,\n        }, changeAddress);\n        // WARNING: It returns a change output also in a case where we don't have enough utxos to cover the output cost, but the change output is needed because it contains additional assets\n        return {\n            outputFee: changeOutputCost.outputFee,\n            minOutputAmount: changeOutputCost.minOutputAmount,\n            output: txOutput,\n        };\n    }\n    // Change output not needed\n    return null;\n};\nexport const getTxBuilder = (a = '44') => CardanoWasm.TransactionBuilder.new(CardanoWasm.TransactionBuilderConfigBuilder.new()\n    .fee_algo(CardanoWasm.LinearFee.new(bigNumFromStr(a), bigNumFromStr('155381')))\n    .pool_deposit(bigNumFromStr('500000000'))\n    .key_deposit(bigNumFromStr('2000000'))\n    .coins_per_utxo_byte(bigNumFromStr(CARDANO_PARAMS.COINS_PER_UTXO_BYTE))\n    .max_value_size(CARDANO_PARAMS.MAX_VALUE_SIZE)\n    .max_tx_size(CARDANO_PARAMS.MAX_TX_SIZE)\n    .build());\nexport const getUnsatisfiedAssets = (selectedUtxos, outputs) => {\n    const assets = [];\n    outputs.forEach(output => {\n        if (output.assets.length > 0) {\n            const asset = output.assets[0];\n            const assetAmountInUtxos = getUtxoQuantity(selectedUtxos, asset.unit);\n            if (assetAmountInUtxos.compare(bigNumFromStr(asset.quantity)) < 0) {\n                assets.push(asset.unit);\n            }\n        }\n    });\n    const lovelaceUtxo = getUtxoQuantity(selectedUtxos, 'lovelace');\n    if (lovelaceUtxo.compare(getOutputQuantity(outputs, 'lovelace')) < 0) {\n        assets.push('lovelace');\n    }\n    return assets;\n};\nexport const getInitialUtxoSet = (utxos, maxOutput) => {\n    var _a, _b;\n    // Picks all utxos containing an asset on which the user requested to set maximum value\n    if (!maxOutput)\n        return {\n            used: [],\n            remaining: utxos,\n        };\n    const used = [];\n    const remaining = [];\n    const maxOutputAsset = (_b = (_a = maxOutput.assets[0]) === null || _a === void 0 ? void 0 : _a.unit) !== null && _b !== void 0 ? _b : 'lovelace';\n    // either all UTXOs will be used (send max for ADA output) or initial set of used utxos will contain all utxos containing given token\n    utxos.forEach(u => {\n        if (u.amount.find(a => a.unit === maxOutputAsset)) {\n            used.push(u);\n        }\n        else {\n            remaining.push(u);\n        }\n    });\n    return {\n        used,\n        remaining,\n    };\n};\nexport const setMaxOutput = (maxOutput, changeOutput) => {\n    var _a, _b, _c, _d;\n    const maxOutputAsset = (_b = (_a = maxOutput.assets[0]) === null || _a === void 0 ? void 0 : _a.unit) !== null && _b !== void 0 ? _b : 'lovelace';\n    let newMaxAmount = bigNumFromStr('0');\n    const changeOutputAssets = multiAssetToArray(changeOutput === null || changeOutput === void 0 ? void 0 : changeOutput.output.amount().multiasset());\n    if (maxOutputAsset === 'lovelace') {\n        // set maxOutput for ADA\n        if (changeOutput) {\n            newMaxAmount = changeOutput.output.amount().coin();\n            if (changeOutputAssets.length === 0) {\n                // we don't need the change output anymore\n                newMaxAmount = newMaxAmount.checked_add(changeOutput.outputFee);\n                changeOutput = null;\n            }\n            else {\n                newMaxAmount = newMaxAmount.clamped_sub(changeOutput.minOutputAmount);\n                const txOutput = CardanoWasm.TransactionOutput.new(changeOutput.output.address(), CardanoWasm.Value.new(newMaxAmount));\n                const minUtxoVal = CardanoWasm.min_ada_for_output(txOutput, DATA_COST_PER_UTXO_BYTE);\n                if (newMaxAmount.compare(minUtxoVal) < 0) {\n                    // the amount would be less than min required ADA\n                    throw new CoinSelectionError(ERROR.UTXO_BALANCE_INSUFFICIENT);\n                }\n            }\n        }\n        maxOutput.amount = newMaxAmount.to_str();\n    }\n    else {\n        // set maxOutput for token\n        if (changeOutput) {\n            // max amount of the asset in output is equal to its quantity in change output\n            newMaxAmount = bigNumFromStr((_d = (_c = changeOutputAssets.find(a => a.unit === maxOutputAsset)) === null || _c === void 0 ? void 0 : _c.quantity) !== null && _d !== void 0 ? _d : '0');\n            maxOutput.assets[0].quantity = newMaxAmount.to_str(); // TODO: set 0 if no change?\n            const txOutput = CardanoWasm.TransactionOutput.new(changeOutput.output.address(), \n            // new_from_assets does not automatically include required ADA\n            CardanoWasm.Value.new_from_assets(buildMultiAsset(maxOutput.assets)));\n            // adjust ADA amount to cover min ada for the asset\n            maxOutput.amount = CardanoWasm.min_ada_for_output(txOutput, DATA_COST_PER_UTXO_BYTE).to_str();\n        }\n    }\n    return { maxOutput };\n};\nexport const getUserOutputQuantityWithDeposit = (outputs, deposit, asset = 'lovelace') => {\n    let amount = getOutputQuantity(outputs, asset);\n    if (deposit > 0) {\n        amount = amount.checked_add(bigNumFromStr(deposit.toString()));\n    }\n    return amount;\n};\nexport const filterUtxos = (utxos, asset) => {\n    return utxos.filter(utxo => utxo.amount.find(a => a.unit === asset));\n};\nexport const getRandomUtxo = (txBuilder, utxoRemaining, utxoSelected) => {\n    const index = Math.floor(Math.random() * utxoRemaining.length);\n    const utxo = utxoRemaining[index];\n    if (!utxo)\n        return null;\n    return {\n        utxo,\n        addUtxo: () => {\n            utxoSelected.push(utxo);\n            const { input, address, amount } = buildTxInput(utxo);\n            txBuilder.add_input(address, input, amount);\n            utxoRemaining.splice(utxoRemaining.indexOf(utxo), 1);\n        },\n    };\n};\nexport const calculateUserOutputsFee = (txBuilder, userOutputs, changeAddress) => {\n    // Calculate fee and minUtxoValue for all external outputs\n    const outputsCost = userOutputs.map(output => getOutputCost(txBuilder, output, changeAddress));\n    const totalOutputsFee = outputsCost.reduce((acc, output) => (acc = acc.checked_add(output.outputFee)), bigNumFromStr('0'));\n    return totalOutputsFee;\n};\nexport const orderInputs = (inputsToOrder, txBody) => {\n    // reorder inputs to match order within tx\n    const orderedInputs = [];\n    for (let i = 0; i < txBody.inputs().len(); i++) {\n        const txid = Buffer.from(txBody.inputs().get(i).transaction_id().to_bytes()).toString('hex');\n        const outputIndex = txBody.inputs().get(i).index();\n        const utxo = inputsToOrder.find(uu => uu.txHash === txid && uu.outputIndex === outputIndex);\n        if (!utxo) {\n            throw new Error('Failed to order the utxos to match the order of inputs in constructed tx. THIS SHOULD NOT HAPPEN');\n        }\n        orderedInputs.push(utxo);\n    }\n    return orderedInputs;\n};\n","import { ERROR } from '../constants';\nimport * as CardanoWasm from '@emurgo/cardano-serialization-lib-asmjs';\nimport { bigNumFromStr, calculateRequiredDeposit, getAssetAmount, prepareCertificates, prepareChangeOutput, prepareWithdrawals, setMinUtxoValueForOutputs, sortUtxos, getTxBuilder, getInitialUtxoSet, setMaxOutput, getUserOutputQuantityWithDeposit, multiAssetToArray, buildTxInput, buildTxOutput, getUnsatisfiedAssets, splitChangeOutput, calculateUserOutputsFee, orderInputs, } from '../utils/common';\nimport { CoinSelectionError } from '../utils/errors';\nexport const largestFirst = (params, options) => {\n    var _a;\n    const { utxos, outputs, changeAddress, certificates, withdrawals, accountPubKey, ttl, } = params;\n    const txBuilder = getTxBuilder((_a = options === null || options === void 0 ? void 0 : options.feeParams) === null || _a === void 0 ? void 0 : _a.a);\n    if (ttl) {\n        txBuilder.set_ttl(ttl);\n    }\n    const usedUtxos = [];\n    let sortedUtxos = sortUtxos(utxos);\n    const accountKey = CardanoWasm.Bip32PublicKey.from_bytes(Buffer.from(accountPubKey, 'hex'));\n    // add withdrawals and certs to correctly set a fee\n    const preparedCertificates = prepareCertificates(certificates, accountKey);\n    const preparedWithdrawals = prepareWithdrawals(withdrawals);\n    if (preparedCertificates.len() > 0) {\n        txBuilder.set_certs(preparedCertificates);\n    }\n    if (preparedWithdrawals.len() > 0) {\n        txBuilder.set_withdrawals(preparedWithdrawals);\n    }\n    // TODO: negative value in case of deregistration (-2000000), but we still need enough utxos to cover fee which can't be (is that right?) paid from returned deposit\n    const deposit = calculateRequiredDeposit(certificates);\n    const totalWithdrawal = withdrawals.reduce((acc, withdrawal) => acc.checked_add(bigNumFromStr(withdrawal.amount)), bigNumFromStr('0'));\n    // calc initial fee\n    let totalFeesAmount = txBuilder.min_fee();\n    let utxosTotalAmount = totalWithdrawal;\n    if (deposit < 0) {\n        // stake deregistration, 2 ADA returned\n        utxosTotalAmount = utxosTotalAmount.checked_add(bigNumFromStr(Math.abs(deposit).toString()));\n    }\n    const preparedOutputs = setMinUtxoValueForOutputs(txBuilder, outputs, changeAddress);\n    const addUtxoToSelection = (utxo) => {\n        const { input, address, amount } = buildTxInput(utxo);\n        const fee = txBuilder.fee_for_input(address, input, amount);\n        txBuilder.add_input(address, input, amount);\n        usedUtxos.push(utxo);\n        totalFeesAmount = totalFeesAmount.checked_add(fee);\n        utxosTotalAmount = utxosTotalAmount.checked_add(bigNumFromStr(getAssetAmount(utxo)));\n    };\n    // set initial utxos set for setMax functionality\n    const maxOutputIndex = outputs.findIndex(o => !!o.setMax);\n    const maxOutput = preparedOutputs[maxOutputIndex];\n    const { used, remaining } = getInitialUtxoSet(sortedUtxos, maxOutput);\n    sortedUtxos = remaining;\n    used.forEach(utxo => addUtxoToSelection(utxo));\n    // add cost of external outputs to total fee amount\n    totalFeesAmount = totalFeesAmount.checked_add(calculateUserOutputsFee(txBuilder, preparedOutputs, changeAddress));\n    let totalUserOutputsAmount = getUserOutputQuantityWithDeposit(preparedOutputs, deposit);\n    let changeOutput = null;\n    let sufficientUtxos = false;\n    let forceAnotherRound = false;\n    while (!sufficientUtxos) {\n        if (maxOutput) {\n            // reset previously computed maxOutput in order to correctly calculate a potential change output\n            preparedOutputs[maxOutputIndex] = setMinUtxoValueForOutputs(txBuilder, [maxOutput], changeAddress)[0];\n        }\n        // Calculate change output\n        let singleChangeOutput = prepareChangeOutput(txBuilder, usedUtxos, preparedOutputs, changeAddress, utxosTotalAmount, getUserOutputQuantityWithDeposit(preparedOutputs, deposit), totalFeesAmount);\n        if (maxOutput) {\n            // set amount for a max output from a changeOutput calculated above\n            const { maxOutput: newMaxOutput } = setMaxOutput(maxOutput, singleChangeOutput);\n            // change output may be completely removed if all ADA are consumed by max output\n            preparedOutputs[maxOutputIndex] = newMaxOutput;\n            // recalculate  total user outputs amount\n            totalUserOutputsAmount = getUserOutputQuantityWithDeposit(preparedOutputs, deposit);\n            // recalculate fees for outputs as cost for max output may be larger than before\n            totalFeesAmount = txBuilder\n                .min_fee()\n                .checked_add(calculateUserOutputsFee(txBuilder, preparedOutputs, changeAddress));\n            // recalculate change after setting amount to max output\n            singleChangeOutput = prepareChangeOutput(txBuilder, usedUtxos, preparedOutputs, changeAddress, utxosTotalAmount, getUserOutputQuantityWithDeposit(preparedOutputs, deposit), totalFeesAmount);\n        }\n        const changeOutputs = singleChangeOutput\n            ? splitChangeOutput(txBuilder, singleChangeOutput, changeAddress, options === null || options === void 0 ? void 0 : options._maxTokensPerOutput)\n            : [];\n        let requiredAmount = totalFeesAmount.checked_add(totalUserOutputsAmount);\n        changeOutputs.forEach(changeOutput => {\n            // we need to cover amounts and fees for change outputs\n            requiredAmount = requiredAmount\n                .checked_add(changeOutput.output.amount().coin())\n                .checked_add(changeOutput.outputFee);\n        });\n        // List of tokens for which we don't have enough utxos\n        const unsatisfiedAssets = getUnsatisfiedAssets(usedUtxos, preparedOutputs);\n        if (utxosTotalAmount.compare(requiredAmount) >= 0 &&\n            unsatisfiedAssets.length === 0 &&\n            usedUtxos.length > 0 && // TODO: force at least 1 utxo, otherwise withdrawal tx is composed without utxo if rewards > tx cost\n            !forceAnotherRound) {\n            // we are done. we have enough utxos to cover fees + minUtxoValue for each output. now we can add the cost of the change output to total fees\n            if (changeOutputs.length > 0) {\n                changeOutputs.forEach(changeOutput => {\n                    totalFeesAmount = totalFeesAmount.checked_add(changeOutput.outputFee);\n                });\n                // set change output\n                changeOutput = changeOutputs.map(change => ({\n                    isChange: true,\n                    amount: change.output.amount().coin().to_str(),\n                    address: changeAddress,\n                    assets: multiAssetToArray(change.output.amount().multiasset()),\n                }));\n            }\n            else {\n                if (sortedUtxos.length > 0) {\n                    // In current iteration we don't have enough utxo to meet min utxo value for an output,\n                    // but some utxos are still available, force adding another one in order to create a change output\n                    forceAnotherRound = true;\n                    continue;\n                }\n                // Change output would be inefficient., we can burn its value + fee we would pay for it\n                const unspendableChangeAmount = utxosTotalAmount.clamped_sub(totalFeesAmount.checked_add(totalUserOutputsAmount));\n                totalFeesAmount = totalFeesAmount.checked_add(unspendableChangeAmount);\n            }\n            sufficientUtxos = true;\n        }\n        else {\n            if (unsatisfiedAssets.length > 0) {\n                // TODO: https://github.com/Emurgo/cardano-serialization-lib/pull/264\n                sortedUtxos = sortUtxos(sortedUtxos, unsatisfiedAssets[0]);\n            }\n            else {\n                sortedUtxos = sortUtxos(sortedUtxos);\n            }\n            const utxo = sortedUtxos.shift();\n            if (!utxo)\n                break;\n            addUtxoToSelection(utxo);\n            forceAnotherRound = false;\n        }\n        // END LOOP\n    }\n    if (!sufficientUtxos) {\n        throw new CoinSelectionError(ERROR.UTXO_BALANCE_INSUFFICIENT);\n    }\n    preparedOutputs.forEach(output => {\n        const txOutput = buildTxOutput(output, changeAddress);\n        txBuilder.add_output(txOutput);\n    });\n    const finalOutputs = JSON.parse(JSON.stringify(preparedOutputs));\n    if (changeOutput) {\n        changeOutput.forEach(change => {\n            finalOutputs.push(change);\n            txBuilder.add_output(buildTxOutput(change, changeAddress));\n        });\n    }\n    txBuilder.set_fee(totalFeesAmount);\n    const txBody = txBuilder.build();\n    const txHash = Buffer.from(CardanoWasm.hash_transaction(txBody).to_bytes()).toString('hex');\n    const txBodyHex = Buffer.from(txBody.to_bytes()).toString('hex');\n    const totalSpent = totalUserOutputsAmount.checked_add(totalFeesAmount);\n    // Set max property with the value of an output which has setMax=true\n    let max;\n    if (maxOutput) {\n        max =\n            maxOutput.assets.length > 0\n                ? maxOutput.assets[0].quantity\n                : maxOutput.amount;\n    }\n    // reorder inputs to match order within tx\n    const orderedInputs = orderInputs(usedUtxos, txBody);\n    return {\n        tx: { body: txBodyHex, hash: txHash, size: txBuilder.full_size() },\n        inputs: orderedInputs,\n        outputs: finalOutputs,\n        fee: totalFeesAmount.to_str(),\n        totalSpent: totalSpent.to_str(),\n        deposit: deposit.toString(),\n        withdrawal: totalWithdrawal.to_str(),\n        ttl,\n        max,\n    };\n};\n","const myFormat = ({ level, args, label, timestamp, }) => {\n    if (timestamp) {\n        return [`${timestamp} [${label}] ${level}:`, ...args];\n    }\n    return [`[${label}] ${level}:`, ...args];\n};\nexport const getLogger = (debug) => {\n    const label = '@fivebinaries/coin-selection';\n    return {\n        debug: (...args) => {\n            if (!debug)\n                return;\n            const formattedMessage = myFormat({\n                level: 'DEBUG',\n                args: args,\n                // timestamp: new Date().toISOString(),\n                timestamp: undefined,\n                label,\n            });\n            console.log(...formattedMessage);\n        },\n    };\n};\n","import { ERROR } from '../constants';\nimport * as CardanoWasm from '@emurgo/cardano-serialization-lib-asmjs';\nimport { bigNumFromStr, prepareChangeOutput, setMinUtxoValueForOutputs, getTxBuilder, getUserOutputQuantityWithDeposit, multiAssetToArray, buildTxInput, buildTxOutput, getUnsatisfiedAssets, splitChangeOutput, filterUtxos, getUtxoQuantity, getOutputQuantity, getRandomUtxo, orderInputs, } from '../utils/common';\nimport { CoinSelectionError } from '../utils/errors';\nimport { getLogger } from '../utils/logger';\n// Heavily inspired by https://github.com/input-output-hk/cardano-js-sdk\nconst improvesSelection = (utxoAlreadySelected, input, minimumTarget, asset) => {\n    const oldQuantity = getUtxoQuantity(utxoAlreadySelected, asset);\n    // We still haven't reached the minimum target of\n    // 100%. Therefore, we consider any potential input\n    // to be an improvement:\n    if (oldQuantity.compare(minimumTarget) < 0)\n        return true;\n    const newQuantity = oldQuantity.checked_add(getUtxoQuantity([input], asset));\n    const idealTarget = minimumTarget.checked_mul(bigNumFromStr('2'));\n    const newDistance = idealTarget.compare(newQuantity) > 0\n        ? idealTarget.clamped_sub(newQuantity)\n        : newQuantity.clamped_sub(idealTarget);\n    const oldDistance = idealTarget.compare(oldQuantity) > 0\n        ? idealTarget.clamped_sub(oldQuantity)\n        : oldQuantity.clamped_sub(idealTarget);\n    // Using this input will move us closer to the\n    // ideal target of 200%, so we treat this as an improvement:\n    if (newDistance.compare(oldDistance) < 0)\n        return true;\n    // Adding the selected input would move us further\n    // away from the target of 200%. Reaching this case\n    // means we have already covered the minimum target\n    // of 100%, and therefore it is safe to not consider\n    // this token any further:\n    return false;\n};\nconst selection = (utxos, outputs, txBuilder, dummyAddress) => {\n    const utxoSelected = [];\n    const utxoRemaining = JSON.parse(JSON.stringify(utxos));\n    const preparedOutputs = setMinUtxoValueForOutputs(txBuilder, outputs, dummyAddress);\n    preparedOutputs.forEach(output => {\n        const txOutput = buildTxOutput(output, dummyAddress);\n        txBuilder.add_output(txOutput);\n    });\n    // Check for UTXO_BALANCE_INSUFFICIENT comparing provided inputs with requested outputs\n    const assetsRemaining = getUnsatisfiedAssets(utxoSelected, preparedOutputs);\n    assetsRemaining.forEach(asset => {\n        const outputQuantity = getOutputQuantity(preparedOutputs, asset);\n        const utxosQuantity = getUtxoQuantity(utxos, asset);\n        if (outputQuantity.compare(utxosQuantity) > 0) {\n            throw new CoinSelectionError(ERROR.UTXO_BALANCE_INSUFFICIENT);\n        }\n    });\n    while (assetsRemaining.length > 0) {\n        assetsRemaining.forEach((asset, assetIndex) => {\n            const assetUtxos = filterUtxos(utxoRemaining, asset);\n            if (assetUtxos.length > 0) {\n                const inputIdx = Math.floor(Math.random() * assetUtxos.length);\n                const utxo = assetUtxos[inputIdx];\n                if (improvesSelection(utxoSelected, utxo, getOutputQuantity(preparedOutputs, asset), asset)) {\n                    utxoSelected.push(utxo);\n                    const { input, address, amount } = buildTxInput(utxo);\n                    txBuilder.add_input(address, input, amount);\n                    utxoRemaining.splice(utxoRemaining.indexOf(utxo), 1);\n                }\n                else {\n                    // The selection was not improved by including\n                    // this input. If we've reached this point, it\n                    // means that we've already covered the minimum\n                    // target of 100%, and therefore it is safe to\n                    // not consider this token any further.\n                    assetsRemaining.splice(assetIndex, 1);\n                }\n            }\n            else {\n                // The attempt to select an input failed (there were\n                // no inputs remaining that contained the token).\n                // This means that we've already covered the minimum\n                // quantity required (due to the pre-condition), and\n                // therefore it is safe to not consider this token\n                // any further:\n                assetsRemaining.splice(assetIndex, 1);\n            }\n        });\n    }\n    return { utxoSelected, utxoRemaining, preparedOutputs };\n};\nconst calculateChange = (utxoSelected, utxoRemaining, preparedOutputs, changeAddress, maxTokensPerOutput, txBuilder) => {\n    const totalFeesAmount = txBuilder.min_fee();\n    const totalUserOutputsAmount = getUserOutputQuantityWithDeposit(preparedOutputs, 0);\n    const singleChangeOutput = prepareChangeOutput(txBuilder, utxoSelected, preparedOutputs, changeAddress, getUtxoQuantity(utxoSelected, 'lovelace'), getUserOutputQuantityWithDeposit(preparedOutputs, 0), totalFeesAmount, () => getRandomUtxo(txBuilder, utxoRemaining, utxoSelected));\n    const changeOutputs = singleChangeOutput\n        ? splitChangeOutput(txBuilder, singleChangeOutput, changeAddress, maxTokensPerOutput)\n        : [];\n    let requiredAmount = totalFeesAmount.checked_add(totalUserOutputsAmount);\n    changeOutputs.forEach(changeOutput => {\n        // we need to cover amounts and fees for change outputs\n        requiredAmount = requiredAmount\n            .checked_add(changeOutput.output.amount().coin())\n            .checked_add(changeOutput.outputFee);\n    });\n    if (requiredAmount.compare(getUtxoQuantity(utxoSelected, 'lovelace')) > 0) {\n        const randomUtxo = getRandomUtxo(txBuilder, utxoRemaining, utxoSelected);\n        if (randomUtxo === null || randomUtxo === void 0 ? void 0 : randomUtxo.utxo) {\n            randomUtxo.addUtxo();\n            const { changeOutputs } = calculateChange(utxoSelected, utxoRemaining, preparedOutputs, changeAddress, maxTokensPerOutput, txBuilder);\n            return { changeOutputs };\n        }\n        else {\n            throw new CoinSelectionError(ERROR.UTXO_BALANCE_INSUFFICIENT);\n        }\n    }\n    else {\n        return { changeOutputs };\n    }\n};\nexport const randomImprove = (params, options) => {\n    var _a;\n    const { utxos, outputs, changeAddress, ttl } = params;\n    const logger = getLogger(!!(options === null || options === void 0 ? void 0 : options.debug));\n    if (outputs.length > utxos.length) {\n        logger.debug('There are more outputs than utxos. Random-improve alg needs to have number of utxos same or larger than number of outputs');\n        throw new CoinSelectionError(ERROR.UTXO_NOT_FRAGMENTED_ENOUGH);\n    }\n    const txBuilder = getTxBuilder((_a = options === null || options === void 0 ? void 0 : options.feeParams) === null || _a === void 0 ? void 0 : _a.a);\n    if (ttl) {\n        txBuilder.set_ttl(ttl);\n    }\n    const { utxoSelected, utxoRemaining, preparedOutputs } = selection(utxos, outputs, txBuilder, changeAddress);\n    // compute change and adjust for fee\n    const { changeOutputs } = calculateChange(utxoSelected, utxoRemaining, preparedOutputs, changeAddress, options === null || options === void 0 ? void 0 : options._maxTokensPerOutput, txBuilder);\n    const finalOutputs = JSON.parse(JSON.stringify(preparedOutputs));\n    changeOutputs.forEach(change => {\n        const ch = {\n            isChange: true,\n            amount: change.output.amount().coin().to_str(),\n            address: changeAddress,\n            assets: multiAssetToArray(change.output.amount().multiasset()),\n        };\n        finalOutputs.push(ch);\n        txBuilder.add_output(buildTxOutput(ch, changeAddress));\n    });\n    const totalUserOutputsAmount = getUserOutputQuantityWithDeposit(preparedOutputs, 0);\n    const totalInput = getUtxoQuantity(utxoSelected, 'lovelace');\n    const totalOutput = getOutputQuantity(finalOutputs, 'lovelace');\n    const fee = totalInput.checked_sub(totalOutput);\n    const totalSpent = totalUserOutputsAmount.checked_add(fee);\n    txBuilder.set_fee(fee);\n    const txBody = txBuilder.build();\n    const txHash = Buffer.from(CardanoWasm.hash_transaction(txBody).to_bytes()).toString('hex');\n    const txBodyHex = Buffer.from(txBody.to_bytes()).toString('hex');\n    // reorder inputs to match order within tx\n    const orderedInputs = orderInputs(utxoSelected, txBody);\n    return {\n        tx: { body: txBodyHex, hash: txHash, size: txBuilder.full_size() },\n        inputs: orderedInputs,\n        outputs: finalOutputs,\n        fee: fee.to_str(),\n        totalSpent: totalSpent.to_str(),\n        deposit: '0',\n        withdrawal: '0',\n        ttl,\n    };\n};\n","export var CardanoAddressType;\n(function (CardanoAddressType) {\n    CardanoAddressType[CardanoAddressType[\"BASE\"] = 0] = \"BASE\";\n    CardanoAddressType[CardanoAddressType[\"BASE_SCRIPT_KEY\"] = 1] = \"BASE_SCRIPT_KEY\";\n    CardanoAddressType[CardanoAddressType[\"BASE_KEY_SCRIPT\"] = 2] = \"BASE_KEY_SCRIPT\";\n    CardanoAddressType[CardanoAddressType[\"BASE_SCRIPT_SCRIPT\"] = 3] = \"BASE_SCRIPT_SCRIPT\";\n    CardanoAddressType[CardanoAddressType[\"POINTER\"] = 4] = \"POINTER\";\n    CardanoAddressType[CardanoAddressType[\"POINTER_SCRIPT\"] = 5] = \"POINTER_SCRIPT\";\n    CardanoAddressType[CardanoAddressType[\"ENTERPRISE\"] = 6] = \"ENTERPRISE\";\n    CardanoAddressType[CardanoAddressType[\"ENTERPRISE_SCRIPT\"] = 7] = \"ENTERPRISE_SCRIPT\";\n    CardanoAddressType[CardanoAddressType[\"BYRON\"] = 8] = \"BYRON\";\n    CardanoAddressType[CardanoAddressType[\"REWARD\"] = 14] = \"REWARD\";\n    CardanoAddressType[CardanoAddressType[\"REWARD_SCRIPT\"] = 15] = \"REWARD_SCRIPT\";\n})(CardanoAddressType || (CardanoAddressType = {}));\n","import { parseAsset } from '../common';\nexport const transformToTokenBundle = (assets) => {\n    // prepare token bundle used in trezor output\n    if (assets.length === 0)\n        return undefined;\n    const uniquePolicies = [];\n    assets.forEach(asset => {\n        const { policyId } = parseAsset(asset.unit);\n        if (!uniquePolicies.includes(policyId)) {\n            uniquePolicies.push(policyId);\n        }\n    });\n    const assetsByPolicy = [];\n    uniquePolicies.forEach(policyId => {\n        const assetsInPolicy = [];\n        assets.forEach(asset => {\n            const assetInfo = parseAsset(asset.unit);\n            if (assetInfo.policyId !== policyId)\n                return;\n            assetsInPolicy.push({\n                assetNameBytes: assetInfo.assetNameInHex,\n                amount: asset.quantity,\n            });\n        }),\n            assetsByPolicy.push({\n                policyId,\n                tokenAmounts: assetsInPolicy,\n            });\n    });\n    return assetsByPolicy;\n};\nexport const transformToTrezorInputs = (utxos, trezorUtxos) => {\n    return utxos.map(utxo => {\n        const utxoWithPath = trezorUtxos.find(u => u.txid === utxo.txHash && u.vout === utxo.outputIndex);\n        // shouldn't happen since utxos should be subset of trezorUtxos (with different shape/fields)\n        if (!utxoWithPath)\n            throw Error(`Cannot transform utxo ${utxo.txHash}:${utxo.outputIndex}`);\n        return {\n            path: utxoWithPath.path,\n            prev_hash: utxo.txHash,\n            prev_index: utxo.outputIndex,\n        };\n    });\n};\nexport const transformToTrezorOutputs = (outputs, changeAddressParameters) => {\n    return outputs.map(output => {\n        let params;\n        if (output.isChange) {\n            params = {\n                addressParameters: changeAddressParameters,\n            };\n        }\n        else {\n            params = {\n                address: output.address,\n            };\n        }\n        return Object.assign(Object.assign({}, params), { amount: output.amount, tokenBundle: transformToTokenBundle(output.assets) });\n    });\n};\n","export var CardanoTxWitnessType;\n(function (CardanoTxWitnessType) {\n    CardanoTxWitnessType[CardanoTxWitnessType[\"BYRON_WITNESS\"] = 0] = \"BYRON_WITNESS\";\n    CardanoTxWitnessType[CardanoTxWitnessType[\"SHELLEY_WITNESS\"] = 1] = \"SHELLEY_WITNESS\";\n})(CardanoTxWitnessType || (CardanoTxWitnessType = {}));\n","import * as CardanoWasm from '@emurgo/cardano-serialization-lib-asmjs';\nimport { CardanoTxWitnessType, } from '../../types/trezor';\nimport { getProtocolMagic } from '../common';\nexport const signTransaction = (txBodyHex, \n// txMetadata: CardanoWasm.AuxiliaryData,\nsignedWitnesses, options) => {\n    const txBody = CardanoWasm.TransactionBody.from_bytes(Uint8Array.from(Buffer.from(txBodyHex, 'hex')));\n    const witnesses = CardanoWasm.TransactionWitnessSet.new();\n    const vkeyWitnesses = CardanoWasm.Vkeywitnesses.new();\n    const bootstrapWitnesses = CardanoWasm.BootstrapWitnesses.new();\n    signedWitnesses.forEach(w => {\n        const vKey = CardanoWasm.Vkey.new(CardanoWasm.PublicKey.from_bytes(Buffer.from(w.pubKey, 'hex')));\n        const signature = CardanoWasm.Ed25519Signature.from_bytes(Buffer.from(w.signature, 'hex'));\n        if (w.type === CardanoTxWitnessType.SHELLEY_WITNESS) {\n            // Shelley witness\n            const vKeyWitness = CardanoWasm.Vkeywitness.new(vKey, signature);\n            vkeyWitnesses.add(vKeyWitness);\n        }\n        else if (w.type === CardanoTxWitnessType.BYRON_WITNESS) {\n            // Byron witness (TODO: not used, needs testing)\n            if (w.chainCode) {\n                const xpubHex = `${w.pubKey}${w.chainCode}`;\n                const bip32Key = CardanoWasm.Bip32PublicKey.from_bytes(Buffer.from(xpubHex, 'hex'));\n                const byronAddress = CardanoWasm.ByronAddress.icarus_from_key(bip32Key, getProtocolMagic(!!(options === null || options === void 0 ? void 0 : options.testnet)));\n                const bootstrapWitness = CardanoWasm.BootstrapWitness.new(vKey, signature, Buffer.from(w.chainCode, 'hex'), byronAddress.attributes());\n                bootstrapWitnesses.add(bootstrapWitness);\n            }\n        }\n    });\n    if (bootstrapWitnesses.len() > 0) {\n        witnesses.set_bootstraps(bootstrapWitnesses);\n    }\n    if (vkeyWitnesses.len() > 0) {\n        witnesses.set_vkeys(vkeyWitnesses);\n    }\n    if (options === null || options === void 0 ? void 0 : options.signOnly) {\n        return Promise.resolve(Buffer.from(witnesses.to_bytes(), 'utf8').toString('hex'));\n    }\n    const transaction = CardanoWasm.Transaction.new(txBody, witnesses);\n    const serializedTx = Buffer.from(transaction.to_bytes()).toString('hex');\n    return Promise.resolve(serializedTx);\n};\n","import BigNumber from 'bignumber.js';\nimport { coinSelection } from '../../index';\nimport { getLogger } from '../logger';\nexport const composeTxPlan = (transferInfo, accountXpub, utxos, changeAddress, outputs, options) => {\n    var _a;\n    const logger = getLogger(!!(options === null || options === void 0 ? void 0 : options.debug));\n    const transformUtxos = utxos.map(utxo => {\n        var _a;\n        return (Object.assign(Object.assign({}, utxo), { txHash: utxo.tx_hash, outputIndex: utxo.output_index, address: (_a = utxo.address) !== null && _a !== void 0 ? _a : transferInfo.from }));\n    });\n    try {\n        const txPlan = coinSelection({\n            utxos: transformUtxos,\n            outputs: outputs,\n            changeAddress,\n            certificates: [],\n            withdrawals: [],\n            accountPubKey: accountXpub,\n        }, {\n            debug: (_a = options === null || options === void 0 ? void 0 : options.debug) !== null && _a !== void 0 ? _a : false,\n        });\n        return Promise.resolve(txPlan);\n    }\n    catch (err) {\n        if ((err === null || err === void 0 ? void 0 : err.code) === 'UTXO_BALANCE_INSUFFICIENT') {\n            logger.debug('UTxO balance insufficient');\n            if (outputs.length === 1) {\n                const fixedOutput = [...outputs];\n                const amountBN = new BigNumber(outputs[0].amount);\n                const oneLovelace = new BigNumber('100000');\n                if (amountBN.gte(oneLovelace)) {\n                    fixedOutput[0].amount = amountBN.minus(oneLovelace).toFixed();\n                    return composeTxPlan(transferInfo, accountXpub, utxos, changeAddress, fixedOutput);\n                }\n            }\n            throw err;\n        }\n        else {\n            throw err;\n        }\n    }\n};\n","export const TxSignError = {\n    ProofGeneration: {\n        code: 1,\n        info: 'User has accepted the transaction sign, but the wallet was unable to sign the transaction (e.g. not having some of the private keys).',\n    },\n    UserDeclined: { code: 2, info: 'User declined to sign the transaction.' },\n};\nexport const DataSignError = {\n    ProofGeneration: {\n        code: 1,\n        info: 'Wallet could not sign the data (e.g. does not have the secret key associated with the address).',\n    },\n    AddressNotPK: {\n        code: 2,\n        info: 'Address was not a P2PK address or Reward address and thus had no SK associated with it.',\n    },\n    UserDeclined: { code: 3, info: 'User declined to sign the data.' },\n    InvalidFormat: {\n        code: 4,\n        info: 'If a wallet enforces data format requirements, this error signifies that the data did not conform to valid formats.',\n    },\n};\n","import * as CardanoWasm from '@emurgo/cardano-serialization-lib-asmjs';\nimport { TxSignError } from './error';\nexport const signTransaction = async (txBodyHex, address, accountIndex, utxos, xprv, signOnly, partialSign) => {\n    const { paymentKey, stakeKey, accountKey } = await requestAccountKey(xprv, accountIndex);\n    const serializedUtxos = await getUtxos(address, utxos);\n    if (!serializedUtxos || serializedUtxos === null) {\n        throw new Error('no utxos');\n    }\n    const transactionWitnessSet = CardanoWasm.TransactionWitnessSet.new();\n    const rawTx = CardanoWasm.Transaction.new(CardanoWasm.TransactionBody.from_hex(txBodyHex), CardanoWasm.TransactionWitnessSet.from_bytes(transactionWitnessSet.to_bytes()));\n    const keyHashes = await getKeyHashes(rawTx, serializedUtxos, { paymentAddr: address });\n    const witnessSet = await signTx({ paymentKey, stakeKey, accountKey }, Buffer.from(rawTx.to_bytes(), 'utf8').toString('hex'), keyHashes.key, partialSign);\n    if (signOnly) {\n        return {\n            signedTx: Buffer.from(witnessSet.to_bytes(), 'utf8').toString('hex'),\n            txid: '',\n        };\n    }\n    const transaction = CardanoWasm.Transaction.new(rawTx.body(), witnessSet, rawTx.auxiliary_data());\n    const signedTx = Buffer.from(transaction.to_bytes(), 'hex').toString('hex');\n    const hash = CardanoWasm.hash_transaction(transaction.body()).to_hex();\n    return {\n        signedTx,\n        txid: hash,\n    };\n};\n/**\n *\n * @param {string} tx - cbor hex string\n * @param {Array<string>} keyHashes\n * @param {string} password\n * @returns {string} witness set as hex string\n */\nexport const signTx = async (keys, tx, keyHashes, partialSign = false) => {\n    const { paymentKey, stakeKey } = keys;\n    const paymentKeyHash = Buffer.from(paymentKey === null || paymentKey === void 0 ? void 0 : paymentKey.to_public().hash().to_bytes(), 'hex').toString('hex');\n    const stakeKeyHash = Buffer.from(stakeKey.to_public().hash().to_bytes(), 'hex').toString('hex');\n    const rawTx = CardanoWasm.Transaction.from_bytes(Buffer.from(tx, 'hex'));\n    const txWitnessSet = CardanoWasm.TransactionWitnessSet.new();\n    const vkeyWitnesses = CardanoWasm.Vkeywitnesses.new();\n    const txHash = CardanoWasm.hash_transaction(rawTx.body());\n    keyHashes.forEach(keyHash => {\n        let signingKey;\n        if (keyHash === paymentKeyHash)\n            signingKey = paymentKey;\n        else if (keyHash === stakeKeyHash)\n            signingKey = stakeKey;\n        else if (!partialSign)\n            throw TxSignError.ProofGeneration;\n        else\n            return;\n        const vkey = CardanoWasm.make_vkey_witness(txHash, signingKey);\n        vkeyWitnesses.add(vkey);\n    });\n    stakeKey.free();\n    // stakeKey = null;\n    paymentKey.free();\n    // paymentKey = null;\n    txWitnessSet.set_vkeys(vkeyWitnesses);\n    return txWitnessSet;\n};\nconst getKeyHashes = async (tx, utxos, account) => {\n    var _a, _b, _c, _d;\n    let requiredKeyHashes = [];\n    const baseAddr = CardanoWasm.BaseAddress.from_address(CardanoWasm.Address.from_bech32(account.paymentAddr));\n    if (!baseAddr)\n        return { key: [], keyKind: [] };\n    const paymentKeyHash = Buffer.from((_b = (_a = baseAddr.payment_cred().to_keyhash()) === null || _a === void 0 ? void 0 : _a.to_bytes()) !== null && _b !== void 0 ? _b : '').toString('hex');\n    const stakeKeyHash = Buffer.from((_d = (_c = baseAddr.stake_cred().to_keyhash()) === null || _c === void 0 ? void 0 : _c.to_bytes()) !== null && _d !== void 0 ? _d : '').toString('hex');\n    //get key hashes from inputs\n    const inputs = tx.body().inputs();\n    for (let i = 0; i < inputs.len(); i++) {\n        const input = inputs.get(i);\n        const txHash = Buffer.from(input.transaction_id().to_bytes()).toString('hex');\n        const index = input.index();\n        if (utxos.some(utxo => Buffer.from(utxo.input().transaction_id().to_bytes()).toString('hex') === txHash && utxo.input().index() === index)) {\n            requiredKeyHashes.push(paymentKeyHash);\n        }\n        else {\n            requiredKeyHashes.push('<not_owned_key_hash>');\n        }\n    }\n    //get key hashes from certificates\n    const txBody = tx.body();\n    const keyHashFromCert = txBody => {\n        for (let i = 0; i < txBody.certs().len(); i++) {\n            const cert = txBody.certs().get(i);\n            if (cert.kind() === 0) {\n                const credential = cert.as_stake_registration().stake_credential();\n                if (credential.kind() === 0) {\n                    // stake registration doesn't required key hash\n                }\n            }\n            else if (cert.kind() === 1) {\n                const credential = cert.as_stake_deregistration().stake_credential();\n                if (credential.kind() === 0) {\n                    const keyHash = Buffer.from(credential.to_keyhash().to_bytes()).toString('hex');\n                    requiredKeyHashes.push(keyHash);\n                }\n            }\n            else if (cert.kind() === 2) {\n                const credential = cert.as_stake_delegation().stake_credential();\n                if (credential.kind() === 0) {\n                    const keyHash = Buffer.from(credential.to_keyhash().to_bytes()).toString('hex');\n                    requiredKeyHashes.push(keyHash);\n                }\n            }\n            else if (cert.kind() === 3) {\n                const owners = cert.as_pool_registration().pool_params().pool_owners();\n                for (let i = 0; i < owners.len(); i++) {\n                    const keyHash = Buffer.from(owners.get(i).to_bytes()).toString('hex');\n                    requiredKeyHashes.push(keyHash);\n                }\n            }\n            else if (cert.kind() === 4) {\n                const operator = cert.as_pool_retirement().pool_keyhash().to_hex();\n                requiredKeyHashes.push(operator);\n            }\n            else if (cert.kind() === 6) {\n                const instant_reward = cert\n                    .as_move_instantaneous_rewards_cert()\n                    .move_instantaneous_reward()\n                    .as_to_stake_creds()\n                    .keys();\n                for (let i = 0; i < instant_reward.len(); i++) {\n                    const credential = instant_reward.get(i);\n                    if (credential.kind() === 0) {\n                        const keyHash = Buffer.from(credential.to_keyhash().to_bytes()).toString('hex');\n                        requiredKeyHashes.push(keyHash);\n                    }\n                }\n            }\n        }\n    };\n    if (txBody.certs())\n        keyHashFromCert(txBody);\n    // key hashes from withdrawals\n    const withdrawals = txBody.withdrawals();\n    const keyHashFromWithdrawal = withdrawals => {\n        const rewardAddresses = withdrawals.keys();\n        for (let i = 0; i < rewardAddresses.len(); i++) {\n            const credential = rewardAddresses.get(i).payment_cred();\n            if (credential.kind() === 0) {\n                requiredKeyHashes.push(credential.to_keyhash().to_hex());\n            }\n        }\n    };\n    if (withdrawals)\n        keyHashFromWithdrawal(withdrawals);\n    //get key hashes from scripts\n    const scripts = tx.witness_set().native_scripts();\n    const keyHashFromScript = scripts => {\n        for (let i = 0; i < scripts.len(); i++) {\n            const script = scripts.get(i);\n            if (script.kind() === 0) {\n                const keyHash = Buffer.from(script.as_script_pubkey().addr_keyhash().to_bytes()).toString('hex');\n                requiredKeyHashes.push(keyHash);\n            }\n            if (script.kind() === 1) {\n                return keyHashFromScript(script.as_script_all().native_scripts());\n            }\n            if (script.kind() === 2) {\n                return keyHashFromScript(script.as_script_any().native_scripts());\n            }\n            if (script.kind() === 3) {\n                return keyHashFromScript(script.as_script_n_of_k().native_scripts());\n            }\n        }\n    };\n    if (scripts)\n        keyHashFromScript(scripts);\n    //get keyHashes from required signers\n    const requiredSigners = tx.body().required_signers();\n    if (requiredSigners) {\n        for (let i = 0; i < requiredSigners.len(); i++) {\n            requiredKeyHashes.push(Buffer.from(requiredSigners.get(i).to_bytes()).toString('hex'));\n        }\n    }\n    //get keyHashes from collateral\n    const collateral = txBody.collateral();\n    if (collateral) {\n        // TODO: Collateral KeyHashed\n        // for (let i = 0; i < collateral.len(); i++) {\n        //   const c = collateral.get(i);\n        //   const utxo = await getSpecificUtxo(\n        //     Buffer.from(c.transaction_id().to_bytes()).toString('hex'),\n        //     c.index(),\n        //   );\n        //   if (utxo) {\n        //     const address = CardanoWasm.Address.from_bech32(utxo.address);\n        //     requiredKeyHashes.push(await getPaymentKeyHash(address));\n        //   }\n        // }\n    }\n    const keyKind = [];\n    requiredKeyHashes = [...new Set(requiredKeyHashes)];\n    if (requiredKeyHashes.includes(paymentKeyHash))\n        keyKind.push('payment');\n    if (requiredKeyHashes.includes(stakeKeyHash))\n        keyKind.push('stake');\n    return {\n        key: requiredKeyHashes,\n        keyKind,\n    };\n};\nexport const getUtxos = async (address, utxos) => {\n    const paymentAddr = getPaymentHexAddress(address);\n    const converted = utxos.map(utxo => utxoFromJson(utxo, paymentAddr));\n    if (converted.length <= 0) {\n        return null;\n    }\n    return Promise.resolve(converted);\n};\nconst getPaymentHexAddress = (address) => {\n    const paymentAddr = Buffer.from(CardanoWasm.Address.from_bech32(address).to_bytes(), 'hex').toString('hex');\n    return paymentAddr;\n};\n/**\n *\n * @param {JSON} output\n * @param {BaseAddress} address\n * @returns\n */\nconst utxoFromJson = (output, address) => CardanoWasm.TransactionUnspentOutput.new(CardanoWasm.TransactionInput.new(CardanoWasm.TransactionHash.from_bytes(Buffer.from(output.tx_hash, 'hex')), Number(output.output_index)), CardanoWasm.TransactionOutput.new(CardanoWasm.Address.from_bytes(Buffer.from(address, 'hex')), assetsToValue(output.amount)));\nconst assetsToValue = (assets) => {\n    const multiAsset = CardanoWasm.MultiAsset.new();\n    const lovelace = assets.find(asset => asset.unit === 'lovelace');\n    const policies = [\n        ...new Set(assets\n            .filter(asset => asset.unit !== 'lovelace')\n            .map(asset => asset.unit.slice(0, 56))),\n    ];\n    policies.forEach(policy => {\n        const policyAssets = assets.filter(asset => asset.unit.slice(0, 56) === policy);\n        const assetsValue = CardanoWasm.Assets.new();\n        policyAssets.forEach(asset => {\n            assetsValue.insert(CardanoWasm.AssetName.new(Buffer.from(asset.unit.slice(56), 'hex')), CardanoWasm.BigNum.from_str(asset.quantity));\n        });\n        multiAsset.insert(CardanoWasm.ScriptHash.from_bytes(Buffer.from(policy, 'hex')), assetsValue);\n    });\n    const value = CardanoWasm.Value.new(CardanoWasm.BigNum.from_str(lovelace ? lovelace.quantity : '0'));\n    if (assets.length > 1 || !lovelace) {\n        value.set_multiasset(multiAsset);\n    }\n    return value;\n};\nconst harden = (num) => {\n    return 0x80000000 + num;\n};\nexport const requestAccountKey = async (xprv, accountIndex) => {\n    let accountKey;\n    try {\n        accountKey = CardanoWasm.Bip32PrivateKey.from_bech32(xprv)\n            .derive(harden(1852)) // purpose\n            .derive(harden(1815)) // coin type;\n            .derive(harden(parseInt(`${accountIndex}`)));\n    }\n    catch (e) {\n        throw new Error('Wrong private key');\n    }\n    return {\n        accountKey,\n        paymentKey: accountKey.derive(0).derive(0).to_raw_key(),\n        stakeKey: accountKey.derive(2).derive(0).to_raw_key(),\n    };\n};\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport * as CardanoWasm from '@emurgo/cardano-serialization-lib-asmjs';\nimport * as CardanoMessage from '@emurgo/cardano-message-signing-asmjs/cardano_message_signing';\nimport BigNumber from 'bignumber.js';\nimport { getUtxos as getRawUtxos, requestAccountKey } from './signTx';\nimport { DataSignError } from './error';\nconst getBalance = async (balances) => {\n    const value = await assetsToValue(balances);\n    return Buffer.from(value.to_bytes(), 'hex').toString('hex');\n};\nexport const assetsToValue = async (assets) => {\n    const multiAsset = CardanoWasm.MultiAsset.new();\n    const lovelace = assets.find(asset => asset.unit === 'lovelace');\n    const policies = [\n        ...new Set(assets\n            .filter(asset => asset.unit !== 'lovelace')\n            .map(asset => asset.unit.slice(0, 56))),\n    ];\n    policies.forEach(policy => {\n        const policyAssets = assets.filter(asset => asset.unit.slice(0, 56) === policy);\n        const assetsValue = CardanoWasm.Assets.new();\n        policyAssets.forEach(asset => {\n            assetsValue.insert(CardanoWasm.AssetName.new(Buffer.from(asset.unit.slice(56), 'hex')), CardanoWasm.BigNum.from_str(asset.quantity));\n        });\n        multiAsset.insert(CardanoWasm.ScriptHash.from_bytes(Buffer.from(policy, 'hex')), assetsValue);\n    });\n    const value = CardanoWasm.Value.new(CardanoWasm.BigNum.from_str(lovelace ? lovelace.quantity : '0'));\n    if (assets.length > 1 || !lovelace)\n        value.set_multiasset(multiAsset);\n    return value;\n};\nconst getAddresses = async (addresses) => {\n    return addresses.map(address => {\n        const addr = Buffer.from(CardanoWasm.Address.from_bech32(address).to_bytes(), 'hex').toString('hex');\n        return addr;\n    });\n};\nconst getUtxos = async (address, utxos, amount) => {\n    let converted = await getRawUtxos(address, utxos);\n    // filter utxos\n    if (amount) {\n        let filterVaule;\n        try {\n            filterVaule = CardanoWasm.Value.from_bytes(Buffer.from(amount, 'hex'));\n        }\n        catch (e) {\n            throw new Error('Invalid Request');\n        }\n        converted = converted === null || converted === void 0 ? void 0 : converted.filter(unspent => !unspent.output().amount().compare(filterVaule) ||\n            unspent.output().amount().compare(filterVaule) !== -1);\n    }\n    if (amount && Array.isArray(converted) && converted.length <= 0) {\n        return null;\n    }\n    return converted === null || converted === void 0 ? void 0 : converted.map(utxo => Buffer.from(utxo.to_bytes(), 'hex').toString('hex'));\n};\nconst convertCborTxToEncodeTx = async (txHex, utxos, addresses, changeAddress) => {\n    var _a, _b;\n    const tx = CardanoWasm.Transaction.from_bytes(Buffer.from(txHex, 'hex'));\n    const body = tx.body();\n    // Fee\n    const fee = body.fee().to_str();\n    const totalFeeInNative = new BigNumber(fee).shiftedBy(-1 * 6).toFixed();\n    // inputs txs\n    const encodeInputs = [];\n    const inputs = [];\n    const inputsLen = body.inputs().len();\n    for (let i = 0; i < inputsLen; i++) {\n        const input = body.inputs().get(i);\n        const txHash = Buffer.from(input.transaction_id().to_bytes(), 'utf8').toString('hex');\n        const index = input.index();\n        inputs.push({ tx_hash: txHash, tx_index: index });\n        const utxo = utxos.find(utxo => utxo.tx_hash === txHash && +utxo.tx_index === +index);\n        encodeInputs.push(utxo);\n    }\n    // outputs txs\n    const outputs = [];\n    const outputsLen = body.outputs().len();\n    for (let i = 0; i < outputsLen; i++) {\n        const output = body.outputs().get(i);\n        const address = output.address().to_bech32();\n        const amount = output.amount().coin().to_str();\n        // get the asset from output\n        const assetsArray = [];\n        const multiasset = output.amount().multiasset();\n        if (multiasset) {\n            const keys = multiasset.keys(); // policy Ids of thee multiasset\n            const N = keys.len();\n            // (`${N} Multiassets in the UTXO`)\n            for (let i = 0; i < N; i++) {\n                const policyId = keys.get(i);\n                const policyIdHex = Buffer.from(policyId.to_bytes(), 'utf8').toString('hex');\n                const assets = multiasset.get(policyId);\n                if (assets) {\n                    const assetNames = assets.keys();\n                    const K = assetNames.len();\n                    for (let j = 0; j < K; j++) {\n                        const assetName = assetNames.get(j);\n                        const assetNameHex = Buffer.from(assetName.name(), 'utf8').toString('hex');\n                        const multiassetAmt = multiasset.get_asset(policyId, assetName);\n                        assetsArray.push({\n                            unit: `${policyIdHex}${assetNameHex}`,\n                            quantity: multiassetAmt.to_str(),\n                        });\n                    }\n                }\n            }\n        }\n        // isChange: outputs length > 0 && address === changeAddress.address\n        const isChange = i > 0 && address === changeAddress.address;\n        outputs.push({\n            amount: amount,\n            address: address,\n            assets: assetsArray,\n            isChange,\n        });\n    }\n    const totalSpent = BigNumber.sum(...outputs.map(o => o.amount)).toFixed();\n    const token = (_b = (_a = outputs\n        .filter(o => !addresses.includes(o.address))\n        .find(o => o.assets.length > 0)) === null || _a === void 0 ? void 0 : _a.assets) === null || _b === void 0 ? void 0 : _b[0].unit;\n    const encodedTx = {\n        inputs: encodeInputs.map(input => (Object.assign(Object.assign({}, input), { txHash: input.tx_hash, outputIndex: input.tx_index }))),\n        outputs,\n        fee,\n        totalSpent,\n        totalFeeInNative,\n        transferInfo: {\n            from: encodeInputs[0].address,\n            to: outputs[0].address,\n            amount: totalSpent,\n            token,\n        },\n        tx: {\n            body: body.to_hex(),\n            hash: Buffer.from(CardanoWasm.hash_transaction(body).to_bytes(), 'utf8').toString('hex'),\n            size: 0,\n            rawTxHex: txHex,\n        },\n        signOnly: true,\n    };\n    console.log('Cardano DApp EncodedTx: ', encodedTx);\n    return encodedTx;\n};\nconst signData = async (address, payload, xprv, accountIndex) => {\n    const keyHash = await extractKeyHash(address);\n    if (!keyHash) {\n        throw DataSignError.InvalidFormat;\n    }\n    const prefix = keyHash.startsWith('addr_vkh') ? 'addr_vkh' : 'stake_vkh';\n    const { paymentKey, stakeKey } = await requestAccountKey(xprv, accountIndex);\n    const accountKey = prefix === 'addr_vkh' ? paymentKey : stakeKey;\n    const publicKey = accountKey.to_public();\n    if (keyHash !== publicKey.hash().to_bech32(prefix))\n        throw DataSignError.ProofGeneration;\n    const protectedHeaders = CardanoMessage.HeaderMap.new();\n    protectedHeaders.set_algorithm_id(CardanoMessage.Label.from_algorithm_id(CardanoMessage.AlgorithmId.EdDSA));\n    // protectedHeaders.set_key_id(publicKey.as_bytes()); // Removed to adhere to CIP-30\n    protectedHeaders.set_header(CardanoMessage.Label.new_text('address'), CardanoMessage.CBORValue.new_bytes(Buffer.from(address, 'hex')));\n    const protectedSerialized = CardanoMessage.ProtectedHeaderMap.new(protectedHeaders);\n    const unprotectedHeaders = CardanoMessage.HeaderMap.new();\n    const headers = CardanoMessage.Headers.new(protectedSerialized, unprotectedHeaders);\n    const builder = CardanoMessage.COSESign1Builder.new(headers, Buffer.from(payload, 'hex'), false);\n    const toSign = builder.make_data_to_sign().to_bytes();\n    const signedSigStruc = accountKey.sign(toSign).to_bytes();\n    const coseSign1 = builder.build(signedSigStruc);\n    stakeKey.free();\n    paymentKey.free();\n    const key = CardanoMessage.COSEKey.new(CardanoMessage.Label.from_key_type(CardanoMessage.KeyType.OKP));\n    key.set_algorithm_id(CardanoMessage.Label.from_algorithm_id(CardanoMessage.AlgorithmId.EdDSA));\n    key.set_header(CardanoMessage.Label.new_int(CardanoMessage.Int.new_negative(CardanoMessage.BigNum.from_str('1'))), CardanoMessage.CBORValue.new_int(CardanoMessage.Int.new_i32(6))); // crv (-1) set to Ed25519 (6)\n    key.set_header(CardanoMessage.Label.new_int(CardanoMessage.Int.new_negative(CardanoMessage.BigNum.from_str('2'))), CardanoMessage.CBORValue.new_bytes(publicKey.as_bytes())); // x (-2) set to public key\n    return {\n        signature: Buffer.from(coseSign1.to_bytes()).toString('hex'),\n        key: Buffer.from(key.to_bytes()).toString('hex'),\n    };\n};\nexport const extractKeyHash = async (address) => {\n    var _a;\n    try {\n        const addr = CardanoWasm.BaseAddress.from_address(CardanoWasm.Address.from_bytes(Buffer.from(address, 'hex')));\n        return (_a = addr.payment_cred()) === null || _a === void 0 ? void 0 : _a.to_keyhash().to_bech32('addr_vkh');\n    }\n    catch (e) {\n        // ignore\n    }\n    try {\n        const addr = CardanoWasm.EnterpriseAddress.from_address(CardanoWasm.Address.from_bytes(Buffer.from(address, 'hex')));\n        return addr.payment_cred().to_keyhash().to_bech32('addr_vkh');\n    }\n    catch (e) {\n        // ignore\n    }\n    try {\n        const addr = CardanoWasm.PointerAddress.from_address(CardanoWasm.Address.from_bytes(Buffer.from(address, 'hex')));\n        return addr.payment_cred().to_keyhash().to_bech32('addr_vkh');\n    }\n    catch (e) {\n        // ignore\n    }\n    try {\n        const addr = CardanoWasm.RewardAddress.from_address(CardanoWasm.Address.from_bytes(Buffer.from(address, 'hex')));\n        return addr.payment_cred().to_keyhash().to_bech32('stake_vkh');\n    }\n    catch (e) {\n        // ignore\n    }\n    throw DataSignError.AddressNotPK;\n};\nexport const dAppUtils = {\n    getBalance,\n    getAddresses,\n    getUtxos,\n    convertCborTxToEncodeTx,\n    signData,\n};\n","// @ts-nocheck\nimport * as CardanoWasm from '@emurgo/cardano-serialization-lib-asmjs';\nexport var CardanoAddressType;\n(function (CardanoAddressType) {\n    CardanoAddressType[CardanoAddressType[\"BASE\"] = 0] = \"BASE\";\n    CardanoAddressType[CardanoAddressType[\"BASE_SCRIPT_KEY\"] = 1] = \"BASE_SCRIPT_KEY\";\n    CardanoAddressType[CardanoAddressType[\"BASE_KEY_SCRIPT\"] = 2] = \"BASE_KEY_SCRIPT\";\n    CardanoAddressType[CardanoAddressType[\"BASE_SCRIPT_SCRIPT\"] = 3] = \"BASE_SCRIPT_SCRIPT\";\n    CardanoAddressType[CardanoAddressType[\"POINTER\"] = 4] = \"POINTER\";\n    CardanoAddressType[CardanoAddressType[\"POINTER_SCRIPT\"] = 5] = \"POINTER_SCRIPT\";\n    CardanoAddressType[CardanoAddressType[\"ENTERPRISE\"] = 6] = \"ENTERPRISE\";\n    CardanoAddressType[CardanoAddressType[\"ENTERPRISE_SCRIPT\"] = 7] = \"ENTERPRISE_SCRIPT\";\n    CardanoAddressType[CardanoAddressType[\"BYRON\"] = 8] = \"BYRON\";\n    CardanoAddressType[CardanoAddressType[\"REWARD\"] = 14] = \"REWARD\";\n    CardanoAddressType[CardanoAddressType[\"REWARD_SCRIPT\"] = 15] = \"REWARD_SCRIPT\";\n})(CardanoAddressType || (CardanoAddressType = {}));\nexport var CardanoTxSigningMode;\n(function (CardanoTxSigningMode) {\n    CardanoTxSigningMode[CardanoTxSigningMode[\"ORDINARY_TRANSACTION\"] = 0] = \"ORDINARY_TRANSACTION\";\n    CardanoTxSigningMode[CardanoTxSigningMode[\"POOL_REGISTRATION_AS_OWNER\"] = 1] = \"POOL_REGISTRATION_AS_OWNER\";\n    CardanoTxSigningMode[CardanoTxSigningMode[\"MULTISIG_TRANSACTION\"] = 2] = \"MULTISIG_TRANSACTION\";\n    CardanoTxSigningMode[CardanoTxSigningMode[\"PLUTUS_TRANSACTION\"] = 3] = \"PLUTUS_TRANSACTION\";\n})(CardanoTxSigningMode || (CardanoTxSigningMode = {}));\nexport var CardanoCertificateType;\n(function (CardanoCertificateType) {\n    CardanoCertificateType[CardanoCertificateType[\"STAKE_REGISTRATION\"] = 0] = \"STAKE_REGISTRATION\";\n    CardanoCertificateType[CardanoCertificateType[\"STAKE_DEREGISTRATION\"] = 1] = \"STAKE_DEREGISTRATION\";\n    CardanoCertificateType[CardanoCertificateType[\"STAKE_DELEGATION\"] = 2] = \"STAKE_DELEGATION\";\n    CardanoCertificateType[CardanoCertificateType[\"STAKE_POOL_REGISTRATION\"] = 3] = \"STAKE_POOL_REGISTRATION\";\n})(CardanoCertificateType || (CardanoCertificateType = {}));\nexport var CardanoPoolRelayType;\n(function (CardanoPoolRelayType) {\n    CardanoPoolRelayType[CardanoPoolRelayType[\"SINGLE_HOST_IP\"] = 0] = \"SINGLE_HOST_IP\";\n    CardanoPoolRelayType[CardanoPoolRelayType[\"SINGLE_HOST_NAME\"] = 1] = \"SINGLE_HOST_NAME\";\n    CardanoPoolRelayType[CardanoPoolRelayType[\"MULTIPLE_HOST_NAME\"] = 2] = \"MULTIPLE_HOST_NAME\";\n})(CardanoPoolRelayType || (CardanoPoolRelayType = {}));\nconst generateKeys = (keys, xpub) => {\n    const publicKey = CardanoWasm.Bip32PublicKey.from_bytes(Buffer.from(xpub, 'hex'));\n    const paymentKeyHashRaw = publicKey.derive(0).derive(0).to_raw_key().hash();\n    const stakeKeyHashRaw = publicKey.derive(2).derive(0).to_raw_key().hash();\n    const paymentKeyHash = Buffer.from(paymentKeyHashRaw.to_bytes()).toString('hex');\n    const stakeKeyHash = Buffer.from(stakeKeyHashRaw.to_bytes()).toString('hex');\n    return {\n        payment: Object.assign(Object.assign({}, keys.payment), { hash: paymentKeyHash }),\n        stake: Object.assign(Object.assign({}, keys.stake), { hash: stakeKeyHash }),\n    };\n};\nconst outputsToOneKey = (outputs, changeAddress) => {\n    const onekeyOutputs = [];\n    for (let i = 0; i < outputs.len(); i++) {\n        const output = outputs.get(i);\n        const multiAsset = output.amount().multiasset();\n        let tokenBundle = null;\n        if (multiAsset) {\n            tokenBundle = [];\n            for (let j = 0; j < multiAsset.keys().len(); j++) {\n                const policy = multiAsset.keys().get(j);\n                const assets = multiAsset.get(policy);\n                const tokens = [];\n                for (let k = 0; k < assets.keys().len(); k++) {\n                    const assetName = assets.keys().get(k);\n                    const amount = assets.get(assetName).to_str();\n                    tokens.push({\n                        assetNameBytes: Buffer.from(assetName.name()).toString('hex'),\n                        amount,\n                    });\n                }\n                // sort canonical\n                tokens.sort((a, b) => {\n                    if (a.assetNameBytes.length == b.assetNameBytes.length) {\n                        return a.assetNameBytes > b.assetNameBytes ? 1 : -1;\n                    }\n                    else if (a.assetNameBytes.length > b.assetNameBytes.length)\n                        return 1;\n                    else\n                        return -1;\n                });\n                tokenBundle.push({\n                    policyId: Buffer.from(policy.to_bytes()).toString('hex'),\n                    tokenAmounts: tokens,\n                });\n            }\n        }\n        const outputAddressBech32 = output.address().to_bech32();\n        const outputAddressHuman = (() => {\n            try {\n                return CardanoWasm.BaseAddress.from_address(output.address())\n                    .to_address()\n                    .to_bech32();\n            }\n            catch (e) {\n                // ignore\n            }\n            try {\n                return CardanoWasm.EnterpriseAddress.from_address(output.address())\n                    .to_address()\n                    .to_bech32();\n            }\n            catch (e) {\n                // ignore\n            }\n            try {\n                return CardanoWasm.PointerAddress.from_address(output.address())\n                    .to_address()\n                    .to_bech32();\n            }\n            catch (e) {\n                // ignore\n            }\n            return CardanoWasm.ByronAddress.from_address(output.address()).to_base58();\n        })();\n        const destination = outputAddressBech32 === changeAddress.address\n            ? {\n                addressParameters: {\n                    addressType: CardanoAddressType.BASE,\n                    path: changeAddress.addressParameters.path,\n                    stakingPath: changeAddress.addressParameters.stakingPath,\n                },\n            }\n            : {\n                address: outputAddressHuman,\n            };\n        // https://github.com/dcSpark/cardano-multiplatform-lib/blob/c6a6d110065e98ed50640c7380d12748856608cf/chain/rust/src/transaction/mod.rs#L87\n        // https://github.com/dcSpark/cardano-multiplatform-lib/blob/c6a6d110065e98ed50640c7380d12748856608cf/chain/rust/src/transaction/mod.rs#L117-L136\n        // data_hash    : kind = 0\n        // plutus_data  : kind = 1\n        const datumHash = output.has_data_hash()\n            ? output.data_hash().to_hex()\n            : null;\n        const inlineDatum = output.has_plutus_data()\n            ? output.plutus_data().to_hex()\n            : null;\n        // const datumHash =\n        //   output.datum() && output.datum().kind() === 0\n        //     ? Buffer.from(output.datum().as_data_hash().to_bytes()).toString('hex')\n        //     : null;\n        // const inlineDatum =\n        //   output.datum() && output.datum().kind() === 1\n        //     ? Buffer.from(output.datum().as_data().get().to_bytes()).toString('hex')\n        //     : null;\n        const referenceScript = output.script_ref()\n            ? Buffer.from(output.script_ref().get().to_bytes()).toString('hex')\n            : null;\n        const outputRes = Object.assign({ amount: output.amount().coin().to_str(), tokenBundle,\n            datumHash, \n            // https://github.com/input-output-hk/nami/commit/a5f5a9357da81307bff9bc77ef2476f1746c134a#diff-1c7110974e24c349d96acac1989fe76c94b0031ab0f5a114e10823e5d74549deR421-R423\n            format: Buffer.from(output.to_bytes()).toString('hex').startsWith('a')\n                ? 1\n                : 0, inlineDatum,\n            referenceScript }, destination);\n        if (!tokenBundle)\n            delete outputRes.tokenBundle;\n        if (!datumHash)\n            delete outputRes.datumHash;\n        if (!inlineDatum)\n            delete outputRes.inlineDatum;\n        if (!referenceScript)\n            delete outputRes.referenceScript;\n        onekeyOutputs.push(outputRes);\n    }\n    return onekeyOutputs;\n};\n/**\n *\n * @param {Transaction} tx\n */\nexport const txToOneKey = async (rawTx, network, initKeys, xpub, changeAddress) => {\n    var _a;\n    const keys = generateKeys(initKeys, xpub);\n    const tx = CardanoWasm.Transaction.from_bytes(Buffer.from(rawTx, 'hex'));\n    let signingMode = CardanoTxSigningMode.ORDINARY_TRANSACTION;\n    const outputs = tx.body().outputs();\n    const onekeyOutputs = outputsToOneKey(outputs, changeAddress);\n    let onekeyCertificates = null;\n    const certificates = tx.body().certs();\n    if (certificates) {\n        onekeyCertificates = [];\n        for (let i = 0; i < certificates.len(); i++) {\n            const cert = certificates.get(i);\n            const certificate = {};\n            if (cert.kind() === 0) {\n                const credential = (_a = cert.as_stake_registration()) === null || _a === void 0 ? void 0 : _a.stake_credential();\n                certificate.type = CardanoCertificateType.STAKE_REGISTRATION;\n                if ((credential === null || credential === void 0 ? void 0 : credential.kind()) === 0) {\n                    certificate.path = keys.stake.path;\n                }\n                else {\n                    const scriptHash = Buffer.from(credential.to_scripthash().to_bytes()).toString('hex');\n                    certificate.scriptHash = scriptHash;\n                }\n            }\n            else if (cert.kind() === 1) {\n                const credential = cert.as_stake_deregistration().stake_credential();\n                certificate.type = CardanoCertificateType.STAKE_DEREGISTRATION;\n                if (credential.kind() === 0) {\n                    certificate.path = keys.stake.path;\n                }\n                else {\n                    const scriptHash = Buffer.from(credential.to_scripthash().to_bytes()).toString('hex');\n                    certificate.scriptHash = scriptHash;\n                }\n            }\n            else if (cert.kind() === 2) {\n                const delegation = cert.as_stake_delegation();\n                const credential = delegation.stake_credential();\n                const poolKeyHashHex = Buffer.from(delegation.pool_keyhash().to_bytes()).toString('hex');\n                certificate.type = CardanoCertificateType.STAKE_DELEGATION;\n                if (credential.kind() === 0) {\n                    certificate.path = keys.stake.path;\n                }\n                else {\n                    const scriptHash = Buffer.from(credential.to_scripthash().to_bytes()).toString('hex');\n                    certificate.scriptHash = scriptHash;\n                }\n                certificate.pool = poolKeyHashHex;\n            }\n            else if (cert.kind() === 3) {\n                const params = cert.as_pool_registration().pool_params();\n                certificate.type = CardanoCertificateType.STAKE_POOL_REGISTRATION;\n                const owners = params.pool_owners();\n                const poolOwners = [];\n                for (let i = 0; i < owners.len(); i++) {\n                    const keyHash = Buffer.from(owners.get(i).to_bytes()).toString('hex');\n                    if (keyHash == keys.stake.hash) {\n                        signingMode = CardanoTxSigningMode.POOL_REGISTRATION_AS_OWNER;\n                        poolOwners.push({\n                            stakingKeyPath: keys.stake.path,\n                        });\n                    }\n                    else {\n                        poolOwners.push({\n                            stakingKeyHash: keyHash,\n                        });\n                    }\n                }\n                const relays = params.relays();\n                const onekeyRelays = [];\n                for (let i = 0; i < relays.len(); i++) {\n                    const relay = relays.get(i);\n                    if (relay.kind() === 0) {\n                        const singleHostAddr = relay.as_single_host_addr();\n                        const type = CardanoPoolRelayType.SINGLE_HOST_IP;\n                        const port = singleHostAddr.port();\n                        const ipv4Address = singleHostAddr.ipv4()\n                            ? bytesToIp(singleHostAddr.ipv4().ip())\n                            : null;\n                        const ipv6Address = singleHostAddr.ipv6()\n                            ? bytesToIp(singleHostAddr.ipv6().ip())\n                            : null;\n                        onekeyRelays.push({ type, port, ipv4Address, ipv6Address });\n                    }\n                    else if (relay.kind() === 1) {\n                        const type = CardanoPoolRelayType.SINGLE_HOST_NAME;\n                        const singleHostName = relay.as_single_host_name();\n                        const port = singleHostName.port();\n                        const hostName = singleHostName.dns_name().record();\n                        onekeyRelays.push({\n                            type,\n                            port,\n                            hostName,\n                        });\n                    }\n                    else if (relay.kind() === 2) {\n                        const type = CardanoPoolRelayType.MULTIPLE_HOST_NAME;\n                        const multiHostName = relay.as_multi_host_name();\n                        const hostName = multiHostName.dns_name();\n                        onekeyRelays.push({\n                            type,\n                            hostName,\n                        });\n                    }\n                }\n                const cost = params.cost().to_str();\n                const margin = params.margin();\n                const pledge = params.pledge().to_str();\n                const poolId = Buffer.from(params.operator().to_bytes()).toString('hex');\n                const metadata = params.pool_metadata()\n                    ? {\n                        url: params.pool_metadata().url().url(),\n                        hash: Buffer.from(params.pool_metadata().pool_metadata_hash().to_bytes()).toString('hex'),\n                    }\n                    : null;\n                const rewardAccount = params.reward_account().to_address().to_bech32();\n                const vrfKeyHash = Buffer.from(params.vrf_keyhash().to_bytes()).toString('hex');\n                certificate.poolParameters = {\n                    poolId,\n                    vrfKeyHash,\n                    pledge,\n                    cost,\n                    margin: {\n                        numerator: margin.numerator().to_str(),\n                        denominator: margin.denominator().to_str(),\n                    },\n                    rewardAccount,\n                    owners: poolOwners,\n                    relays: onekeyRelays,\n                    metadata,\n                };\n            }\n            onekeyCertificates.push(certificate);\n        }\n    }\n    const fee = tx.body().fee().to_str();\n    const ttl = tx.body().ttl();\n    const withdrawals = tx.body().withdrawals();\n    let onekeyWithdrawals = null;\n    if (withdrawals) {\n        onekeyWithdrawals = [];\n        for (let i = 0; i < withdrawals.keys().len(); i++) {\n            const withdrawal = {};\n            const rewardAddress = withdrawals.keys().get(i);\n            if (rewardAddress.payment_cred().kind() === 0) {\n                withdrawal.path = keys.stake.path;\n            }\n            else {\n                withdrawal.scriptHash = Buffer.from(rewardAddress.payment_cred().to_scripthash().to_bytes()).toString('hex');\n            }\n            withdrawal.amount = withdrawals.get(rewardAddress).to_str();\n            onekeyWithdrawals.push(withdrawal);\n        }\n    }\n    const auxiliaryData = tx.body().auxiliary_data_hash()\n        ? {\n            hash: Buffer.from(tx.body().auxiliary_data_hash().to_bytes()).toString('hex'),\n        }\n        : null;\n    const validityIntervalStart = tx.body().validity_start_interval()\n        ? tx.body().validity_start_interval().to_str()\n        : null;\n    const mint = tx.body().mint();\n    let additionalWitnessRequests = null;\n    let mintBundle = null;\n    if (mint) {\n        mintBundle = [];\n        for (let j = 0; j < mint.keys().len(); j++) {\n            const policy = mint.keys().get(j);\n            const assets = mint.get(policy);\n            const tokens = [];\n            for (let k = 0; k < assets.keys().len(); k++) {\n                const assetName = assets.keys().get(k);\n                const amount = assets.get(assetName);\n                tokens.push({\n                    assetNameBytes: Buffer.from(assetName.name()).toString('hex'),\n                    mintAmount: amount.is_positive()\n                        ? amount.as_positive().to_str()\n                        : '-' + amount.as_negative().to_str(),\n                });\n            }\n            // sort canonical\n            tokens.sort((a, b) => {\n                if (a.assetNameBytes.length == b.assetNameBytes.length) {\n                    return a.assetNameBytes > b.assetNameBytes ? 1 : -1;\n                }\n                else if (a.assetNameBytes.length > b.assetNameBytes.length)\n                    return 1;\n                else\n                    return -1;\n            });\n            mintBundle.push({\n                policyId: Buffer.from(policy.to_bytes()).toString('hex'),\n                tokenAmounts: tokens,\n            });\n        }\n        additionalWitnessRequests = [];\n        if (keys.payment.path)\n            additionalWitnessRequests.push(keys.payment.path);\n        if (keys.stake.path)\n            additionalWitnessRequests.push(keys.stake.path);\n    }\n    // Plutus\n    const scriptDataHash = tx.body().script_data_hash()\n        ? Buffer.from(tx.body().script_data_hash().to_bytes()).toString('hex')\n        : null;\n    let collateralInputs = null;\n    if (tx.body().collateral()) {\n        collateralInputs = [];\n        const coll = tx.body().collateral();\n        for (let i = 0; i < coll.len(); i++) {\n            const input = coll.get(i);\n            if (keys.payment.path) {\n                collateralInputs.push({\n                    prev_hash: Buffer.from(input.transaction_id().to_bytes()).toString('hex'),\n                    prev_index: parseInt(input.index()),\n                    path: keys.payment.path, // needed to include payment key witness if available\n                });\n            }\n            else {\n                collateralInputs.push({\n                    prev_hash: Buffer.from(input.transaction_id().to_bytes()).toString('hex'),\n                    prev_index: parseInt(input.index()),\n                });\n            }\n            signingMode = CardanoTxSigningMode.PLUTUS_TRANSACTION;\n        }\n    }\n    let requiredSigners = null;\n    if (tx.body().required_signers()) {\n        requiredSigners = [];\n        const r = tx.body().required_signers();\n        for (let i = 0; i < r.len(); i++) {\n            const signer = Buffer.from(r.get(i).to_bytes()).toString('hex');\n            if (signer === keys.payment.hash) {\n                requiredSigners.push({\n                    keyPath: keys.payment.path,\n                });\n            }\n            else if (signer === keys.stake.hash) {\n                // https://github.com/input-output-hk/nami/commit/a5f5a9357da81307bff9bc77ef2476f1746c134a#diff-1c7110974e24c349d96acac1989fe76c94b0031ab0f5a114e10823e5d74549deR421-R423\n                requiredSigners.push({\n                    keyPath: keys.stake.path,\n                });\n            }\n            else {\n                requiredSigners.push({\n                    keyHash: signer,\n                });\n            }\n        }\n        signingMode = CardanoTxSigningMode.PLUTUS_TRANSACTION;\n    }\n    let referenceInputs = null;\n    if (tx.body().reference_inputs()) {\n        referenceInputs = [];\n        const ri = tx.body().reference_inputs();\n        for (let i = 0; i < ri.len(); i++) {\n            referenceInputs.push({\n                prev_hash: ri.get(i).transaction_id().to_hex(),\n                prev_index: parseInt(ri.get(i).index().to_str()),\n            });\n        }\n        signingMode = CardanoTxSigningMode.PLUTUS_TRANSACTION;\n    }\n    const totalCollateral = tx.body().total_collateral()\n        ? tx.body().total_collateral().to_str()\n        : null;\n    const collateralReturn = (() => {\n        if (tx.body().collateral_return()) {\n            const outputs = CardanoWasm.TransactionOutputs.new();\n            outputs.add(tx.body().collateral_return());\n            const [out] = outputsToOneKey(outputs, changeAddress);\n            return out;\n        }\n        return null;\n    })();\n    const includeNetworkId = !!tx.body().network_id();\n    const onekeyTx = {\n        signingMode,\n        outputs: onekeyOutputs,\n        fee,\n        ttl: ttl ? `${ttl}` : null,\n        validityIntervalStart,\n        certificates: onekeyCertificates,\n        withdrawals: onekeyWithdrawals,\n        auxiliaryData,\n        mint: mintBundle,\n        scriptDataHash,\n        collateralInputs,\n        requiredSigners,\n        protocolMagic: network === 1 ? 764824073 : 42,\n        networkId: network,\n        includeNetworkId,\n        additionalWitnessRequests,\n        collateralReturn,\n        totalCollateral,\n        referenceInputs,\n    };\n    Object.keys(onekeyTx).forEach(key => !onekeyTx[key] && onekeyTx[key] != 0 && delete onekeyTx[key]);\n    console.log('format onekey cardano hardware Tx =====>>> : ', onekeyTx);\n    return Promise.resolve(onekeyTx);\n};\nconst bytesToIp = bytes => {\n    if (!bytes)\n        return null;\n    if (bytes.length === 4) {\n        return { ipv4: bytes.join('.') };\n    }\n    else if (bytes.length === 16) {\n        let ipv6 = '';\n        for (let i = 0; i < bytes.length; i += 2) {\n            ipv6 += bytes[i].toString(16) + bytes[i + 1].toString(16) + ':';\n        }\n        ipv6 = ipv6.slice(0, -1);\n        return { ipv6 };\n    }\n    return null;\n};\n","import { composeTxPlan } from './transaction';\nimport { signTransaction, signTx } from './signTx';\nimport { dAppUtils } from './dapp';\nimport { txToOneKey } from './txToOneKey';\nconst onekeyUtils = {\n    composeTxPlan,\n    signTransaction,\n    signTx,\n    txToOneKey,\n};\nexport { onekeyUtils, dAppUtils };\n","import { ERROR } from './constants';\nimport { largestFirst } from './methods/largestFirst';\nimport { randomImprove } from './methods/randomImprove';\nimport { CoinSelectionError } from './utils/errors';\nimport { getLogger } from './utils/logger';\nimport { bigNumFromStr } from './utils/common';\nexport const coinSelection = (params, options) => {\n    const logger = getLogger(!!(options === null || options === void 0 ? void 0 : options.debug));\n    logger.debug('Args:', {\n        params,\n        options,\n    });\n    if (params.utxos.length === 0) {\n        logger.debug('Empty Utxo set');\n        throw new CoinSelectionError(ERROR.UTXO_BALANCE_INSUFFICIENT);\n    }\n    const t1 = new Date().getTime();\n    let res;\n    if (params.outputs.find(o => o.setMax) ||\n        params.certificates.length > 0 ||\n        params.withdrawals.length > 0 ||\n        (options === null || options === void 0 ? void 0 : options.forceLargestFirstSelection)) {\n        logger.debug('Running largest-first alg');\n        res = largestFirst(params, options);\n    }\n    else {\n        logger.debug('Running random-improve alg');\n        try {\n            res = randomImprove(params, options);\n        }\n        catch (error) {\n            if (error instanceof CoinSelectionError &&\n                error.code === 'UTXO_NOT_FRAGMENTED_ENOUGH') {\n                logger.debug(`random-improve failed with ${error.code}. Retrying with largest-first alg.`);\n                res = largestFirst(params, options);\n            }\n            else {\n                throw error;\n            }\n        }\n    }\n    const t2 = new Date().getTime();\n    logger.debug(`Duration: ${(t2 - t1) / 1000} seconds`);\n    const incompleteOutputs = res.outputs.find(o => !o.address ||\n        !o.amount ||\n        // assets set with quantity = 0\n        (o.assets.length > 0 &&\n            o.assets.find(a => !a.quantity ||\n                bigNumFromStr(a.quantity).compare(bigNumFromStr('0')) === 0)));\n    if (incompleteOutputs) {\n        const selection = {\n            type: 'nonfinal',\n            fee: res.fee,\n            totalSpent: res.totalSpent,\n            deposit: res.deposit,\n            withdrawal: res.withdrawal,\n            max: res.max,\n        };\n        logger.debug('Coin selection for a draft transaction:', selection);\n        return selection;\n    }\n    else {\n        const selection = Object.assign(Object.assign({ type: 'final' }, res), { outputs: res.outputs });\n        logger.debug('Coin selection for a final transaction:', selection);\n        return selection;\n    }\n};\nimport * as types_1 from './types/types';\nexport { types_1 as types };\nimport * as trezorUtils_1 from './utils/trezor';\nexport { trezorUtils_1 as trezorUtils };\nexport { onekeyUtils, dAppUtils } from './utils/onekey';\nexport { CoinSelectionError } from './utils/errors';\n"],"names":["heap","Array","fill","undefined","getObject","idx","push","heap_next","length","takeObject","ret","dropObject","cachedTextDecoder","TextDecoder","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","Uint8Array","getStringFromWasm0","ptr","len","subarray","debugString","val","type","description","name","isArray","debug","i","builtInMatches","exec","toString","call","className","JSON","stringify","_","Error","message","stack","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","mem","offset","code","charCodeAt","slice","cachegetInt32Memory0","getInt32Memory0","Int32Array","getArrayU8FromWasm0","passArray8ToWasm0","_assertClass","instance","klass","isLikeNone","x","cachegetFloat64Memory0","Object","freeze","Int","Text","COSESIGN","COSESIGN1","Signature","Signature1","CounterSignature","Bool","Float","Unassigned","Break","Undefined","Null","Bytes","TaggedCBOR","Special","AlgorithmId","EdDSA","ChaCha20Poly1305","KeyType","OKP","EC2","Symmetric","CRV","X","Y","D","P256","P384","P521","X25519","X448","Ed25519","Ed448","Sign","Verify","Encrypt","Decrypt","WrapKey","UnwrapKey","DeriveKey","DeriveBits","BigNum","__wrap","obj","create","prototype","__destroy_into_raw","this","free","to_bytes","retptr","r0","r1","v0","from_bytes","bytes","ptr0","len0","from_str","string","to_str","checked_mul","other","checked_add","checked_sub","CBORArray","get","index","CBORValue","add","elem","set_definite_encoding","use_definite","is_definite","CBORObject","insert","key","value","keys","CBORSpecial","new_bool","b","new_unassigned","u","new_break","new_null","new_undefined","kind","as_bool","as_float","getFloat64Memory0","Float64Array","as_unassigned","new_int","int","new_bytes","new_text","text","new_array","arr","new_object","new_tagged","tagged","new_special","special","from_label","label","Label","as_int","as_bytes","as_text","as_array","as_object","as_tagged","as_special","COSEKey","set_key_type","key_type","set_key_id","key_id","set_algorithm_id","algorithm_id","set_key_ops","key_ops","Labels","set_base_init_vector","base_init_vector","header","set_header","COSESign1","headers","Headers","payload","signature","signed_data","external_aad","external_payload","ptr1","len1","SigStructure","COSESign1Builder","is_payload_external","hash_payload","set_external_aad","make_data_to_sign","build","signed_sig_structure","COSESignature","COSESignatures","new_single","cose_signature","new_multi","cose_signatures","signatures","HeaderMap","set_criticality","criticality","set_content_type","content_type","set_init_vector","init_vector","set_partial_init_vector","partial_init_vector","set_counter_signature","counter_signature","protected","ProtectedHeaderMap","unprotected","protected_","unprotected_","new_negative","new_i32","is_positive","as_positive","as_negative","as_i32","from_algorithm_id","id","from_key_type","from_ec_key","ec_key","from_curve_type","curve_type","from_key_operation","key_op","new_empty","header_map","deserialized_headers","context","body_protected","sign_protected","set_sign_protected","tag","__wbindgen_object_drop_ref","arg0","__wbindgen_string_new","arg1","addHeapObject","__wbindgen_debug_string","__wbindgen_throw","__wbindgen_rethrow","module","require","cachegetUint32Memory0","getUint32Memory0","Uint32Array","getArrayU32FromWasm0","make_vkey_witness","tx_body_hash","sk","TransactionHash","PrivateKey","Vkeywitness","hash_transaction","tx_body","TransactionBody","min_ada_for_output","output","data_cost","TransactionOutput","DataCost","handleError","f","args","apply","e","StakeRegistration","StakeDeregistration","StakeDelegation","PoolRegistration","PoolRetirement","GenesisKeyDelegation","MoveInstantaneousRewardsCert","Reserves","Treasury","ToOtherPot","ToStakeCredentials","SingleHostAddr","SingleHostName","MultiHostName","ScriptPubkey","ScriptAll","ScriptAny","ScriptNOfK","TimelockStart","TimelockExpiry","NativeScript","PlutusScript","PlutusScriptV2","Testnet","Mainnet","LargestFirst","RandomImprove","LargestFirstMultiAsset","RandomImproveMultiAsset","Key","Script","Wallet","Node","MetadataMap","MetadataList","NoConversions","BasicConversions","DetailedSchema","PlutusV1","PlutusV2","ConstrPlutusData","Map","List","Integer","Spend","Mint","Cert","Reward","Address","data","to_json","to_js_value","from_json","json","to_hex","from_hex","hex_str","to_bech32","prefix","from_bech32","bech_str","network_id","AssetName","AssetNames","Assets","AuxiliaryData","metadata","GeneralTransactionMetadata","set_metadata","native_scripts","NativeScripts","set_native_scripts","plutus_scripts","PlutusScripts","set_plutus_scripts","AuxiliaryDataHash","hex","BaseAddress","network","payment","stake","StakeCredential","payment_cred","stake_cred","to_address","from_address","addr","BigInt","is_zero","as_u64","mul","one","increment","div_ceil","zero","div_floor","clamped_sub","compare","rhs_value","less_than","max","a","Bip32PrivateKey","derive","from_128_xprv","to_128_xprv","generate_ed25519_bip32","to_raw_key","to_public","Bip32PublicKey","bech32_str","from_bip39_entropy","entropy","password","chaincode","PublicKey","BootstrapWitness","vkey","Vkey","Ed25519Signature","chain_code","attributes","BootstrapWitnesses","ByronAddress","to_base58","byron_protocol_magic","from_base58","s","icarus_from_key","protocol_magic","is_valid","Certificate","new_stake_registration","stake_registration","new_stake_deregistration","stake_deregistration","new_stake_delegation","stake_delegation","new_pool_registration","pool_registration","new_pool_retirement","pool_retirement","new_genesis_key_delegation","genesis_key_delegation","new_move_instantaneous_rewards_cert","move_instantaneous_rewards_cert","as_stake_registration","as_stake_deregistration","as_stake_delegation","as_pool_registration","as_pool_retirement","as_genesis_key_delegation","as_move_instantaneous_rewards_cert","Certificates","alternative","PlutusList","CostModel","operation","cost","Costmdls","Language","Languages","retain_language_versions","languages","DNSRecordAorAAAA","dns_name","record","DNSRecordSRV","new_coins_per_word","coins_per_word","new_coins_per_byte","coins_per_byte","DataHash","DatumSource","datum","PlutusData","new_ref_input","input","TransactionInput","Ed25519KeyHash","Ed25519KeyHashes","to_option","EnterpriseAddress","ExUnitPrices","mem_price","UnitInterval","step_price","ExUnits","steps","TransactionMetadatum","TransactionMetadatumLabels","GenesisDelegateHash","GenesisHash","GenesisHashes","genesishash","genesis_delegate_hash","vrf_keyhash","VRFKeyHash","as_i32_or_nothing","as_i32_or_fail","Ipv4","ip","Ipv6","new_plutus_v1","new_plutus_v2","LinearFee","constant","coefficient","MIRToStakeCredentials","cred","delta","StakeCredentials","insert_str","insert_i32","get_str","get_i32","has","new_from_entry","ScriptHash","MintAssets","ScriptHashes","as_positive_multiasset","MultiAsset","as_negative_multiasset","MoveInstantaneousReward","new_to_other_pot","pot","amount","new_to_stake_creds","amounts","as_to_other_pot","as_to_stake_creds","move_instantaneous_reward","policy_id","assets","set_asset","asset_name","get_asset","sub","rhs_ma","hash","new_script_pubkey","script_pubkey","new_script_all","script_all","new_script_any","script_any","new_script_n_of_k","script_n_of_k","new_timelock_start","timelock_start","new_timelock_expiry","timelock_expiry","as_script_pubkey","as_script_all","as_script_any","as_script_n_of_k","as_timelock_start","as_timelock_expiry","get_required_signers","NetworkId","testnet","mainnet","NetworkInfo","Nonce","new_identity","new_from_hash","get_hash","new_constr_plutus_data","constr_plutus_data","new_empty_constr_plutus_data","new_map","map","PlutusMap","new_list","list","new_integer","integer","as_constr_plutus_data","as_map","as_list","as_integer","schema","new_v2","new_with_version","language","from_bytes_v2","from_bytes_with_version","from_hex_with_version","language_version","PlutusScriptSource","script","script_hash","PlutusWitness","redeemer","Redeemer","new_with_ref","PlutusWitnesses","Pointer","slot","tx_index","cert_index","new_pointer","slot_bignum","tx_index_bignum","cert_index_bignum","PointerAddress","stake_pointer","PoolMetadata","url","URL","pool_metadata_hash","PoolMetadataHash","PoolParams","operator","pledge","margin","reward_account","RewardAddress","pool_owners","relays","Relays","pool_metadata","pool_params","pool_keyhash","epoch","generate_ed25519","generate_ed25519extended","from_extended_bytes","from_normal_bytes","sign","ProposedProtocolParameterUpdates","ProtocolParamUpdate","set_minfee_a","minfee_a","set_minfee_b","minfee_b","set_max_block_body_size","max_block_body_size","set_max_tx_size","max_tx_size","set_max_block_header_size","max_block_header_size","set_key_deposit","key_deposit","set_pool_deposit","pool_deposit","set_max_epoch","max_epoch","set_n_opt","n_opt","set_pool_pledge_influence","pool_pledge_influence","set_expansion_rate","expansion_rate","set_treasury_growth_rate","treasury_growth_rate","d","extra_entropy","set_protocol_version","protocol_version","ProtocolVersion","set_min_pool_cost","min_pool_cost","set_ada_per_utxo_byte","ada_per_utxo_byte","set_cost_models","cost_models","set_execution_costs","execution_costs","set_max_tx_ex_units","max_tx_ex_units","set_max_block_ex_units","max_block_ex_units","set_max_value_size","max_value_size","set_collateral_percentage","collateral_percentage","set_max_collateral_inputs","max_collateral_inputs","major","minor","verify","RedeemerTag","ex_units","new_spend","new_mint","new_cert","new_reward","Redeemers","total_ex_units","Relay","new_single_host_addr","single_host_addr","new_single_host_name","single_host_name","new_multi_host_name","multi_host_name","as_single_host_addr","as_single_host_name","as_multi_host_name","RewardAddresses","ScriptDataHash","n","addr_keyhash","ScriptRef","new_native_script","native_script","new_plutus_script","plutus_script","is_native_script","is_plutus_script","port","ipv4","ipv6","from_keyhash","from_scripthash","to_keyhash","to_scripthash","stake_credential","new_timelockexpiry","new_timelockstart","Transaction","body","witness_set","TransactionWitnessSet","auxiliary_data","set_is_valid","valid","inputs","TransactionInputs","outputs","TransactionOutputs","fee","ttl","ttl_bignum","set_ttl","remove_ttl","set_certs","certs","set_withdrawals","withdrawals","Withdrawals","set_update","update","Update","set_auxiliary_data_hash","auxiliary_data_hash","set_validity_start_interval","validity_start_interval","set_validity_start_interval_bignum","validity_start_interval_bignum","set_mint","mint","multiassets","set_reference_inputs","reference_inputs","set_script_data_hash","script_data_hash","set_collateral","collateral","set_required_signers","required_signers","set_network_id","set_collateral_return","collateral_return","set_total_collateral","total_collateral","new_tx_body","TransactionBuilder","add_inputs_from","strategy","TransactionUnspentOutputs","set_inputs","TxInputsBuilder","set_collateral_return_and_total","set_total_collateral_and_return","return_address","add_reference_input","reference_input","add_key_input","Value","add_script_input","add_native_script_input","add_plutus_script_input","witness","add_bootstrap_input","add_input","address","count_missing_input_scripts","add_required_native_input_scripts","scripts","add_required_plutus_input_scripts","get_native_input_scripts","get_plutus_input_scripts","fee_for_input","add_output","fee_for_output","set_fee","set_ttl_bignum","get_auxiliary_data","set_auxiliary_data","add_metadatum","add_json_metadatum","add_json_metadatum_with_schema","mint_scripts","get_mint","get_mint_scripts","set_mint_asset","policy_script","mint_assets","add_mint_asset","add_mint_asset_and_output","output_builder","output_coin","TransactionOutputAmountBuilder","add_mint_asset_and_output_min_required_coin","cfg","TransactionBuilderConfig","get_reference_inputs","get_explicit_input","get_implicit_input","get_total_input","get_total_output","get_explicit_output","get_deposit","get_fee_if_set","add_change_if_needed","calc_script_data_hash","remove_script_data_hash","add_required_signer","full_size","output_sizes","build_tx","build_tx_unsafe","min_fee","TransactionBuilderConfigBuilder","fee_algo","coins_per_utxo_word","coins_per_utxo_byte","ex_unit_prices","prefer_pure_change","transaction_id","data_hash","plutus_data","script_ref","set_script_ref","set_plutus_data","set_data_hash","has_plutus_data","has_data_hash","has_script_ref","with_value","with_coin","coin","with_coin_and_asset","multiasset","with_asset_and_min_required_coin","with_asset_and_min_required_coin_by_utxo_cost","TransactionUnspentOutput","set_vkeys","vkeys","Vkeywitnesses","set_bootstraps","bootstraps","set_redeemers","redeemers","get_ref_inputs","add_required_signers","total_value","inputs_option","numerator","denominator","proposed_protocol_parameter_updates","new_from_assets","new_with_assets","set_coin","set_multiasset","rhs","pk","public_key","__wbindgen_string_get","__wbindgen_number_new","__wbindgen_object_clone_ref","__wbindgen_is_object","__wbindgen_is_undefined","__wbg_String_7462bcc0fcdbaf7d","String","__wbg_set_e93b31d47b90bff6","arg2","__wbg_process_2f24d6544ea7b200","process","__wbg_versions_6164651e75405d4a","versions","__wbg_node_4b517d861cbcb3bc","node","__wbindgen_is_string","__wbg_modulerequire_3440a4bcf44437db","arguments","__wbg_crypto_98fc271021c7d2ad","crypto","__wbg_msCrypto_a2cdb043d2bfe57f","msCrypto","__wbg_getRandomValues_98117e9a7e993920","getRandomValues","__wbg_randomFillSync_64cc7d048f228ca8","randomFillSync","__wbg_new_949bbc1147195c4e","__wbg_newnoargs_be86524d73f67598","Function","__wbg_new_ac32179a660db4bb","__wbg_call_888d259a5fefc347","__wbg_new_0b83d3df67ecb33e","__wbg_self_c6fbdfc2918d5e58","self","__wbg_window_baec038b5ab35c54","window","__wbg_globalThis_3f735a5746d41fbd","globalThis","__wbg_global_1bc0b39582740e95","g","global","__wbg_set_1820441f7fb79aad","__wbg_new_342a24ca698edd87","__wbg_set_a46091b120cc63e9","__wbg_buffer_397eaa4d72ee94dd","__wbg_new_a7ce447f15ff496f","__wbg_set_969ad0a60e51d320","__wbg_length_1eb8fc608a0d4cdb","__wbg_newwithlength_929232475839a482","__wbg_subarray_8b658422a224f479","__wbg_new_3a746f2619705add","__wbg_call_f54d3a6dadb199ca","__wbindgen_jsval_eq","__wbg_self_ac379e780a0d8b94","__wbg_crypto_1e4302b85d4f64a2","__wbg_getRandomValues_1b4ba144162a5c9e","__wbg_require_6461b1e9a0d7c34a","__wbg_randomFillSync_1b52c8482374c55b","__wbg_getRandomValues_1ef11e888e5228e9","__wbindgen_memory","CertificateType","ERROR","PROTOCOL_MAGICS","NETWORK_IDS","COINS_PER_UTXO_BYTE","MAX_TX_SIZE","MAX_VALUE_SIZE","DATA_COST_PER_UTXO_BYTE","CoinSelectionError","constructor","errorObject","super","setPrototypeOf","bigNumFromStr","num","parseAsset","policyId","assetNameInHex","buildMultiAsset","multiAsset","new","assetsGroupedByPolicy","forEach","assetEntry","unit","Buffer","from","quantity","scriptHash","multiAssetToArray","assetsArray","policyHashes","assetsInPolicy","assetNames","j","assetName","policyIdHex","assetNameHex","getAssetAmount","asset","_a","_b","find","getUtxoQuantity","utxos","reduce","acc","utxo","getOutputQuantity","_c","sortUtxos","parse","sort","u1","u2","buildTxInput","txHash","outputIndex","filter","buildTxOutput","dummyAddress","outputAddr","outputAmount","outputValue","txOutput","minAdaRequired","getOutputCost","txBuilder","outputFee","minOutputAmount","setMinUtxoValueForOutputs","setMax","assign","splitChangeOutput","singleChangeOutput","changeAddress","maxTokensPerOutput","lovelaceAvailable","allAssets","nAssetBundles","Math","ceil","changeOutputs","assetsBundle","isChange","partialChange","changeOutputCost","changeOutputAmount","prepareChangeOutput","usedUtxos","preparedOutputs","utxosTotalAmount","totalOutputAmount","totalFeesAmount","pickAdditionalUtxo","placeholderChangeOutputAmount","uniqueAssets","includes","changeOutputAssets","assetUnit","assetInputAmount","assetSpentAmount","totalSpent","isChangeOutputNeeded","addUtxo","newTotalFee","getTxBuilder","getUnsatisfiedAssets","selectedUtxos","setMaxOutput","maxOutput","changeOutput","_d","maxOutputAsset","newMaxAmount","minUtxoVal","getUserOutputQuantityWithDeposit","deposit","filterUtxos","getRandomUtxo","utxoRemaining","utxoSelected","floor","random","splice","indexOf","calculateUserOutputsFee","userOutputs","orderInputs","inputsToOrder","txBody","orderedInputs","txid","uu","largestFirst","params","options","certificates","accountPubKey","feeParams","sortedUtxos","preparedCertificates","accountKey","stakeKey","stakeCred","cert","pool","prepareCertificates","preparedWithdrawals","withdrawal","rewardAddress","stakeAddress","prepareWithdrawals","CertificateDeposit","calculateRequiredDeposit","totalWithdrawal","abs","addUtxoToSelection","maxOutputIndex","findIndex","o","used","remaining","getInitialUtxoSet","totalUserOutputsAmount","sufficientUtxos","forceAnotherRound","newMaxOutput","_maxTokensPerOutput","requiredAmount","unsatisfiedAssets","change","unspendableChangeAmount","shift","finalOutputs","txBodyHex","tx","size","getLogger","formattedMessage","level","timestamp","myFormat","console","log","improvesSelection","utxoAlreadySelected","minimumTarget","oldQuantity","newQuantity","idealTarget","newDistance","oldDistance","calculateChange","randomUtxo","randomImprove","logger","assetsRemaining","outputQuantity","utxosQuantity","assetIndex","assetUtxos","selection","ch","totalInput","totalOutput","CardanoAddressType","transformToTokenBundle","uniquePolicies","assetsByPolicy","assetInfo","assetNameBytes","tokenAmounts","transformToTrezorInputs","trezorUtxos","utxoWithPath","vout","path","prev_hash","prev_index","transformToTrezorOutputs","changeAddressParameters","addressParameters","tokenBundle","CardanoTxWitnessType","signTransaction","signedWitnesses","witnesses","vkeyWitnesses","bootstrapWitnesses","w","vKey","pubKey","SHELLEY_WITNESS","vKeyWitness","BYRON_WITNESS","chainCode","xpubHex","bip32Key","byronAddress","bootstrapWitness","signOnly","Promise","resolve","transaction","serializedTx","composeTxPlan","transferInfo","accountXpub","transformUtxos","tx_hash","output_index","txPlan","coinSelection","err","fixedOutput","amountBN","oneLovelace","gte","minus","toFixed","TxSignError","info","DataSignError","signTx","async","keyHashes","partialSign","paymentKey","paymentKeyHash","stakeKeyHash","rawTx","txWitnessSet","keyHash","signingKey","getKeyHashes","account","requiredKeyHashes","baseAddr","paymentAddr","keyKind","some","credential","owners","instant_reward","keyHashFromCert","rewardAddresses","keyHashFromWithdrawal","keyHashFromScript","requiredSigners","Set","getUtxos","getPaymentHexAddress","converted","utxoFromJson","Number","assetsToValue","lovelace","policy","policyAssets","assetsValue","harden","requestAccountKey","xprv","accountIndex","parseInt","extractKeyHash","dAppUtils","getBalance","balances","getAddresses","addresses","filterVaule","unspent","convertCborTxToEncodeTx","txHex","totalFeeInNative","shiftedBy","encodeInputs","inputsLen","outputsLen","N","K","multiassetAmt","sum","token","encodedTx","to","rawTxHex","signData","startsWith","publicKey","protectedHeaders","protectedSerialized","unprotectedHeaders","builder","toSign","signedSigStruc","coseSign1","CardanoTxSigningMode","CardanoCertificateType","CardanoPoolRelayType","outputsToOneKey","onekeyOutputs","tokens","k","outputAddressBech32","outputAddressHuman","destination","addressType","BASE","stakingPath","datumHash","inlineDatum","referenceScript","outputRes","format","bytesToIp","join","onekeyUtils","serializedUtxos","transactionWitnessSet","witnessSet","signedTx","txToOneKey","initKeys","xpub","paymentKeyHashRaw","stakeKeyHashRaw","generateKeys","signingMode","ORDINARY_TRANSACTION","onekeyCertificates","certificate","STAKE_REGISTRATION","STAKE_DEREGISTRATION","delegation","poolKeyHashHex","STAKE_DELEGATION","STAKE_POOL_REGISTRATION","poolOwners","POOL_REGISTRATION_AS_OWNER","stakingKeyPath","stakingKeyHash","onekeyRelays","relay","singleHostAddr","SINGLE_HOST_IP","ipv4Address","ipv6Address","SINGLE_HOST_NAME","singleHostName","hostName","MULTIPLE_HOST_NAME","poolId","rewardAccount","vrfKeyHash","poolParameters","onekeyWithdrawals","auxiliaryData","validityIntervalStart","additionalWitnessRequests","mintBundle","mintAmount","scriptDataHash","collateralInputs","coll","PLUTUS_TRANSACTION","r","signer","keyPath","referenceInputs","ri","totalCollateral","collateralReturn","out","onekeyTx","protocolMagic","networkId","includeNetworkId","t1","Date","getTime","res","forceLargestFirstSelection","error","t2"],"sourceRoot":""}
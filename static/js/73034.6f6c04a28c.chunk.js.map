{"version":3,"file":"static/js/73034.6f6c04a28c.chunk.js","mappings":"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","sources":["webpack://web/../../node_modules/ansicolors/ansicolors.js","webpack://web/../../node_modules/buffer-layout/lib/Layout.js","webpack://web/../../node_modules/camelcase/index.js","webpack://web/../../node_modules/debug/node_modules/ms/index.js","webpack://web/../../node_modules/debug/src/browser.js","webpack://web/../../node_modules/debug/src/common.js"],"sourcesContent":["// ColorCodes explained: http://www.termsys.demon.co.uk/vtansi.htm\n'use strict';\n\nvar colorNums = {\n      white         :  37\n    , black         :  30\n    , blue          :  34\n    , cyan          :  36\n    , green         :  32\n    , magenta       :  35\n    , red           :  31\n    , yellow        :  33\n    , brightBlack   :  90\n    , brightRed     :  91\n    , brightGreen   :  92\n    , brightYellow  :  93\n    , brightBlue    :  94\n    , brightMagenta :  95\n    , brightCyan    :  96\n    , brightWhite   :  97\n    }\n  , backgroundColorNums = {\n      bgBlack         :  40\n    , bgRed           :  41\n    , bgGreen         :  42\n    , bgYellow        :  43\n    , bgBlue          :  44\n    , bgMagenta       :  45\n    , bgCyan          :  46\n    , bgWhite         :  47\n    , bgBrightBlack   :  100\n    , bgBrightRed     :  101\n    , bgBrightGreen   :  102\n    , bgBrightYellow  :  103\n    , bgBrightBlue    :  104\n    , bgBrightMagenta :  105\n    , bgBrightCyan    :  106\n    , bgBrightWhite   :  107\n    } \n  , open   =  {}\n  , close  =  {}\n  , colors =  {}\n  ;\n\nObject.keys(colorNums).forEach(function (k) {\n  var o =  open[k]  =  '\\u001b[' + colorNums[k] + 'm';\n  var c =  close[k] =  '\\u001b[39m';\n\n  colors[k] = function (s) { \n    return o + s + c;\n  };\n});\n\nObject.keys(backgroundColorNums).forEach(function (k) {\n  var o =  open[k]  =  '\\u001b[' + backgroundColorNums[k] + 'm';\n  var c =  close[k] =  '\\u001b[49m';\n\n  colors[k] = function (s) { \n    return o + s + c;\n  };\n});\n\nmodule.exports =  colors;\ncolors.open    =  open;\ncolors.close   =  close;\n","/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Support for translating between Buffer instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */\n\n'use strict';\n\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */\nclass Layout {\n  constructor(span, property) {\n    if (!Number.isInteger(span)) {\n      throw new TypeError('span must be an integer');\n    }\n\n    /** The span of the layout in bytes.\n     *\n     * Positive values are generally expected.\n     *\n     * Zero will only appear in {@link Constant}s and in {@link\n     * Sequence}s where the {@link Sequence#count|count} is zero.\n     *\n     * A negative value indicates that the span is value-specific, and\n     * must be obtained using {@link Layout#getSpan|getSpan}. */\n    this.span = span;\n\n    /** The property name used when this layout is represented in an\n     * Object.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances.  If left undefined the span of the unnamed layout will\n     * be treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Function to create an Object into which decoded properties will\n   * be written.\n   *\n   * Used only for layouts that {@link Layout#decode|decode} to Object\n   * instances, which means:\n   * * {@link Structure}\n   * * {@link Union}\n   * * {@link VariantLayout}\n   * * {@link BitStructure}\n   *\n   * If left undefined the JavaScript representation of these layouts\n   * will be Object instances.\n   *\n   * See {@link bindConstructorLayout}.\n   */\n  makeDestinationObject() {\n    return {};\n  }\n\n  /**\n   * Decode from a Buffer into an JavaScript value.\n   *\n   * @param {Buffer} b - the buffer from which encoded data is read.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {(Number|Array|Object)} - the value of the decoded data.\n   *\n   * @abstract\n   */\n  decode(b, offset) {\n    throw new Error('Layout is abstract');\n  }\n\n  /**\n   * Encode a JavaScript value into a Buffer.\n   *\n   * @param {(Number|Array|Object)} src - the value to be encoded into\n   * the buffer.  The type accepted depends on the (sub-)type of {@link\n   * Layout}.\n   *\n   * @param {Buffer} b - the buffer into which encoded data will be\n   * written.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {Number} - the number of bytes encoded, including the\n   * space skipped for internal padding, but excluding data such as\n   * {@link Sequence#count|lengths} when stored {@link\n   * ExternalLayout|externally}.  This is the adjustment to `offset`\n   * producing the offset where data for the next layout would be\n   * written.\n   *\n   * @abstract\n   */\n  encode(src, b, offset) {\n    throw new Error('Layout is abstract');\n  }\n\n  /**\n   * Calculate the span of a specific instance of a layout.\n   *\n   * @param {Buffer} b - the buffer that contains an encoded instance.\n   *\n   * @param {Number} [offset] - the offset at which the encoded instance\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @return {Number} - the number of bytes covered by the layout\n   * instance.  If this method is not overridden in a subclass the\n   * definition-time constant {@link Layout#span|span} will be\n   * returned.\n   *\n   * @throws {RangeError} - if the length of the value cannot be\n   * determined.\n   */\n  getSpan(b, offset) {\n    if (0 > this.span) {\n      throw new RangeError('indeterminate span');\n    }\n    return this.span;\n  }\n\n  /**\n   * Replicate the layout using a new property.\n   *\n   * This function must be used to get a structurally-equivalent layout\n   * with a different name since all {@link Layout} instances are\n   * immutable.\n   *\n   * **NOTE** This is a shallow copy.  All fields except {@link\n   * Layout#property|property} are strictly equal to the origin layout.\n   *\n   * @param {String} property - the value for {@link\n   * Layout#property|property} in the replica.\n   *\n   * @returns {Layout} - the copy with {@link Layout#property|property}\n   * set to `property`.\n   */\n  replicate(property) {\n    const rv = Object.create(this.constructor.prototype);\n    Object.assign(rv, this);\n    rv.property = property;\n    return rv;\n  }\n\n  /**\n   * Create an object from layout properties and an array of values.\n   *\n   * **NOTE** This function returns `undefined` if invoked on a layout\n   * that does not return its value as an Object.  Objects are\n   * returned for things that are a {@link Structure}, which includes\n   * {@link VariantLayout|variant layouts} if they are structures, and\n   * excludes {@link Union}s.  If you want this feature for a union\n   * you must use {@link Union.getVariant|getVariant} to select the\n   * desired layout.\n   *\n   * @param {Array} values - an array of values that correspond to the\n   * default order for properties.  As with {@link Layout#decode|decode}\n   * layout elements that have no property name are skipped when\n   * iterating over the array values.  Only the top-level properties are\n   * assigned; arguments are not assigned to properties of contained\n   * layouts.  Any unused values are ignored.\n   *\n   * @return {(Object|undefined)}\n   */\n  fromArray(values) {\n    return undefined;\n  }\n}\nexports.Layout = Layout;\n\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */\nfunction nameWithProperty(name, lo) {\n  if (lo.property) {\n    return name + '[' + lo.property + ']';\n  }\n  return name;\n}\nexports.nameWithProperty = nameWithProperty;\n\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */\nfunction bindConstructorLayout(Class, layout) {\n  if ('function' !== typeof Class) {\n    throw new TypeError('Class must be constructor');\n  }\n  if (Class.hasOwnProperty('layout_')) {\n    throw new Error('Class is already bound to a layout');\n  }\n  if (!(layout && (layout instanceof Layout))) {\n    throw new TypeError('layout must be a Layout');\n  }\n  if (layout.hasOwnProperty('boundConstructor_')) {\n    throw new Error('layout is already bound to a constructor');\n  }\n  Class.layout_ = layout;\n  layout.boundConstructor_ = Class;\n  layout.makeDestinationObject = (() => new Class());\n  Object.defineProperty(Class.prototype, 'encode', {\n    value: function(b, offset) {\n      return layout.encode(this, b, offset);\n    },\n    writable: true,\n  });\n  Object.defineProperty(Class, 'decode', {\n    value: function(b, offset) {\n      return layout.decode(b, offset);\n    },\n    writable: true,\n  });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */\nclass ExternalLayout extends Layout {\n  /**\n   * Return `true` iff the external layout decodes to an unsigned\n   * integer layout.\n   *\n   * In that case it can be used as the source of {@link\n   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n   * or as {@link UnionLayoutDiscriminator#layout|external union\n   * discriminators}.\n   *\n   * @abstract\n   */\n  isCount() {\n    throw new Error('ExternalLayout is abstract');\n  }\n}\n\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */\nclass GreedyCount extends ExternalLayout {\n  constructor(elementSpan, property) {\n    if (undefined === elementSpan) {\n      elementSpan = 1;\n    }\n    if ((!Number.isInteger(elementSpan)) || (0 >= elementSpan)) {\n      throw new TypeError('elementSpan must be a (positive) integer');\n    }\n    super(-1, property);\n\n    /** The layout for individual elements of the sequence.  The value\n     * must be a positive integer.  If not provided, the value will be\n     * 1. */\n    this.elementSpan = elementSpan;\n  }\n\n  /** @override */\n  isCount() {\n    return true;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const rem = b.length - offset;\n    return Math.floor(rem / this.elementSpan);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    return 0;\n  }\n}\n\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */\nclass OffsetLayout extends ExternalLayout {\n  constructor(layout, offset, property) {\n    if (!(layout instanceof Layout)) {\n      throw new TypeError('layout must be a Layout');\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    } else if (!Number.isInteger(offset)) {\n      throw new TypeError('offset must be integer or undefined');\n    }\n\n    super(layout.span, property || layout.property);\n\n    /** The subordinated layout. */\n    this.layout = layout;\n\n    /** The location of {@link OffsetLayout#layout} relative to the\n     * start of another layout.\n     *\n     * The value may be positive or negative, but an error will thrown\n     * if at the point of use it goes outside the span of the Buffer\n     * being accessed.  */\n    this.offset = offset;\n  }\n\n  /** @override */\n  isCount() {\n    return ((this.layout instanceof UInt)\n            || (this.layout instanceof UIntBE));\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return this.layout.decode(b, offset + this.offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return this.layout.encode(src, b, offset + this.offset);\n  }\n}\n\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UInt extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readUIntLE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeUIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UIntBE extends Layout {\n  constructor(span, property) {\n    super( span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readUIntBE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeUIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Int extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readIntLE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass IntBE extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readIntBE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\n\nconst V2E32 = Math.pow(2, 32);\n\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */\nfunction divmodInt64(src) {\n  const hi32 = Math.floor(src / V2E32);\n  const lo32 = src - (hi32 * V2E32);\n  return {hi32, lo32};\n}\n/* Reconstruct Number from quotient and non-negative remainder */\nfunction roundedInt64(hi32, lo32) {\n  return hi32 * V2E32 + lo32;\n}\n\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readUInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeUInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const hi32 = b.readUInt32BE(offset);\n    const lo32 = b.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32BE(split.hi32, offset);\n    b.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const hi32 = b.readInt32BE(offset);\n    const lo32 = b.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeInt32BE(split.hi32, offset);\n    b.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Float extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readFloatLE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeFloatLE(src, offset);\n    return 4;\n  }\n}\n\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass FloatBE extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readFloatBE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeFloatBE(src, offset);\n    return 4;\n  }\n}\n\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Double extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readDoubleLE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeDoubleLE(src, offset);\n    return 8;\n  }\n}\n\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass DoubleBE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readDoubleBE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeDoubleBE(src, offset);\n    return 8;\n  }\n}\n\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Sequence extends Layout {\n  constructor(elementLayout, count, property) {\n    if (!(elementLayout instanceof Layout)) {\n      throw new TypeError('elementLayout must be a Layout');\n    }\n    if (!(((count instanceof ExternalLayout) && count.isCount())\n          || (Number.isInteger(count) && (0 <= count)))) {\n      throw new TypeError('count must be non-negative integer '\n                          + 'or an unsigned integer ExternalLayout');\n    }\n    let span = -1;\n    if ((!(count instanceof ExternalLayout))\n        && (0 < elementLayout.span)) {\n      span = count * elementLayout.span;\n    }\n\n    super(span, property);\n\n    /** The layout for individual elements of the sequence. */\n    this.elementLayout = elementLayout;\n\n    /** The number of elements in the sequence.\n     *\n     * This will be either a non-negative integer or an instance of\n     * {@link ExternalLayout} for which {@link\n     * ExternalLayout#isCount|isCount()} is `true`. */\n    this.count = count;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    if (0 < this.elementLayout.span) {\n      span = count * this.elementLayout.span;\n    } else {\n      let idx = 0;\n      while (idx < count) {\n        span += this.elementLayout.getSpan(b, offset + span);\n        ++idx;\n      }\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const rv = [];\n    let i = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    while (i < count) {\n      rv.push(this.elementLayout.decode(b, offset));\n      offset += this.elementLayout.getSpan(b, offset);\n      i += 1;\n    }\n    return rv;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n   *\n   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n   * the unused space in the buffer is left unchanged.  If `src` is\n   * longer than {@link Sequence#count|count} the unneeded elements are\n   * ignored.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const elo = this.elementLayout;\n    const span = src.reduce((span, v) => {\n      return span + elo.encode(v, b, offset + span);\n    }, 0);\n    if (this.count instanceof ExternalLayout) {\n      this.count.encode(src.length, b, offset);\n    }\n    return span;\n  }\n}\n\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */\nclass Structure extends Layout {\n  constructor(fields, property, decodePrefixes) {\n    if (!(Array.isArray(fields)\n          && fields.reduce((acc, v) => acc && (v instanceof Layout), true))) {\n      throw new TypeError('fields must be array of Layout instances');\n    }\n    if (('boolean' === typeof property)\n        && (undefined === decodePrefixes)) {\n      decodePrefixes = property;\n      property = undefined;\n    }\n\n    /* Verify absence of unnamed variable-length fields. */\n    for (const fd of fields) {\n      if ((0 > fd.span)\n          && (undefined === fd.property)) {\n        throw new Error('fields cannot contain unnamed variable-length layout');\n      }\n    }\n\n    let span = -1;\n    try {\n      span = fields.reduce((span, fd) => span + fd.getSpan(), 0);\n    } catch (e) {\n    }\n    super(span, property);\n\n    /** The sequence of {@link Layout} values that comprise the\n     * structure.\n     *\n     * The individual elements need not be the same type, and may be\n     * either scalar or aggregate layouts.  If a member layout leaves\n     * its {@link Layout#property|property} undefined the\n     * corresponding region of the buffer associated with the element\n     * will not be mutated.\n     *\n     * @type {Layout[]} */\n    this.fields = fields;\n\n    /** Control behavior of {@link Layout#decode|decode()} given short\n     * buffers.\n     *\n     * In some situations a structure many be extended with additional\n     * fields over time, with older installations providing only a\n     * prefix of the full structure.  If this property is `true`\n     * decoding will accept those buffers and leave subsequent fields\n     * undefined, as long as the buffer ends at a field boundary.\n     * Defaults to `false`. */\n    this.decodePrefixes = !!decodePrefixes;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = 0;\n    try {\n      span = this.fields.reduce((span, fd) => {\n        const fsp = fd.getSpan(b, offset);\n        offset += fsp;\n        return span + fsp;\n      }, 0);\n    } catch (e) {\n      throw new RangeError('indeterminate span');\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(b, offset);\n      }\n      offset += fd.getSpan(b, offset);\n      if (this.decodePrefixes\n          && (b.length === offset)) {\n        break;\n      }\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Structure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the buffer is\n   * left unmodified. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const firstOffset = offset;\n    let lastOffset = 0;\n    let lastWrote = 0;\n    for (const fd of this.fields) {\n      let span = fd.span;\n      lastWrote = (0 < span) ? span : 0;\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          lastWrote = fd.encode(fv, b, offset);\n          if (0 > span) {\n            /* Read the as-encoded span, which is not necessarily the\n             * same as what we wrote. */\n            span = fd.getSpan(b, offset);\n          }\n        }\n      }\n      lastOffset = offset;\n      offset += span;\n    }\n    /* Use (lastOffset + lastWrote) instead of offset because the last\n     * item may have had a dynamic length and we don't want to include\n     * the padding between it and the end of the space reserved for\n     * it. */\n    return (lastOffset + lastWrote) - firstOffset;\n  }\n\n  /** @override */\n  fromArray(values) {\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if ((undefined !== fd.property)\n          && (0 < values.length)) {\n        dest[fd.property] = values.shift();\n      }\n    }\n    return dest;\n  }\n\n  /**\n   * Get access to the layout of a given property.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Layout} - the layout associated with `property`, or\n   * undefined if there is no such property.\n   */\n  layoutFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n\n  /**\n   * Get the offset of a structure member.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Number} - the offset in bytes to the start of `property`\n   * within the structure, or undefined if `property` is not a field\n   * within the structure.  If the property is a member but follows a\n   * variable-length structure member a negative number will be\n   * returned.\n   */\n  offsetOf(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    let offset = 0;\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return offset;\n      }\n      if (0 > fd.span) {\n        offset = -1;\n      } else if (0 <= offset) {\n        offset += fd.span;\n      }\n    }\n  }\n}\n\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */\nclass UnionDiscriminator {\n  constructor(property) {\n    /** The {@link Layout#property|property} to be used when the\n     * discriminator is referenced in isolation (generally when {@link\n     * Union#decode|Union decode} cannot delegate to a specific\n     * variant). */\n    this.property = property;\n  }\n\n  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n   *\n   * The implementation of this method need not reference the buffer if\n   * variant information is available through other means. */\n  decode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n\n  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n   *\n   * The implementation of this method need not store the value if\n   * variant information is maintained through other means. */\n  encode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n}\n\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */\nclass UnionLayoutDiscriminator extends UnionDiscriminator {\n  constructor(layout, property) {\n    if (!((layout instanceof ExternalLayout)\n          && layout.isCount())) {\n      throw new TypeError('layout must be an unsigned integer ExternalLayout');\n    }\n\n    super(property || layout.property || 'variant');\n\n    /** The {@link ExternalLayout} used to access the discriminator\n     * value. */\n    this.layout = layout;\n  }\n\n  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  decode(b, offset) {\n    return this.layout.decode(b, offset);\n  }\n\n  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  encode(src, b, offset) {\n    return this.layout.encode(src, b, offset);\n  }\n}\n\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Union extends Layout {\n  constructor(discr, defaultLayout, property) {\n    const upv = ((discr instanceof UInt)\n               || (discr instanceof UIntBE));\n    if (upv) {\n      discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n    } else if ((discr instanceof ExternalLayout)\n               && discr.isCount()) {\n      discr = new UnionLayoutDiscriminator(discr);\n    } else if (!(discr instanceof UnionDiscriminator)) {\n      throw new TypeError('discr must be a UnionDiscriminator '\n                          + 'or an unsigned integer layout');\n    }\n    if (undefined === defaultLayout) {\n      defaultLayout = null;\n    }\n    if (!((null === defaultLayout)\n          || (defaultLayout instanceof Layout))) {\n      throw new TypeError('defaultLayout must be null or a Layout');\n    }\n    if (null !== defaultLayout) {\n      if (0 > defaultLayout.span) {\n        throw new Error('defaultLayout must have constant span');\n      }\n      if (undefined === defaultLayout.property) {\n        defaultLayout = defaultLayout.replicate('content');\n      }\n    }\n\n    /* The union span can be estimated only if there's a default\n     * layout.  The union spans its default layout, plus any prefix\n     * variant layout.  By construction both layouts, if present, have\n     * non-negative span. */\n    let span = -1;\n    if (defaultLayout) {\n      span = defaultLayout.span;\n      if ((0 <= span) && upv) {\n        span += discr.layout.span;\n      }\n    }\n    super(span, property);\n\n    /** The interface for the discriminator value in isolation.\n     *\n     * This a {@link UnionDiscriminator} either passed to the\n     * constructor or synthesized from the `discr` constructor\n     * argument.  {@link\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n     * `true` iff the `discr` parameter was a non-offset {@link\n     * Layout} instance. */\n    this.discriminator = discr;\n\n    /** `true` if the {@link Union#discriminator|discriminator} is the\n     * first field in the union.\n     *\n     * If `false` the discriminator is obtained from somewhere\n     * else. */\n    this.usesPrefixDiscriminator = upv;\n\n    /** The layout for non-discriminator content when the value of the\n     * discriminator is not recognized.\n     *\n     * This is the value passed to the constructor.  It is\n     * structurally equivalent to the second component of {@link\n     * Union#layout|layout} but may have a different property\n     * name. */\n    this.defaultLayout = defaultLayout;\n\n    /** A registry of allowed variants.\n     *\n     * The keys are unsigned integers which should be compatible with\n     * {@link Union.discriminator|discriminator}.  The property value\n     * is the corresponding {@link VariantLayout} instances assigned\n     * to this union by {@link Union#addVariant|addVariant}.\n     *\n     * **NOTE** The registry remains mutable so that variants can be\n     * {@link Union#addVariant|added} at any time.  Users should not\n     * manipulate the content of this property. */\n    this.registry = {};\n\n    /* Private variable used when invoking getSourceVariant */\n    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n\n    /** Function to infer the variant selected by a source object.\n     *\n     * Defaults to {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n     * be overridden using {@link\n     * Union#configGetSourceVariant|configGetSourceVariant}.\n     *\n     * @param {Object} src - as with {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * @returns {(undefined|VariantLayout)} The default variant\n     * (`undefined`) or first registered variant that uses a property\n     * available in `src`. */\n    this.getSourceVariant = function(src) {\n      return boundGetSourceVariant(src);\n    };\n\n    /** Function to override the implementation of {@link\n     * Union#getSourceVariant|getSourceVariant}.\n     *\n     * Use this if the desired variant cannot be identified using the\n     * algorithm of {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * **NOTE** The provided function will be invoked bound to this\n     * Union instance, providing local access to {@link\n     * Union#registry|registry}.\n     *\n     * @param {Function} gsv - a function that follows the API of\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n    this.configGetSourceVariant = function(gsv) {\n      boundGetSourceVariant = gsv.bind(this);\n    };\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Default layouts always have non-negative span, so we don't have\n     * one and we have to recognize the variant which will in turn\n     * determine the span. */\n    const vlo = this.getVariant(b, offset);\n    if (!vlo) {\n      throw new Error('unable to determine span for unrecognized variant');\n    }\n    return vlo.getSpan(b, offset);\n  }\n\n  /**\n   * Method to infer a registered Union variant compatible with `src`.\n   *\n   * The first satisified rule in the following sequence defines the\n   * return value:\n   * * If `src` has properties matching the Union discriminator and\n   *   the default layout, `undefined` is returned regardless of the\n   *   value of the discriminator property (this ensures the default\n   *   layout will be used);\n   * * If `src` has a property matching the Union discriminator, the\n   *   value of the discriminator identifies a registered variant, and\n   *   either (a) the variant has no layout, or (b) `src` has the\n   *   variant's property, then the variant is returned (because the\n   *   source satisfies the constraints of the variant it identifies);\n   * * If `src` does not have a property matching the Union\n   *   discriminator, but does have a property matching a registered\n   *   variant, then the variant is returned (because the source\n   *   matches a variant without an explicit conflict);\n   * * An error is thrown (because we either can't identify a variant,\n   *   or we were explicitly told the variant but can't satisfy it).\n   *\n   * @param {Object} src - an object presumed to be compatible with\n   * the content of the Union.\n   *\n   * @return {(undefined|VariantLayout)} - as described above.\n   *\n   * @throws {Error} - if `src` cannot be associated with a default or\n   * registered variant.\n   */\n  defaultGetSourceVariant(src) {\n    if (src.hasOwnProperty(this.discriminator.property)) {\n      if (this.defaultLayout\n          && src.hasOwnProperty(this.defaultLayout.property)) {\n        return undefined;\n      }\n      const vlo = this.registry[src[this.discriminator.property]];\n      if (vlo\n          && ((!vlo.layout)\n              || src.hasOwnProperty(vlo.property))) {\n        return vlo;\n      }\n    } else {\n      for (const tag in this.registry) {\n        const vlo = this.registry[tag];\n        if (src.hasOwnProperty(vlo.property)) {\n          return vlo;\n        }\n      }\n    }\n    throw new Error('unable to infer src variant');\n  }\n\n  /** Implement {@link Layout#decode|decode} for {@link Union}.\n   *\n   * If the variant is {@link Union#addVariant|registered} the return\n   * value is an instance of that variant, with no explicit\n   * discriminator.  Otherwise the {@link Union#defaultLayout|default\n   * layout} is used to decode the content. */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let dest;\n    const dlo = this.discriminator;\n    const discr = dlo.decode(b, offset);\n    let clo = this.registry[discr];\n    if (undefined === clo) {\n      let contentOffset = 0;\n      clo = this.defaultLayout;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dest = this.makeDestinationObject();\n      dest[dlo.property] = discr;\n      dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);\n    } else {\n      dest = clo.decode(b, offset);\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Union}.\n   *\n   * This API assumes the `src` object is consistent with the union's\n   * {@link Union#defaultLayout|default layout}.  To encode variants\n   * use the appropriate variant-specific {@link VariantLayout#encode}\n   * method. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const vlo = this.getSourceVariant(src);\n    if (undefined === vlo) {\n      const dlo = this.discriminator;\n      const clo = this.defaultLayout;\n      let contentOffset = 0;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dlo.encode(src[dlo.property], b, offset);\n      return contentOffset + clo.encode(src[clo.property], b,\n                                        offset + contentOffset);\n    }\n    return vlo.encode(src, b, offset);\n  }\n\n  /** Register a new variant structure within a union.  The newly\n   * created variant is returned.\n   *\n   * @param {Number} variant - initializer for {@link\n   * VariantLayout#variant|variant}.\n   *\n   * @param {Layout} layout - initializer for {@link\n   * VariantLayout#layout|layout}.\n   *\n   * @param {String} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {VariantLayout} */\n  addVariant(variant, layout, property) {\n    const rv = new VariantLayout(this, variant, layout, property);\n    this.registry[variant] = rv;\n    return rv;\n  }\n\n  /**\n   * Get the layout associated with a registered variant.\n   *\n   * If `vb` does not produce a registered variant the function returns\n   * `undefined`.\n   *\n   * @param {(Number|Buffer)} vb - either the variant number, or a\n   * buffer from which the discriminator is to be read.\n   *\n   * @param {Number} offset - offset into `vb` for the start of the\n   * union.  Used only when `vb` is an instance of {Buffer}.\n   *\n   * @return {({VariantLayout}|undefined)}\n   */\n  getVariant(vb, offset) {\n    let variant = vb;\n    if (Buffer.isBuffer(vb)) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      variant = this.discriminator.decode(vb, offset);\n    }\n    return this.registry[variant];\n  }\n}\n\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */\nclass VariantLayout extends Layout {\n  constructor(union, variant, layout, property) {\n    if (!(union instanceof Union)) {\n      throw new TypeError('union must be a Union');\n    }\n    if ((!Number.isInteger(variant)) || (0 > variant)) {\n      throw new TypeError('variant must be a (non-negative) integer');\n    }\n    if (('string' === typeof layout)\n        && (undefined === property)) {\n      property = layout;\n      layout = null;\n    }\n    if (layout) {\n      if (!(layout instanceof Layout)) {\n        throw new TypeError('layout must be a Layout');\n      }\n      if ((null !== union.defaultLayout)\n          && (0 <= layout.span)\n          && (layout.span > union.defaultLayout.span)) {\n        throw new Error('variant span exceeds span of containing union');\n      }\n      if ('string' !== typeof property) {\n        throw new TypeError('variant must have a String property');\n      }\n    }\n    let span = union.span;\n    if (0 > union.span) {\n      span = layout ? layout.span : 0;\n      if ((0 <= span) && union.usesPrefixDiscriminator) {\n        span += union.discriminator.layout.span;\n      }\n    }\n    super(span, property);\n\n    /** The {@link Union} to which this variant belongs. */\n    this.union = union;\n\n    /** The unsigned integral value identifying this variant within\n     * the {@link Union#discriminator|discriminator} of the containing\n     * union. */\n    this.variant = variant;\n\n    /** The {@link Layout} to be used when reading/writing the\n     * non-discriminator part of the {@link\n     * VariantLayout#union|union}.  If `null` the variant carries no\n     * data. */\n    this.layout = layout || null;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      /* Will be equal to the containing union span if that is not\n       * variable. */\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    /* Span is defined solely by the variant (and prefix discriminator) */\n    return contentOffset + this.layout.getSpan(b, offset + contentOffset);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n    if (undefined === offset) {\n      offset = 0;\n    }\n    if (this !== this.union.getVariant(b, offset)) {\n      throw new Error('variant mismatch');\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout) {\n      dest[this.property] = this.layout.decode(b, offset + contentOffset);\n    } else if (this.property) {\n      dest[this.property] = true;\n    } else if (this.union.usesPrefixDiscriminator) {\n      dest[this.union.discriminator.property] = this.variant;\n    }\n    return dest;\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout\n        && (!src.hasOwnProperty(this.property))) {\n      throw new TypeError('variant lacks property ' + this.property);\n    }\n    this.union.discriminator.encode(this.variant, b, offset);\n    let span = contentOffset;\n    if (this.layout) {\n      this.layout.encode(src[this.property], b, offset + contentOffset);\n      span += this.layout.getSpan(b, offset + contentOffset);\n      if ((0 <= this.union.span)\n          && (span > this.union.span)) {\n        throw new Error('encoded variant overruns containing union');\n      }\n    }\n    return span;\n  }\n\n  /** Delegate {@link Layout#fromArray|fromArray} to {@link\n   * VariantLayout#layout|layout}. */\n  fromArray(values) {\n    if (this.layout) {\n      return this.layout.fromArray(values);\n    }\n  }\n}\n\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */\nfunction fixBitwiseResult(v) {\n  if (0 > v) {\n    v += 0x100000000;\n  }\n  return v;\n}\n\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass BitStructure extends Layout {\n  constructor(word, msb, property) {\n    if (!((word instanceof UInt)\n          || (word instanceof UIntBE))) {\n      throw new TypeError('word must be a UInt or UIntBE layout');\n    }\n    if (('string' === typeof msb)\n        && (undefined === property)) {\n      property = msb;\n      msb = undefined;\n    }\n    if (4 < word.span) {\n      throw new RangeError('word cannot exceed 32 bits');\n    }\n    super(word.span, property);\n\n    /** The layout used for the packed value.  {@link BitField}\n     * instances are packed sequentially depending on {@link\n     * BitStructure#msb|msb}. */\n    this.word = word;\n\n    /** Whether the bit sequences are packed starting at the most\n     * significant bit growing down (`true`), or the least significant\n     * bit growing up (`false`).\n     *\n     * **NOTE** Regardless of this value, the least significant bit of\n     * any {@link BitField} value is the least significant bit of the\n     * corresponding section of the packed value. */\n    this.msb = !!msb;\n\n    /** The sequence of {@link BitField} layouts that comprise the\n     * packed structure.\n     *\n     * **NOTE** The array remains mutable to allow fields to be {@link\n     * BitStructure#addField|added} after construction.  Users should\n     * not manipulate the content of this property.*/\n    this.fields = [];\n\n    /* Storage for the value.  Capture a variable instead of using an\n     * instance property because we don't want anything to change the\n     * value without going through the mutator. */\n    let value = 0;\n    this._packedSetValue = function(v) {\n      value = fixBitwiseResult(v);\n      return this;\n    };\n    this._packedGetValue = function() {\n      return value;\n    };\n  }\n\n  /** @override */\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(value);\n      }\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the packed\n   * value is left unmodified.  Unused bits are also left unmodified. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          fd.encode(fv);\n        }\n      }\n    }\n    return this.word.encode(this._packedGetValue(), b, offset);\n  }\n\n  /** Register a new bitfield with a containing bit structure.  The\n   * resulting bitfield is returned.\n   *\n   * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {BitField} */\n  addField(bits, property) {\n    const bf = new BitField(this, bits, property);\n    this.fields.push(bf);\n    return bf;\n  }\n\n  /** As with {@link BitStructure#addField|addField} for single-bit\n   * fields with `boolean` value representation.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {Boolean} */\n  addBoolean(property) {\n    // This is my Boolean, not the Javascript one.\n    // eslint-disable-next-line no-new-wrappers\n    const bf = new Boolean(this, property);\n    this.fields.push(bf);\n    return bf;\n  }\n\n  /**\n   * Get access to the bit field for a given property.\n   *\n   * @param {String} property - the bit field of interest.\n   *\n   * @return {BitField} - the field associated with `property`, or\n   * undefined if there is no such property.\n   */\n  fieldFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n}\n\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */\nclass BitField {\n  constructor(container, bits, property) {\n    if (!(container instanceof BitStructure)) {\n      throw new TypeError('container must be a BitStructure');\n    }\n    if ((!Number.isInteger(bits)) || (0 >= bits)) {\n      throw new TypeError('bits must be positive integer');\n    }\n    const totalBits = 8 * container.span;\n    const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);\n    if ((bits + usedBits) > totalBits) {\n      throw new Error('bits too long for span remainder ('\n                      + (totalBits - usedBits) + ' of '\n                      + totalBits + ' remain)');\n    }\n\n    /** The {@link BitStructure} instance to which this bit field\n     * belongs. */\n    this.container = container;\n\n    /** The span of this value in bits. */\n    this.bits = bits;\n\n    /** A mask of {@link BitField#bits|bits} bits isolating value bits\n     * that fit within the field.\n     *\n     * That is, it masks a value that has not yet been shifted into\n     * position within its containing packed integer. */\n    this.valueMask = (1 << bits) - 1;\n    if (32 === bits) { // shifted value out of range\n      this.valueMask = 0xFFFFFFFF;\n    }\n\n    /** The offset of the value within the containing packed unsigned\n     * integer.  The least significant bit of the packed value is at\n     * offset zero, regardless of bit ordering used. */\n    this.start = usedBits;\n    if (this.container.msb) {\n      this.start = totalBits - usedBits - bits;\n    }\n\n    /** A mask of {@link BitField#bits|bits} isolating the field value\n     * within the containing packed unsigned integer. */\n    this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n\n    /** The property name used when this bitfield is represented in an\n     * Object.\n     *\n     * Intended to be functionally equivalent to {@link\n     * Layout#property}.\n     *\n     * If left undefined the corresponding span of bits will be\n     * treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field. */\n  decode() {\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(word & this.wordMask);\n    const value = wordValue >>> this.start;\n    return value;\n  }\n\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field.\n   *\n   * **NOTE** This is not a specialization of {@link\n   * Layout#encode|Layout.encode} and there is no return value. */\n  encode(value) {\n    if ((!Number.isInteger(value))\n        || (value !== fixBitwiseResult(value & this.valueMask))) {\n      throw new TypeError(nameWithProperty('BitField.encode', this)\n                          + ' value must be integer not exceeding ' + this.valueMask);\n    }\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(value << this.start);\n    this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask)\n                                   | wordValue);\n  };\n}\n\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */\n/* eslint-disable no-extend-native */\nclass Boolean extends BitField {\n  constructor(container, property) {\n    super(container, 1, property);\n  }\n\n  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n   *\n   * @returns {boolean} */\n  decode(b, offset) {\n    return !!BitField.prototype.decode.call(this, b, offset);\n  }\n\n  /** @override */\n  encode(value) {\n    if ('boolean' === typeof value) {\n      // BitField requires integer values\n      value = +value;\n    }\n    return BitField.prototype.encode.call(this, value);\n  }\n}\n/* eslint-enable no-extend-native */\n\n/**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Buffer.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Blob extends Layout {\n  constructor(length, property) {\n    if (!(((length instanceof ExternalLayout) && length.isCount())\n          || (Number.isInteger(length) && (0 <= length)))) {\n      throw new TypeError('length must be positive integer '\n                          + 'or an unsigned integer ExternalLayout');\n    }\n\n    let span = -1;\n    if (!(length instanceof ExternalLayout)) {\n      span = length;\n    }\n    super(span, property);\n\n    /** The number of bytes in the blob.\n     *\n     * This may be a non-negative integer, or an instance of {@link\n     * ExternalLayout} that satisfies {@link\n     * ExternalLayout#isCount|isCount()}. */\n    this.length = length;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return b.slice(offset, offset + span);\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Blob}.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    let span = this.length;\n    if (this.length instanceof ExternalLayout) {\n      span = src.length;\n    }\n    if (!(Buffer.isBuffer(src)\n          && (span === src.length))) {\n      throw new TypeError(nameWithProperty('Blob.encode', this)\n                          + ' requires (length ' + span + ') Buffer as src');\n    }\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    b.write(src.toString('hex'), offset, span, 'hex');\n    if (this.length instanceof ExternalLayout) {\n      this.length.encode(span, b, offset);\n    }\n    return span;\n  }\n}\n\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass CString extends Layout {\n  constructor(property) {\n    super(-1, property);\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (!Buffer.isBuffer(b)) {\n      throw new TypeError('b must be a Buffer');\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let idx = offset;\n    while ((idx < b.length) && (0 !== b[idx])) {\n      idx += 1;\n    }\n    return 1 + idx - offset;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.getSpan(b, offset);\n    return b.slice(offset, offset + span - 1).toString('utf-8');\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n    const srcb = new Buffer(src, 'utf8');\n    const span = srcb.length;\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    srcb.copy(b, offset);\n    b[offset + span] = 0;\n    return span + 1;\n  }\n}\n\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UTF8 extends Layout {\n  constructor(maxSpan, property) {\n    if (('string' === typeof maxSpan)\n        && (undefined === property)) {\n      property = maxSpan;\n      maxSpan = undefined;\n    }\n    if (undefined === maxSpan) {\n      maxSpan = -1;\n    } else if (!Number.isInteger(maxSpan)) {\n      throw new TypeError('maxSpan must be an integer');\n    }\n\n    super(-1, property);\n\n    /** The maximum span of the layout in bytes.\n     *\n     * Positive values are generally expected.  Zero is abnormal.\n     * Attempts to encode or decode a value that exceeds this length\n     * will throw a `RangeError`.\n     *\n     * A negative value indicates that there is no bound on the length\n     * of the content. */\n    this.maxSpan = maxSpan;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (!Buffer.isBuffer(b)) {\n      throw new TypeError('b must be a Buffer');\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.length - offset;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.getSpan(b, offset);\n    if ((0 <= this.maxSpan)\n        && (this.maxSpan < span)) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    return b.slice(offset, offset + span).toString('utf-8');\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n    const srcb = new Buffer(src, 'utf8');\n    const span = srcb.length;\n    if ((0 <= this.maxSpan)\n        && (this.maxSpan < span)) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    srcb.copy(b, offset);\n    return span;\n  }\n}\n\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Constant extends Layout {\n  constructor(value, property) {\n    super(0, property);\n\n    /** The value produced by this constant when the layout is {@link\n     * Constant#decode|decoded}.\n     *\n     * Any JavaScript value including `null` and `undefined` is\n     * permitted.\n     *\n     * **WARNING** If `value` passed in the constructor was not\n     * frozen, it is possible for users of decoded values to change\n     * the content of the value. */\n    this.value = value;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    return this.value;\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    /* Constants take no space */\n    return 0;\n  }\n}\n\nexports.ExternalLayout = ExternalLayout;\nexports.GreedyCount = GreedyCount;\nexports.OffsetLayout = OffsetLayout;\nexports.UInt = UInt;\nexports.UIntBE = UIntBE;\nexports.Int = Int;\nexports.IntBE = IntBE;\nexports.Float = Float;\nexports.FloatBE = FloatBE;\nexports.Double = Double;\nexports.DoubleBE = DoubleBE;\nexports.Sequence = Sequence;\nexports.Structure = Structure;\nexports.UnionDiscriminator = UnionDiscriminator;\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\nexports.Union = Union;\nexports.VariantLayout = VariantLayout;\nexports.BitStructure = BitStructure;\nexports.BitField = BitField;\nexports.Boolean = Boolean;\nexports.Blob = Blob;\nexports.CString = CString;\nexports.UTF8 = UTF8;\nexports.Constant = Constant;\n\n/** Factory for {@link GreedyCount}. */\nexports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));\n\n/** Factory for {@link OffsetLayout}. */\nexports.offset = ((layout, offset, property) => new OffsetLayout(layout, offset, property));\n\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */\nexports.u8 = (property => new UInt(1, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16 = (property => new UInt(2, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24 = (property => new UInt(3, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32 = (property => new UInt(4, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40 = (property => new UInt(5, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48 = (property => new UInt(6, property));\n\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64 = (property => new NearUInt64(property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16be = (property => new UIntBE(2, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24be = (property => new UIntBE(3, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32be = (property => new UIntBE(4, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40be = (property => new UIntBE(5, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48be = (property => new UIntBE(6, property));\n\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64be = (property => new NearUInt64BE(property));\n\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */\nexports.s8 = (property => new Int(1, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */\nexports.s16 = (property => new Int(2, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */\nexports.s24 = (property => new Int(3, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */\nexports.s32 = (property => new Int(4, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */\nexports.s40 = (property => new Int(5, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */\nexports.s48 = (property => new Int(6, property));\n\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64 = (property => new NearInt64(property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */\nexports.s16be = (property => new IntBE(2, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */\nexports.s24be = (property => new IntBE(3, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */\nexports.s32be = (property => new IntBE(4, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */\nexports.s40be = (property => new IntBE(5, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */\nexports.s48be = (property => new IntBE(6, property));\n\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64be = (property => new NearInt64BE(property));\n\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\nexports.f32 = (property => new Float(property));\n\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\nexports.f32be = (property => new FloatBE(property));\n\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\nexports.f64 = (property => new Double(property));\n\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\nexports.f64be = (property => new DoubleBE(property));\n\n/** Factory for {@link Structure} values. */\nexports.struct = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));\n\n/** Factory for {@link BitStructure} values. */\nexports.bits = ((word, msb, property) => new BitStructure(word, msb, property));\n\n/** Factory for {@link Sequence} values. */\nexports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));\n\n/** Factory for {@link Union} values. */\nexports.union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));\n\n/** Factory for {@link UnionLayoutDiscriminator} values. */\nexports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator(layout, property));\n\n/** Factory for {@link Blob} values. */\nexports.blob = ((length, property) => new Blob(length, property));\n\n/** Factory for {@link CString} values. */\nexports.cstr = (property => new CString(property));\n\n/** Factory for {@link UTF8} values. */\nexports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));\n\n/** Factory for {@link Constant} values. */\nexports.const = ((value, property) => new Constant(value, property));\n","'use strict';\n\nconst preserveCamelCase = string => {\n\tlet isLastCharLower = false;\n\tlet isLastCharUpper = false;\n\tlet isLastLastCharUpper = false;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tconst character = string[i];\n\n\t\tif (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {\n\t\t\tstring = string.slice(0, i) + '-' + string.slice(i);\n\t\t\tisLastCharLower = false;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = true;\n\t\t\ti++;\n\t\t} else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {\n\t\t\tstring = string.slice(0, i - 1) + '-' + string.slice(i - 1);\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = false;\n\t\t\tisLastCharLower = true;\n\t\t} else {\n\t\t\tisLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;\n\t\t}\n\t}\n\n\treturn string;\n};\n\nconst camelCase = (input, options) => {\n\tif (!(typeof input === 'string' || Array.isArray(input))) {\n\t\tthrow new TypeError('Expected the input to be `string | string[]`');\n\t}\n\n\toptions = Object.assign({\n\t\tpascalCase: false\n\t}, options);\n\n\tconst postProcess = x => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;\n\n\tif (Array.isArray(input)) {\n\t\tinput = input.map(x => x.trim())\n\t\t\t.filter(x => x.length)\n\t\t\t.join('-');\n\t} else {\n\t\tinput = input.trim();\n\t}\n\n\tif (input.length === 0) {\n\t\treturn '';\n\t}\n\n\tif (input.length === 1) {\n\t\treturn options.pascalCase ? input.toUpperCase() : input.toLowerCase();\n\t}\n\n\tconst hasUpperCase = input !== input.toLowerCase();\n\n\tif (hasUpperCase) {\n\t\tinput = preserveCamelCase(input);\n\t}\n\n\tinput = input\n\t\t.replace(/^[_.\\- ]+/, '')\n\t\t.toLowerCase()\n\t\t.replace(/[_.\\- ]+(\\w|$)/g, (_, p1) => p1.toUpperCase())\n\t\t.replace(/\\d+(\\w|$)/g, m => m.toUpperCase());\n\n\treturn postProcess(input);\n};\n\nmodule.exports = camelCase;\n// TODO: Remove this for the next major release\nmodule.exports.default = camelCase;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n"],"names":["colorNums","white","black","blue","cyan","green","magenta","red","yellow","brightBlack","brightRed","brightGreen","brightYellow","brightBlue","brightMagenta","brightCyan","brightWhite","backgroundColorNums","bgBlack","bgRed","bgGreen","bgYellow","bgBlue","bgMagenta","bgCyan","bgWhite","bgBrightBlack","bgBrightRed","bgBrightGreen","bgBrightYellow","bgBrightBlue","bgBrightMagenta","bgBrightCyan","bgBrightWhite","open","close","colors","Object","keys","forEach","k","o","c","s","module","exports","Layout","constructor","span","property","Number","isInteger","TypeError","this","makeDestinationObject","decode","b","offset","Error","encode","src","getSpan","RangeError","replicate","rv","create","prototype","assign","fromArray","values","nameWithProperty","name","lo","bindConstructorLayout","Class","layout","hasOwnProperty","layout_","boundConstructor_","defineProperty","value","writable","ExternalLayout","isCount","GreedyCount","elementSpan","undefined","super","rem","length","Math","floor","OffsetLayout","UInt","UIntBE","readUIntLE","writeUIntLE","readUIntBE","writeUIntBE","Int","readIntLE","writeIntLE","IntBE","readIntBE","writeIntBE","V2E32","pow","divmodInt64","hi32","lo32","roundedInt64","NearUInt64","readUInt32LE","split","writeUInt32LE","NearUInt64BE","readUInt32BE","writeUInt32BE","NearInt64","readInt32LE","writeInt32LE","NearInt64BE","readInt32BE","writeInt32BE","Float","readFloatLE","writeFloatLE","FloatBE","readFloatBE","writeFloatBE","Double","readDoubleLE","writeDoubleLE","DoubleBE","readDoubleBE","writeDoubleBE","Sequence","elementLayout","count","idx","i","push","elo","reduce","v","Structure","fields","decodePrefixes","Array","isArray","acc","fd","e","fsp","dest","firstOffset","lastOffset","lastWrote","fv","shift","layoutFor","offsetOf","UnionDiscriminator","UnionLayoutDiscriminator","Union","discr","defaultLayout","upv","discriminator","usesPrefixDiscriminator","registry","boundGetSourceVariant","defaultGetSourceVariant","bind","getSourceVariant","configGetSourceVariant","gsv","vlo","getVariant","tag","dlo","clo","contentOffset","addVariant","variant","VariantLayout","vb","Buffer","isBuffer","union","fixBitwiseResult","BitStructure","word","msb","_packedSetValue","_packedGetValue","addField","bits","bf","BitField","addBoolean","Boolean","fieldFor","container","totalBits","usedBits","sum","valueMask","start","wordMask","wordValue","call","Blob","slice","write","toString","CString","srcb","copy","UTF8","maxSpan","Constant","greedy","u8","u16","u24","u32","u40","u48","nu64","u16be","u24be","u32be","u40be","u48be","nu64be","s8","s16","s24","s32","s40","s48","ns64","s16be","s24be","s32be","s40be","s48be","ns64be","f32","f32be","f64","f64be","struct","seq","unionLayoutDiscriminator","blob","cstr","utf8","camelCase","input","options","pascalCase","map","x","trim","filter","join","toUpperCase","toLowerCase","string","isLastCharLower","isLastCharUpper","isLastLastCharUpper","character","test","preserveCamelCase","replace","_","p1","m","charAt","h","d","w","y","plural","ms","msAbs","n","isPlural","round","val","type","parse","str","String","match","exec","parseFloat","isFinite","long","fmtLong","abs","fmtShort","JSON","stringify","formatArgs","args","useColors","namespace","humanize","diff","color","splice","index","lastC","save","namespaces","storage","setItem","removeItem","error","load","r","getItem","DEBUG","window","process","__nwjs","navigator","userAgent","document","documentElement","style","WebkitAppearance","console","firebug","exception","table","parseInt","RegExp","$1","localstorage","localStorage","destroy","warned","warn","log","debug","formatters","j","message","setup","env","createDebug","prevTime","namespacesCache","enabledCache","enableOverride","enabled","self","curr","Date","prev","coerce","unshift","format","formatter","apply","selectColor","extend","enumerable","configurable","get","set","init","delimiter","newDebug","toNamespace","regexp","substring","default","stack","disable","names","skips","enable","len","key","hash","charCodeAt"],"sourceRoot":""}
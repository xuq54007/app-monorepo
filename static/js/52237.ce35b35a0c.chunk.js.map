{"version":3,"file":"static/js/52237.ce35b35a0c.chunk.js","mappings":"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","sources":["webpack://web/../../node_modules/@onekeyfe/coinselect/utils.js","webpack://web/../../packages/core/src/base/ChainSigner.ts","webpack://web/../../packages/core/src/base/CoreChainApiBase.ts","webpack://web/../../packages/core/src/chains/cfx/CoreChainImported.ts","webpack://web/../../node_modules/cip-23/node_modules/superstruct/lib/index.es.js","webpack://web/../../node_modules/cip-23/lib/es/types.js","webpack://web/../../node_modules/cip-23/lib/es/utils/buffer.js","webpack://web/../../node_modules/@findeth/abi/lib/es/utils/buffer.js","webpack://web/../../node_modules/@findeth/abi/lib/es/parsers/bytes.js","webpack://web/../../node_modules/@findeth/abi/lib/es/parsers/fixed-bytes.js","webpack://web/../../node_modules/@findeth/abi/lib/es/parsers/number.js","webpack://web/../../node_modules/@findeth/abi/lib/es/parsers/array.js","webpack://web/../../node_modules/@findeth/abi/lib/es/parsers/address.js","webpack://web/../../node_modules/@findeth/abi/lib/es/utils/twos-complement.js","webpack://web/../../node_modules/@findeth/abi/lib/es/parsers/string.js","webpack://web/../../node_modules/@findeth/abi/lib/es/abi.js","webpack://web/../../node_modules/cip-23/lib/es/utils/abi.js","webpack://web/../../node_modules/cip-23/lib/es/cip-23.js","webpack://web/../../node_modules/cip-23/lib/es/utils/json.js","webpack://web/../../packages/core/src/chains/cfx/CoreChainSoftware.ts","webpack://web/../../packages/core/src/utils/index.ts"],"sourcesContent":["// baseline estimates, used to improve performance\nvar TX_EMPTY_SIZE = 4 + 1 + 1 + 4\nvar TX_INPUT_BASE = 32 + 4 + 1 + 4\nvar TX_INPUT_PUBKEYHASH = 107\nvar TX_OUTPUT_BASE = 8 + 1\nvar TX_OUTPUT_PUBKEYHASH = 25\nvar OP_RETURN_OVERHEAD = 1 + 8 + 1\n\nfunction inputBytes (input) {\n  return TX_INPUT_BASE + (input.script ? input.script.length : TX_INPUT_PUBKEYHASH)\n}\n\nfunction outputBytes (output) {\n  if (output.script) {\n    return OP_RETURN_OVERHEAD + output.script.length + (output.script.length >= 74 ? 2 : 1)\n  }\n  return TX_OUTPUT_BASE + (output.script ? output.script.length : TX_OUTPUT_PUBKEYHASH)\n}\n\nfunction dustThreshold (output, feeRate) {\n  /* ... classify the output for input estimate  */\n  return inputBytes({}) * feeRate\n}\n\nfunction transactionBytes (inputs, outputs) {\n  return TX_EMPTY_SIZE +\n    inputs.reduce(function (a, x) { return a + inputBytes(x) }, 0) +\n    outputs.reduce(function (a, x) { return a + outputBytes(x) }, 0)\n}\n\nfunction uintOrNaN (v) {\n  if (typeof v !== 'number') return NaN\n  if (!isFinite(v)) return NaN\n  if (Math.floor(v) !== v) return NaN\n  if (v < 0) return NaN\n  return v\n}\n\nfunction sumForgiving (range) {\n  return range.reduce(function (a, x) { return a + (isFinite(x.value) ? x.value : 0) }, 0)\n}\n\nfunction sumOrNaN (range) {\n  return range.reduce(function (a, x) { return a + uintOrNaN(x.value) }, 0)\n}\n\nvar BLANK_OUTPUT = outputBytes({})\n\nfunction finalize (inputs, outputs, feeRate) {\n  var bytesAccum = transactionBytes(inputs, outputs)\n  var feeAfterExtraOutput = feeRate * (bytesAccum + BLANK_OUTPUT)\n  var remainderAfterExtraOutput = sumOrNaN(inputs) - (sumOrNaN(outputs) + feeAfterExtraOutput)\n\n  // is it worth a change output?\n  if (remainderAfterExtraOutput > dustThreshold({}, feeRate)) {\n    outputs = outputs.concat({ value: remainderAfterExtraOutput })\n  }\n\n  var fee = sumOrNaN(inputs) - sumOrNaN(outputs)\n  if (!isFinite(fee)) return { fee: feeRate * bytesAccum }\n\n  return {\n    inputs: inputs,\n    outputs: outputs,\n    fee: fee\n  }\n}\n\nmodule.exports = {\n  dustThreshold: dustThreshold,\n  finalize: finalize,\n  inputBytes: inputBytes,\n  outputBytes: outputBytes,\n  sumOrNaN: sumOrNaN,\n  sumForgiving: sumForgiving,\n  transactionBytes: transactionBytes,\n  uintOrNaN: uintOrNaN\n}\n","import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";import _createClass from\"@babel/runtime/helpers/createClass\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));}catch(t){}return(_isNativeReflectConstruct=function(){return!!t;})();}import bufferUtils from'@onekeyhq/shared/src/utils/bufferUtils';import{N,decrypt,sign as _sign,uncompressPublicKey,verify}from\"../secret\";export var Verifier=function(){function Verifier(pub,curve){this.curve=curve;this.compressedPublicKey=Buffer.from(pub,'hex');this.uncompressedPublicKey=uncompressPublicKey(curve,this.compressedPublicKey);}var _proto=Verifier.prototype;_proto.getPubkey=function getPubkey(compressed){return Promise.resolve(compressed?this.compressedPublicKey:this.uncompressedPublicKey);};_proto.getPubkeyHex=function(){var _getPubkeyHex=_asyncToGenerator(function*(compressed){return bufferUtils.bytesToHex(yield this.getPubkey(compressed));});function getPubkeyHex(_x){return _getPubkeyHex.apply(this,arguments);}return getPubkeyHex;}();_proto.verify=function verify(){return Promise.resolve(Buffer.from([]));};_proto.verifySignature=function verifySignature({publicKey,digest,signature}){var p=bufferUtils.toBuffer(publicKey);var d=bufferUtils.toBuffer(digest);var s=bufferUtils.toBuffer(signature);var{curve}=this;var result=verify(curve,p,d,s);return Promise.resolve(result);};return _createClass(Verifier);}();export var ChainSigner=function(_Verifier){_inherits(ChainSigner,_Verifier);var _super=_createSuper(ChainSigner);function ChainSigner(encryptedPrivateKey,password,curve){var _this;var pub=N(curve,{key:encryptedPrivateKey,chainCode:Buffer.alloc(32)},password).key.toString('hex');_this=_super.call(this,pub,curve);_this.encryptedPrivateKey=encryptedPrivateKey;_this.password=password;_this.curve=curve;return _this;}var _proto2=ChainSigner.prototype;_proto2.getPrvkey=function getPrvkey(){return Promise.resolve(decrypt(this.password,this.encryptedPrivateKey));};_proto2.getPrvkeyHex=function(){var _getPrvkeyHex=_asyncToGenerator(function*(){return bufferUtils.bytesToHex(yield this.getPrvkey());});function getPrvkeyHex(){return _getPrvkeyHex.apply(this,arguments);}return getPrvkeyHex;}();_proto2.sign=function sign(digest){var signature=_sign(this.curve,this.encryptedPrivateKey,digest,this.password);if(this.curve==='secp256k1'){return Promise.resolve([signature.slice(0,-1),signature[signature.length-1]]);}return Promise.resolve([signature,0]);};return _createClass(ChainSigner);}(Verifier);","import _merge from\"lodash/merge\";import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";import _createClass from\"@babel/runtime/helpers/createClass\";function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}import{NotImplemented,OneKeyInternalError}from'@onekeyhq/shared/src/errors';import bufferUtils from'@onekeyhq/shared/src/utils/bufferUtils';import{batchGetPrivateKeys,batchGetPublicKeysAsync,decrypt,decryptImportedCredential,ed25519,encrypt,nistp256,secp256k1}from\"../secret\";import{ECoreCredentialType}from\"../types\";import{slicePathTemplate}from\"../utils\";import{ChainSigner}from\"./ChainSigner\";export var CoreChainApiBase=function(){function CoreChainApiBase(){}var _proto=CoreChainApiBase.prototype;_proto.baseGetCurve=function baseGetCurve(curveName){switch(curveName){case'ed25519':return ed25519;case'secp256k1':return secp256k1;case'nistp256':return nistp256;default:throw new OneKeyInternalError('Unsupported curve');}};_proto.baseCreateSigner=function(){var _baseCreateSigner=_asyncToGenerator(function*({curve,privateKey,password}){if(typeof password==='undefined'){throw new OneKeyInternalError('Software signing requires a password.');}var privateKeyBuffer=bufferUtils.toBuffer(privateKey);return Promise.resolve(new ChainSigner(privateKeyBuffer,password,curve));});function baseCreateSigner(_x){return _baseCreateSigner.apply(this,arguments);}return baseCreateSigner;}();_proto.baseGetSingleSigner=function(){var _baseGetSingleSigner=_asyncToGenerator(function*({payload,curve}){var privateKeys=yield this.getPrivateKeys(payload);var accountPath=payload.account.path;var privateKey=privateKeys[accountPath];var firstRelPath=payload?.relPaths?.[0];if(!privateKey&&firstRelPath){var fullPath=[accountPath,firstRelPath].join('/');privateKey=privateKeys[fullPath];}if(!privateKey){throw new Error(`No private key found: ${accountPath}`);}return this.baseCreateSigner({curve,privateKey,password:payload.password});});function baseGetSingleSigner(_x2){return _baseGetSingleSigner.apply(this,arguments);}return baseGetSingleSigner;}();_proto.baseGetPrivateKeys=function(){var _baseGetPrivateKeys=_asyncToGenerator(function*({payload,curve}){var{credentials,account,password,relPaths}=payload;var privateKeys={};if(credentials.hd&&credentials.imported){throw new OneKeyInternalError('getPrivateKeys ERROR: hd and imported credentials can NOT both set.');}if(credentials.hd){privateKeys=yield this.baseGetPrivateKeysHd({curve,account,hdCredential:credentials.hd,password,relPaths});}if(credentials.imported){var{privateKey:p}=decryptImportedCredential({password,credential:credentials.imported});var encryptPrivateKey=bufferUtils.bytesToHex(encrypt(password,p));privateKeys[account.path]=encryptPrivateKey;privateKeys['']=encryptPrivateKey;}if(!Object.keys(privateKeys).length){throw new Error('No private keys found');}return privateKeys;});function baseGetPrivateKeys(_x3){return _baseGetPrivateKeys.apply(this,arguments);}return baseGetPrivateKeys;}();_proto.baseGetPrivateKeysHd=function(){var _baseGetPrivateKeysHd=_asyncToGenerator(function*({curve,password,account,relPaths,hdCredential}){var{path}=account;var pathComponents=path.split('/');var usedRelativePaths=relPaths||[pathComponents.pop()];var basePath=pathComponents.join('/');if(usedRelativePaths.length===0){throw new OneKeyInternalError('getPrivateKeysHd ERROR: relPaths is empty.');}var keys=batchGetPrivateKeys(curve,hdCredential,password,basePath,usedRelativePaths);var map=keys.reduce(function(ret,key){var result=_objectSpread(_objectSpread({},ret),{},{[key.path]:bufferUtils.bytesToHex(key.extendedKey.key)});return result;},{});return map;});function baseGetPrivateKeysHd(_x4){return _baseGetPrivateKeysHd.apply(this,arguments);}return baseGetPrivateKeysHd;}();_proto.baseGetAddressesFromHd=function(){var _baseGetAddressesFromHd=_asyncToGenerator(function*(query,options){var _this=this;var{curve,generateFrom}=options;var{template,hdCredential,password,indexes}=query;var{pathPrefix,pathSuffix}=slicePathTemplate(template);var indexFormatted=indexes.map(function(index){return pathSuffix.replace('{index}',index.toString());});var isPrivateKeyMode=generateFrom==='privateKey';var pubkeyInfos=[];var pvtkeyInfos=[];if(isPrivateKeyMode){pvtkeyInfos=batchGetPrivateKeys(curve,hdCredential,password,pathPrefix,indexFormatted);}else{pubkeyInfos=yield batchGetPublicKeysAsync({curveName:curve,hdCredential,password,prefix:pathPrefix,relPaths:indexFormatted});}var infos=isPrivateKeyMode?pvtkeyInfos:pubkeyInfos;if(infos.length!==indexes.length){throw new OneKeyInternalError('Unable to get publick key.');}var addresses=yield Promise.all(infos.map(function(){var _ref=_asyncToGenerator(function*(info){var{path,extendedKey:{key}}=info;var publicKey;var result;if(isPrivateKeyMode){var privateKeyRaw=bufferUtils.bytesToHex(decrypt(password,key));result=yield _this.getAddressFromPrivate({networkInfo:query.networkInfo,privateKeyRaw,privateKeyInfo:info});}else{publicKey=key.toString('hex');result=yield _this.getAddressFromPublic({networkInfo:query.networkInfo,publicKey,publicKeyInfo:info});}return _merge({publicKey,path},result);});return function(_x7){return _ref.apply(this,arguments);};}()));return{addresses};});function baseGetAddressesFromHd(_x5,_x6){return _baseGetAddressesFromHd.apply(this,arguments);}return baseGetAddressesFromHd;}();_proto.baseGetCredentialsType=function baseGetCredentialsType({credentials}){if(credentials.hd&&credentials.imported){throw new OneKeyInternalError('getCredentialsType ERROR: hd and imported credentials can NOT both set.');}if(credentials.hd){return ECoreCredentialType.hd;}if(credentials.imported){return ECoreCredentialType.imported;}throw new OneKeyInternalError('getCredentialsType ERROR: no credentials found');};_proto.baseGetDefaultPrivateKey=function(){var _baseGetDefaultPrivateKey=_asyncToGenerator(function*(params){var privateKeysMap=yield this.getPrivateKeys(params);var[encryptedPrivateKey]=Object.values(privateKeysMap);return{privateKeyRaw:encryptedPrivateKey};});function baseGetDefaultPrivateKey(_x8){return _baseGetDefaultPrivateKey.apply(this,arguments);}return baseGetDefaultPrivateKey;}();_proto.validateXpub=function(){var _validateXpub=_asyncToGenerator(function*(params){throw new NotImplemented();});function validateXpub(_x9){return _validateXpub.apply(this,arguments);}return validateXpub;}();_proto.validateXprvt=function(){var _validateXprvt=_asyncToGenerator(function*(params){throw new NotImplemented();});function validateXprvt(_x10){return _validateXprvt.apply(this,arguments);}return validateXprvt;}();return _createClass(CoreChainApiBase);}();","import _createClass from\"@babel/runtime/helpers/createClass\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));}catch(t){}return(_isNativeReflectConstruct=function(){return!!t;})();}import CoreChainSoftware from\"./CoreChainSoftware\";var CoreChainImported=function(_CoreChainSoftware){_inherits(CoreChainImported,_CoreChainSoftware);var _super=_createSuper(CoreChainImported);function CoreChainImported(){return _super.apply(this,arguments);}return _createClass(CoreChainImported);}(CoreChainSoftware);export{CoreChainImported as default};","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context) {\n  if (result === true) ; else if (result === false) {\n    yield context.fail();\n  } else {\n    yield* result;\n  }\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nfunction iteratorShift(input) {\n  const {\n    done,\n    value\n  } = input.next();\n  return done ? undefined : value;\n}\n\n/**\n * `Struct` objects encapsulate the schema for a specific data type (with\n * optional coercion). You can then use the `assert`, `is` or `validate` helpers\n * to validate unknown data against a struct.\n */\n\nclass Struct {\n  constructor(props) {\n    const {\n      type,\n      schema,\n      coercer = value => value,\n      validator = () => [],\n      refiner = () => []\n    } = props;\n    this.type = type;\n    this.schema = schema;\n    this.coercer = coercer;\n    this.validator = validator;\n    this.refiner = refiner;\n  }\n\n}\n/**\n * `StructError` objects are thrown (or returned) by Superstruct when its\n * validation fails. The error represents the first error encountered during\n * validation. But they also have an `error.failures` property that holds\n * information for all of the failures encountered.\n */\n\nclass StructError extends TypeError {\n  constructor(failure, moreFailures) {\n    const {\n      path,\n      value,\n      type,\n      branch\n    } = failure,\n          rest = _objectWithoutProperties(failure, [\"path\", \"value\", \"type\", \"branch\"]);\n\n    const message = `Expected a value of type \\`${type}\\`${path.length ? ` for \\`${path.join('.')}\\`` : ''} but received \\`${JSON.stringify(value)}\\`.`;\n    let failuresResult;\n\n    function failures() {\n      if (!failuresResult) {\n        failuresResult = [failure, ...moreFailures];\n      }\n\n      return failuresResult;\n    }\n\n    super(message);\n    this.value = value;\n    Object.assign(this, rest);\n    this.type = type;\n    this.path = path;\n    this.branch = branch;\n    this.failures = failures;\n    this.stack = new Error().stack;\n    this.__proto__ = StructError.prototype;\n  }\n\n}\n/**\n * Assert that a value passes a `Struct`, throwing if it doesn't.\n */\n\nfunction assert(value, struct) {\n  const result = validate(value, struct);\n\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Coerce a value with the coercion logic of `Struct` and validate it.\n */\n\nfunction coerce(value, struct) {\n  const ret = struct.coercer(value);\n  assert(ret, struct);\n  return ret;\n}\n/**\n * Check if a value passes a `Struct`.\n */\n\nfunction is(value, struct) {\n  const result = validate(value, struct);\n  return !result[0];\n}\n/**\n * Validate a value against a `Struct`, returning an error if invalid.\n */\n\nfunction validate(value, struct, coercing = false) {\n  if (coercing) {\n    value = struct.coercer(value);\n  }\n\n  const failures = check(value, struct);\n  const failure = iteratorShift(failures);\n\n  if (failure) {\n    const error = new StructError(failure, failures);\n    return [error, undefined];\n  } else {\n    return [undefined, value];\n  }\n}\n/**\n * Check a value against a `Struct`, returning an iterable of failures.\n */\n\nfunction* check(value, struct, path = [], branch = []) {\n  const {\n    type\n  } = struct;\n  const ctx = {\n    value,\n    type,\n    branch,\n    path,\n\n    fail(props = {}) {\n      return _objectSpread2({\n        value,\n        type,\n        path,\n        branch: [...branch, value]\n      }, props);\n    },\n\n    check(v, s, parent, key) {\n      const p = parent !== undefined ? [...path, key] : path;\n      const b = parent !== undefined ? [...branch, parent] : branch;\n      return check(v, s, p, b);\n    }\n\n  };\n  const failures = toFailures(struct.validator(value, ctx), ctx);\n  const failure = iteratorShift(failures);\n\n  if (failure) {\n    yield failure;\n    yield* failures;\n  } else {\n    yield* toFailures(struct.refiner(value, ctx), ctx);\n  }\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n */\n\nfunction coercion(struct, coercer) {\n  const fn = struct.coercer;\n  return new Struct(_objectSpread2(_objectSpread2({}, struct), {}, {\n    coercer: value => {\n      return fn(coercer(value));\n    }\n  }));\n}\n/**\n * Augment a struct to coerce a default value for missing values.\n *\n * Note: You must use `coerce(value, Struct)` on the value before validating it\n * to have the value defaulted!\n */\n\nfunction defaulted(S, fallback, strict) {\n  return coercion(S, x => {\n    const f = typeof fallback === 'function' ? fallback() : fallback;\n\n    if (x === undefined) {\n      return f;\n    }\n\n    if (strict !== true && isPlainObject(x) && isPlainObject(f)) {\n      const ret = _objectSpread2({}, x);\n\n      let changed = false;\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key];\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        return ret;\n      }\n    }\n\n    return x;\n  });\n}\n/**\n * Coerce a value to mask its properties to only that defined in the struct.\n */\n\nfunction masked(S) {\n  return coercion(S, x => {\n    if (!isPlainObject(x)) {\n      return x;\n    }\n\n    const ret = {};\n\n    for (const key in S.schema) {\n      ret[key] = x[key];\n    }\n\n    return ret;\n  });\n}\n/**\n * Check if a value is a plain object.\n */\n\nfunction isPlainObject(value) {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Augment a string or array struct to constrain its length to zero.\n */\n\nfunction empty(S) {\n  return refinement(S, `${S.type} & Empty`, value => {\n    return value.length === 0;\n  });\n}\n/**\n * Augment a string or array struct to constrain its length to being between a\n * minimum and maximum size.\n */\n\nfunction length(S, min, max) {\n  return refinement(S, `${S.type} & Length<${min},${max}>`, value => {\n    return min < value.length && value.length < max;\n  });\n}\n/**\n * Refine a string struct to match a specific regexp pattern.\n */\n\nfunction pattern(S, regexp) {\n  return refinement(S, `${S.type} & Pattern<${regexp.source}>`, value => {\n    return regexp.test(value);\n  });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n */\n\nfunction refinement(struct, type, refiner) {\n  const fn = struct.refiner;\n  return new Struct(_objectSpread2(_objectSpread2({}, struct), {}, {\n    type,\n\n    *refiner(value, fail) {\n      yield* toFailures(fn(value, fail), fail);\n      yield* toFailures(refiner(value, fail), fail);\n    }\n\n  }));\n}\n\n/**\n * Validate any value.\n */\n\nfunction any() {\n  return struct('any', () => true);\n}\nfunction array(Element) {\n  return new Struct({\n    type: `Array<${Element ? Element.type : 'unknown'}>`,\n    schema: Element,\n    coercer: value => {\n      return Element && Array.isArray(value) ? value.map(v => coerce(v, Element)) : value;\n    },\n\n    *validator(value, ctx) {\n      if (!Array.isArray(value)) {\n        yield ctx.fail();\n        return;\n      }\n\n      if (Element) {\n        for (const [i, v] of value.entries()) {\n          yield* ctx.check(v, Element, value, i);\n        }\n      }\n    }\n\n  });\n}\n/**\n * Validate that boolean values.\n */\n\nfunction boolean() {\n  return struct('boolean', value => {\n    return typeof value === 'boolean';\n  });\n}\n/**\n * Validate that `Date` values.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nfunction date() {\n  return struct('Date', value => {\n    return value instanceof Date && !isNaN(value.getTime());\n  });\n}\n/**\n * Validate that a value dynamically, determing which struct to use at runtime.\n */\n\nfunction dynamic(fn) {\n  return struct('Dynamic<...>', (value, ctx) => {\n    return ctx.check(value, fn(value, ctx));\n  });\n}\nfunction enums(values) {\n  return struct(`Enum<${values.map(toLiteralString)}>`, value => {\n    return values.includes(value);\n  });\n}\n/**\n * Validate that a value is a function.\n */\n\nfunction func() {\n  return struct('Function', value => {\n    return typeof value === 'function';\n  });\n}\n/**\n * Validate that a value is an instance of a class.\n */\n\nfunction instance(Class) {\n  return struct(`InstanceOf<${Class.name}>`, value => {\n    return value instanceof Class;\n  });\n}\nfunction intersection(Structs) {\n  return struct(Structs.map(s => s.type).join(' & '), function* (value, ctx) {\n    for (const S of Structs) {\n      yield* ctx.check(value, S);\n    }\n  });\n}\n/**\n * Validate a value lazily, by constructing the struct right before the first\n * validation. This is useful for cases where you want to have self-referential\n * structs for nested data structures.\n */\n\nfunction lazy(fn) {\n  let S;\n  return struct('Lazy<...>', (value, ctx) => {\n    if (!S) {\n      S = fn();\n    }\n\n    return ctx.check(value, S);\n  });\n}\nfunction literal(constant) {\n  return struct(`Literal<${toLiteralString(constant)}>`, value => {\n    return value === constant;\n  });\n}\n/**\n * Validate that a value is a map with specific key and value entries.\n */\n\nfunction map(Key, Value) {\n  return struct(`Map<${Key.type},${Value.type}>`, function* (value, ctx) {\n    if (!(value instanceof Map)) {\n      yield ctx.fail();\n      return;\n    }\n\n    for (const [k, v] of value.entries()) {\n      yield* ctx.check(k, Key, value, k);\n      yield* ctx.check(v, Value, value, k);\n    }\n  });\n}\n/**\n * Validate that a value always fails.\n */\n\nfunction never() {\n  return struct('never', () => false);\n}\n/**\n * Augment a struct to make it accept `null` values.\n */\n\nfunction nullable(S) {\n  return new Struct({\n    type: `${S.type} | null`,\n    schema: S.schema,\n    validator: (value, ctx) => {\n      return value === null || ctx.check(value, S);\n    }\n  });\n}\n/**\n * Validate that a value is a number.\n */\n\nfunction number() {\n  return struct(`number`, value => {\n    return typeof value === 'number' && !isNaN(value);\n  });\n}\nfunction object(Structs) {\n  const knowns = Structs ? Object.keys(Structs) : [];\n  const Never = never();\n  return new Struct({\n    type: Structs ? `Object<{${knowns.join(',')}}>` : 'Object',\n    schema: Structs ? Structs : null,\n    coercer: Structs ? createObjectCoercer(Structs) : x => x,\n\n    *validator(value, ctx) {\n      if (typeof value !== 'object' || value == null) {\n        yield ctx.fail();\n        return;\n      }\n\n      if (Structs) {\n        const unknowns = new Set(Object.keys(value));\n\n        for (const key of knowns) {\n          unknowns.delete(key);\n          const Value = Structs[key];\n          const v = value[key];\n          yield* ctx.check(v, Value, value, key);\n        }\n\n        for (const key of unknowns) {\n          const v = value[key];\n          yield* ctx.check(v, Never, value, key);\n        }\n      }\n    }\n\n  });\n}\n/**\n * Augment a struct to make it optionally accept `undefined` values.\n */\n\nfunction optional(S) {\n  return new Struct({\n    type: `${S.type}?`,\n    schema: S.schema,\n    validator: (value, ctx) => {\n      return value === undefined || ctx.check(value, S);\n    }\n  });\n}\n/**\n * Validate that a partial object with specific entry values.\n */\n\nfunction partial(Structs) {\n  if (Structs instanceof Struct) {\n    Structs = Structs.schema;\n  }\n\n  const knowns = Object.keys(Structs);\n  const Never = never();\n  return new Struct({\n    type: `Partial<{${knowns.join(',')}}>`,\n    schema: Structs,\n    coercer: createObjectCoercer(Structs),\n\n    *validator(value, ctx) {\n      if (typeof value !== 'object' || value == null) {\n        yield ctx.fail();\n        return;\n      }\n\n      const unknowns = new Set(Object.keys(value));\n\n      for (const key of knowns) {\n        unknowns.delete(key);\n\n        if (!(key in value)) {\n          continue;\n        }\n\n        const Value = Structs[key];\n        const v = value[key];\n        yield* ctx.check(v, Value, value, key);\n      }\n\n      for (const key of unknowns) {\n        const v = value[key];\n        yield* ctx.check(v, Never, value, key);\n      }\n    }\n\n  });\n}\n/**\n * Validate that a value is a record with specific key and\n * value entries.\n */\n\nfunction record(Key, Value) {\n  return struct(`Record<${Key.type},${Value.type}>`, function* (value, ctx) {\n    if (typeof value !== 'object' || value == null) {\n      yield ctx.fail();\n      return;\n    }\n\n    for (const k in value) {\n      const v = value[k];\n      yield* ctx.check(k, Key, value, k);\n      yield* ctx.check(v, Value, value, k);\n    }\n  });\n}\n/**\n * Validate that a set of values matches a specific type.\n */\n\nfunction set(Element) {\n  return struct(`Set<${Element.type}>`, (value, ctx) => {\n    if (!(value instanceof Set)) {\n      return false;\n    }\n\n    for (const val of value) {\n      const [failure] = ctx.check(val, Element);\n\n      if (failure) {\n        return false;\n      }\n    }\n\n    return true;\n  });\n}\n/**\n * Validate that a value is a string.\n */\n\nfunction string() {\n  return struct('string', value => {\n    return typeof value === 'string';\n  });\n}\n/**\n * Define a `Struct` instance with a type and validation function.\n */\n\nfunction struct(name, validator) {\n  return new Struct({\n    type: name,\n    validator,\n    schema: null\n  });\n}\nfunction tuple(Elements) {\n  const Never = never();\n  return struct(`[${Elements.map(s => s.type).join(',')}]`, function* (value, ctx) {\n    if (!Array.isArray(value)) {\n      yield ctx.fail();\n      return;\n    }\n\n    for (const [index, Element] of Elements.entries()) {\n      const v = value[index];\n      yield* ctx.check(v, Element, value, index);\n    }\n\n    if (value.length > Elements.length) {\n      const index = Elements.length;\n      const v = value[index];\n      yield* ctx.check(v, Never, value, index);\n    }\n  });\n}\n/**\n * Validate that a value matches a specific strutural interface, like the\n * structural typing that TypeScript uses.\n */\n\nfunction type(Structs) {\n  const keys = Object.keys(Structs);\n  return struct(`Type<{${keys.join(',')}}>`, function* (value, ctx) {\n    if (typeof value !== 'object' || value == null) {\n      yield ctx.fail();\n      return;\n    }\n\n    for (const key of keys) {\n      const Value = Structs[key];\n      const v = value[key];\n      yield* ctx.check(v, Value, value, key);\n    }\n  });\n}\nfunction union(Structs) {\n  return struct(`${Structs.map(s => s.type).join(' | ')}`, function* (value, ctx) {\n    for (const S of Structs) {\n      const [...failures] = ctx.check(value, S);\n\n      if (failures.length === 0) {\n        return;\n      }\n    }\n\n    yield ctx.fail();\n  });\n}\n/**\n * Convert a value to a literal string.\n */\n\nfunction toLiteralString(value) {\n  return typeof value === 'string' ? `\"${value.replace(/\"/g, '\"')}\"` : `${value}`;\n}\n/**\n * Coerce the values of an object-like struct.\n */\n\n\nfunction createObjectCoercer(Structs) {\n  const knowns = Object.keys(Structs);\n  return value => {\n    if (typeof value !== 'object' || value == null) {\n      return value;\n    }\n\n    const ret = {};\n    const unknowns = new Set(Object.keys(value));\n\n    for (const key of knowns) {\n      unknowns.delete(key);\n      const Value = Structs[key];\n      const v = value[key];\n      ret[key] = coerce(v, Value);\n    }\n\n    for (const key of unknowns) {\n      ret[key] = value[key];\n    }\n\n    return ret;\n  };\n}\n\nexport { Struct, StructError, any, array, assert, boolean, coerce, coercion, date, defaulted, dynamic, empty, enums, func, instance, intersection, is, lazy, length, literal, map, masked, never, nullable, number, object, optional, partial, pattern, record, refinement, set, string, struct, tuple, type, union, validate };\n//# sourceMappingURL=index.es.js.map\n","import { array, intersection, number, object, optional, pattern, record, refinement, string, type, union } from 'superstruct';\nexport const TYPE_REGEX = /^\\w+/;\nexport const ARRAY_REGEX = /^(.*)\\[([0-9]*?)]$/;\nexport const BYTES_REGEX = /^bytes([0-9]{1,2})$/;\nexport const NUMBER_REGEX = /^u?int([0-9]{0,3})$/;\nexport const STATIC_TYPES = ['address', 'bool', 'bytes', 'string'];\nconst TYPE = refinement(string(), 'Type', (type, context) => {\n  return isValidType(context.branch[0].types, type);\n});\nexport const CIP_23_TYPE = object({\n  name: string(),\n  type: TYPE\n});\nexport const CIP_23_DOMAIN_TYPE = object({\n  name: optional(string()),\n  version: optional(string()),\n  chainId: optional(union([string(), number()])),\n  verifyingContract: optional(pattern(string(), /^0x[0-9a-z]{40}$/i)),\n  salt: optional(union([array(number()), pattern(string(), /^0x[0-9a-z]{64}$/i)]))\n});\nexport const CIP_23_TYPED_DATA_TYPE = object({\n  types: intersection([type({\n    CIP23Domain: array(CIP_23_TYPE)\n  }), record(string(), array(CIP_23_TYPE))]),\n  primaryType: string(),\n  domain: CIP_23_DOMAIN_TYPE,\n  message: object()\n});\nexport const EIP_712_TYPED_DATA_TYPE = object({\n  types: intersection([type({\n    EIP712Domain: array(CIP_23_TYPE)\n  }), record(string(), array(CIP_23_TYPE))]),\n  primaryType: string(),\n  domain: CIP_23_DOMAIN_TYPE,\n  message: object()\n});\nexport const isValidType = (types, type) => {\n  if (STATIC_TYPES.includes(type)) {\n    return true;\n  }\n\n  if (types[type]) {\n    return true;\n  }\n\n  if (type.match(ARRAY_REGEX)) {\n    const match = type.match(TYPE_REGEX);\n\n    if (match) {\n      const innerType = match[0];\n      return isValidType(types, innerType);\n    }\n  }\n\n  const bytesMatch = type.match(BYTES_REGEX);\n\n  if (bytesMatch) {\n    const length = Number(bytesMatch[1]);\n\n    if (length >= 1 && length <= 32) {\n      return true;\n    }\n  }\n\n  const numberMatch = type.match(NUMBER_REGEX);\n\n  if (numberMatch) {\n    const length = Number(numberMatch[1]);\n\n    if (length >= 8 && length <= 256 && length % 8 === 0) {\n      return true;\n    }\n  }\n\n  return false;\n};\n//# sourceMappingURL=types.js.map","import createKeccakHash from 'keccak';\nexport const keccak256 = (data, encoding) => {\n  return createKeccakHash('keccak256').update(data, encoding).digest();\n};\nexport const toBuffer = (data, encoding) => {\n  if (!encoding) {\n    if (data.startsWith('0x')) {\n      return Buffer.from(data.substring(2), 'hex');\n    }\n\n    return Buffer.from(data, 'hex');\n  }\n\n  return Buffer.from(data, encoding);\n};\n//# sourceMappingURL=buffer.js.map","const BUFFER_WIDTH = 32;\nexport const concat = (target, value, position) => {\n  return new Uint8Array([...target.subarray(0, position !== null && position !== void 0 ? position : target.length), ...value, ...target.subarray(position !== null && position !== void 0 ? position : target.length)]);\n};\nexport const concatMultiple = buffers => {\n  return buffers.reduce((target, buffer) => {\n    const array = new Uint8Array(target.length + buffer.length);\n    array.set(target, 0);\n    array.set(buffer, target.length);\n    return array;\n  }, new Uint8Array(0));\n};\nexport const addPadding = (buffer, length = 32) => {\n  const padding = Buffer.alloc(Math.max(length - buffer.length, 0), 0);\n  return concat(buffer, padding);\n};\nexport const toBuffer = value => {\n  if (Buffer.isBuffer(value) || value instanceof Uint8Array) {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    const stringValue = value.startsWith('0x') ? value.substring(2) : value;\n    return Buffer.from(stringValue, 'hex');\n  }\n\n  const hex = value.toString(16);\n  return Buffer.from(hex.padStart(BUFFER_WIDTH * 2, '0').slice(0, BUFFER_WIDTH * 2), 'hex');\n};\nexport const toString = value => {\n  if (typeof window !== 'undefined' && window.TextDecoder) {\n    return new TextDecoder('utf-8').decode(value);\n  }\n\n  return new (require('util').TextDecoder)('utf-8').decode(value);\n};\nexport const toNumber = buffer => {\n  const hex = toHex(buffer);\n\n  if (hex.length === 0) {\n    return BigInt(0);\n  }\n\n  return BigInt(`0x${hex}`);\n};\n\nconst numberToHex = value => {\n  return ('0' + value.toString(16)).slice(-2);\n};\n\nexport const toHex = buffer => {\n  return Array.from(buffer).map(numberToHex).join('');\n};\n//# sourceMappingURL=buffer.js.map","import { addPadding, concat, toBuffer, toNumber } from '../utils/buffer';\nexport const encodeBytes = (buffer, value) => {\n  const bufferValue = toBuffer(value);\n  const paddedSize = Math.ceil(bufferValue.byteLength / 32) * 32;\n  return concat(buffer, Buffer.concat([toBuffer(bufferValue.byteLength), addPadding(bufferValue, paddedSize)]));\n};\nexport const decodeBytes = (value, buffer) => {\n  const pointer = Number(toNumber(value.subarray(0, 32)));\n  const length = toNumber(value.subarray(pointer, pointer + 32));\n  return buffer.subarray(32, 32 + Number(length));\n};\n//# sourceMappingURL=bytes.js.map","import { addPadding, concat, toBuffer } from '../utils/buffer';\nconst BYTES_REGEX = /^bytes([0-9]{1,2})$/;\nexport const isFixedBytes = type => {\n  return BYTES_REGEX.test(type);\n};\nexport const getByteLength = type => {\n  var _type$match;\n\n  const bytes = (_type$match = type.match(BYTES_REGEX)) === null || _type$match === void 0 ? void 0 : _type$match[1];\n\n  if (bytes) {\n    const length = Number(bytes);\n\n    if (length <= 0 || length > 32) {\n      throw new Error('Invalid type: length is out of range');\n    }\n\n    return length;\n  }\n\n  throw new Error('Invalid type: no length');\n};\nexport const encodeFixedBytes = (buffer, value, type) => {\n  const length = getByteLength(type);\n  const bufferValue = toBuffer(value);\n\n  if (bufferValue.length > length) {\n    throw new Error(`Buffer is too long, expected ${length}, got ${bufferValue.length}`);\n  }\n\n  return concat(buffer, addPadding(bufferValue));\n};\nexport const decodeFixedBytes = (value, _, type) => {\n  const length = getByteLength(type);\n  return value.subarray(0, length);\n};\n//# sourceMappingURL=fixed-bytes.js.map","import { concat, toBuffer, toNumber } from '../utils/buffer';\nimport { fromTwosComplement, toTwosComplement } from '../utils/twos-complement';\nconst NUMBER_REGEX = /^u?int([0-9]*)?$/;\n\nconst isSigned = type => {\n  return type.startsWith('i');\n};\n\nexport const isNumber = type => {\n  return NUMBER_REGEX.test(type);\n};\nexport const getBitLength = type => {\n  var _type$match$, _type$match;\n\n  const rawBits = (_type$match$ = (_type$match = type.match(NUMBER_REGEX)) === null || _type$match === void 0 ? void 0 : _type$match[1]) !== null && _type$match$ !== void 0 ? _type$match$ : '256';\n  return Number(rawBits);\n};\nexport const inRange = (value, type) => {\n  const bits = BigInt(getBitLength(type));\n\n  if (isSigned(type)) {\n    const maxSignedValue = 2n ** (bits - 1n) - 1n;\n    return value >= -maxSignedValue - 1n && value <= maxSignedValue;\n  }\n\n  const maxValue = 2n ** bits - 1n;\n  return value >= 0n && value <= maxValue;\n};\n\nconst asNumber = value => {\n  if (typeof value === 'bigint') {\n    return value;\n  }\n\n  return BigInt(value);\n};\n\nexport const encodeNumber = (buffer, value, type) => {\n  const numberValue = asNumber(value);\n\n  if (!inRange(numberValue, type)) {\n    throw new Error(`Cannot encode number: value is out of range for type ${type}`);\n  }\n\n  if (isSigned(type)) {\n    return concat(buffer, toTwosComplement(numberValue, 32));\n  }\n\n  return concat(buffer, toBuffer(numberValue));\n};\nexport const decodeNumber = (value, _, type) => {\n  if (isSigned(type)) {\n    return fromTwosComplement(value);\n  }\n\n  return toNumber(value);\n};\n//# sourceMappingURL=number.js.map","import { concat, concatMultiple, toBuffer, toNumber } from '../utils/buffer';\nimport { decodeAddress, encodeAddress } from './address';\nimport { decodeBytes, encodeBytes } from './bytes';\nimport { decodeFixedBytes, encodeFixedBytes, isFixedBytes } from './fixed-bytes';\nimport { decodeNumber, encodeNumber, isNumber } from './number';\nimport { decodeString, encodeString } from './string';\nconst ARRAY_REGEX = /^(.*)\\[]$/;\nexport const isArray = type => {\n  return ARRAY_REGEX.test(type);\n};\nexport const getType = type => {\n  return type.match(ARRAY_REGEX)[1];\n};\nexport const encodeArray = (buffer, values, type) => {\n  if (!isArray(type)) {\n    throw new Error('Invalid type: type is not array');\n  }\n\n  const actualType = getType(type);\n  const length = toBuffer(values.length);\n  const arrayBuffer = concat(buffer, length);\n  return pack(arrayBuffer, values, new Array(values.length).fill(actualType));\n};\nexport const decodeArray = (value, buffer, type) => {\n  if (!isArray(type)) {\n    throw new Error('Invalid type: type is not array');\n  }\n\n  const actualType = getType(type);\n  const pointer = Number(toNumber(value));\n  const length = Number(toNumber(buffer.subarray(pointer, pointer + 32)));\n  const arrayPointer = pointer + 32;\n  const arrayBuffer = buffer.subarray(arrayPointer);\n  return unpack(arrayBuffer, new Array(length).fill(actualType));\n};\nconst parsers = {\n  address: {\n    encode: encodeAddress,\n    decode: decodeAddress\n  },\n  array: {\n    dynamic: true,\n    encode: encodeArray,\n    decode: decodeArray\n  },\n  bytes: {\n    dynamic: true,\n    encode: encodeBytes,\n    decode: decodeBytes\n  },\n  fixedBytes: {\n    encode: encodeFixedBytes,\n    decode: decodeFixedBytes\n  },\n  number: {\n    encode: encodeNumber,\n    decode: decodeNumber\n  },\n  string: {\n    dynamic: true,\n    encode: encodeString,\n    decode: decodeString\n  }\n};\nexport const getParser = type => {\n  if (parsers[type]) {\n    return parsers[type];\n  }\n\n  if (isFixedBytes(type)) {\n    return parsers.fixedBytes;\n  }\n\n  if (isNumber(type) || type === 'bool') {\n    return parsers.number;\n  }\n\n  if (isArray(type)) {\n    return parsers.array;\n  }\n\n  throw new Error(`type \"${type}\" is not supported`);\n};\nexport const pack = (buffer, values, types) => {\n  const {\n    staticBuffer: packedStaticBuffer,\n    dynamicBuffer: packedDynamicBuffer,\n    updateFunctions: packedUpdateFunctions\n  } = types.reduce(({\n    staticBuffer,\n    dynamicBuffer,\n    updateFunctions\n  }, type, index) => {\n    const parser = getParser(type);\n    const value = values[index];\n\n    if (parser.dynamic) {\n      const offset = dynamicBuffer.length;\n      const staticOffset = staticBuffer.length;\n      const newStaticBuffer = concat(staticBuffer, Buffer.alloc(32, 0));\n      const newDynamicBuffer = parser.encode(dynamicBuffer, value, type);\n\n      const update = oldBuffer => {\n        return concatMultiple([oldBuffer.subarray(0, staticOffset), toBuffer(oldBuffer.length + offset), oldBuffer.subarray(staticOffset + 32)]);\n      };\n\n      return {\n        staticBuffer: newStaticBuffer,\n        dynamicBuffer: newDynamicBuffer,\n        updateFunctions: [...updateFunctions, update]\n      };\n    }\n\n    const newBuffer = parser.encode(staticBuffer, value, type);\n    return {\n      staticBuffer: newBuffer,\n      dynamicBuffer,\n      updateFunctions\n    };\n  }, {\n    staticBuffer: new Uint8Array(0),\n    dynamicBuffer: new Uint8Array(0),\n    updateFunctions: []\n  });\n  const updatedStaticBuffer = packedUpdateFunctions.reduce((target, update) => update(target), packedStaticBuffer);\n  return concatMultiple([buffer, updatedStaticBuffer, packedDynamicBuffer]);\n};\nexport function* iterate(buffer, chunkSize) {\n  for (let i = 0; i < buffer.length; i += chunkSize) {\n    yield buffer.slice(i, i + chunkSize);\n  }\n\n  return buffer;\n}\nexport const unpack = (buffer, types) => {\n  const iterator = iterate(buffer, 32);\n  return types.map(type => {\n    const {\n      value,\n      done\n    } = iterator.next();\n\n    if (done) {\n      throw new Error('input data has an invalid length');\n    }\n\n    const parser = getParser(type);\n    return parser.decode(value, buffer, type);\n  });\n};\n//# sourceMappingURL=array.js.map","import { concat, toHex } from '../utils/buffer';\nexport const encodeAddress = (buffer, value) => {\n  if (value.length !== 42) {\n    throw new Error('Invalid address length');\n  }\n\n  const addressBuffer = Buffer.alloc(32);\n  addressBuffer.write(value.substring(2), 12, 'hex');\n  return concat(buffer, addressBuffer);\n};\nexport const decodeAddress = value => {\n  const addressBuffer = value.subarray(-20);\n  return `0x${toHex(addressBuffer)}`;\n};\n//# sourceMappingURL=address.js.map","import { toBuffer } from './buffer';\nexport const fromTwosComplement = buffer => {\n  const bufferValue = toBuffer(buffer);\n  let value = 0n;\n\n  for (const byte of bufferValue) {\n    value = (value << 8n) + BigInt(byte);\n  }\n\n  return BigInt.asIntN(bufferValue.length * 8, value);\n};\nexport const toTwosComplement = (value, length) => {\n  const buffer = new Uint8Array(length);\n\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] = Number(BigInt.asUintN(8, value));\n    value = value >> 8n;\n  }\n\n  return buffer.reverse();\n};\n//# sourceMappingURL=twos-complement.js.map","import { toString } from '../utils/buffer';\nimport { decodeBytes, encodeBytes } from './bytes';\nexport const encodeString = (buffer, value) => {\n  const bufferValue = Buffer.from(value, 'utf8');\n  return encodeBytes(buffer, bufferValue, 'bytes');\n};\nexport const decodeString = (value, buffer) => {\n  return toString(decodeBytes(value, buffer, 'string'));\n};\n//# sourceMappingURL=string.js.map","import { getIdentifier } from './identifier';\nimport { pack, unpack } from './parsers/array';\nimport { concat } from './utils/buffer';\nexport const encode = (input, values) => {\n  const types = input.map(type => {\n    if (typeof type === 'string') {\n      return type;\n    }\n\n    return type.type;\n  });\n  return pack(Buffer.alloc(0), values, types);\n};\nexport const encodeWithIdentifier = (contractFunction, values) => {\n  const identifier = Buffer.from(getIdentifier(contractFunction), 'hex');\n  const encoded = encode(contractFunction.inputs, values);\n  return concat(identifier, encoded);\n};\nexport const decode = (input, buffer) => {\n  const types = input.map(type => {\n    if (typeof type === 'string') {\n      return type;\n    }\n\n    return type.type;\n  });\n  return unpack(buffer, types);\n};\n//# sourceMappingURL=abi.js.map","import cfxAddress from '@conflux-dev/conflux-address-js';\nimport { encode as encodeAbi } from '@findeth/abi';\nconst ADDRESS = 'address';\nexport const encode = (types, values) => {\n  values.map(function (v, i, origin) {\n    if (types[i] === ADDRESS) {\n      origin[i] = normalizeAddress(v);\n    }\n  });\n  return Buffer.from(encodeAbi(types, values));\n};\n\nfunction normalizeAddress(address) {\n  if (!cfxAddress.hasNetworkPrefix(address)) {\n    return address;\n  }\n\n  return '0x' + cfxAddress.decode(address).hexAddress.toString('hex');\n}\n//# sourceMappingURL=abi.js.map","import { ARRAY_REGEX, TYPE_REGEX } from './types';\nimport { keccak256, toBuffer, validateTypedData, encode } from './utils';\nconst EIP_191_PREFIX = Buffer.from('1901', 'hex');\nexport const getDependencies = (typedData, type, dependencies = []) => {\n  if (!validateTypedData(typedData)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n\n  const match = type.match(TYPE_REGEX);\n  const actualType = match[0];\n\n  if (dependencies.includes(actualType)) {\n    return dependencies;\n  }\n\n  if (!typedData.types[actualType]) {\n    return dependencies;\n  }\n\n  return [actualType, ...typedData.types[actualType].reduce((previous, type) => {\n    const newDependencies = actualType === type.type ? [] : getDependencies(typedData, type.type, previous).filter(dependency => !previous.includes(dependency));\n    return [...previous, ...newDependencies];\n  }, [])];\n};\nexport const encodeType = (typedData, type) => {\n  const [primary, ...dependencies] = getDependencies(typedData, type);\n  const types = [primary, ...dependencies.sort()];\n  return types.map(dependency => {\n    return `${dependency}(${typedData.types[dependency].map(type => `${type.type} ${type.name}`)})`;\n  }).join('');\n};\nexport const getTypeHash = (typedData, type) => {\n  return keccak256(encodeType(typedData, type), 'utf8');\n};\n\nconst encodeValue = (typedData, type, data) => {\n  const match = type.match(ARRAY_REGEX);\n\n  if (match) {\n    const arrayType = match[1];\n    const length = Number(match[2]) || undefined;\n\n    if (!Array.isArray(data)) {\n      throw new Error('Cannot encode data: value is not of array type');\n    }\n\n    if (length && data.length !== length) {\n      throw new Error(`Cannot encode data: expected length of ${length}, but got ${data.length}`);\n    }\n\n    const encodedData = data.map(item => encodeValue(typedData, arrayType, item));\n    const types = encodedData.map(item => item[0]);\n    const values = encodedData.map(item => item[1]);\n    return ['bytes32', keccak256(encode(types, values))];\n  }\n\n  if (typedData.types[type]) {\n    return ['bytes32', getStructHash(typedData, type, data)];\n  }\n\n  if (type === 'string') {\n    return ['bytes32', keccak256(data, 'utf8')];\n  }\n\n  if (type === 'bytes') {\n    return ['bytes32', keccak256(Buffer.isBuffer(data) ? data : toBuffer(data), 'hex')];\n  }\n\n  return [type, data];\n};\n\nexport const encodeData = (typedData, type, data) => {\n  const [types, values] = typedData.types[type].reduce(([types, values], field) => {\n    if (data[field.name] === undefined || data[field.name] === null) {\n      return [[...types, 'bytes32'], [...values, '0x0000000000000000000000000000000000000000000000000000000000000000']];\n    }\n\n    const value = data[field.name];\n    const [type, encodedValue] = encodeValue(typedData, field.type, value);\n    return [[...types, type], [...values, encodedValue]];\n  }, [['bytes32'], [getTypeHash(typedData, type)]]);\n  return encode(types, values);\n};\nexport const getStructHash = (typedData, type, data) => {\n  return keccak256(encodeData(typedData, type, data));\n};\nexport const getMessage = (typedData, hash, domainName = 'CIP23Domain') => {\n  const message = Buffer.concat([EIP_191_PREFIX, getStructHash(typedData, domainName, typedData.domain), getStructHash(typedData, typedData.primaryType, typedData.message)]);\n\n  if (hash) {\n    return keccak256(message);\n  }\n\n  return message;\n};\nexport const asArray = (typedData, type = typedData.primaryType, data = typedData.message) => {\n  if (!validateTypedData(typedData)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n\n  if (!typedData.types[type]) {\n    throw new Error('Cannot get data as array: type does not exist');\n  }\n\n  return typedData.types[type].reduce((array, {\n    name,\n    type\n  }) => {\n    if (typedData.types[type]) {\n      if (!data[name]) {\n        throw new Error(`Cannot get data as array: missing data for '${name}'`);\n      }\n\n      return [...array, asArray(typedData, type, data[name])];\n    }\n\n    const value = data[name];\n    return [...array, value];\n  }, []);\n};\n//# sourceMappingURL=cip-23.js.map","import { is } from 'superstruct';\nimport { CIP_23_TYPED_DATA_TYPE, EIP_712_TYPED_DATA_TYPE } from '../types';\nexport const validateTypedData = data => {\n  return is(data, CIP_23_TYPED_DATA_TYPE) || is(data, EIP_712_TYPED_DATA_TYPE);\n};\n//# sourceMappingURL=json.js.map","import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";import _createClass from\"@babel/runtime/helpers/createClass\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));}catch(t){}return(_isNativeReflectConstruct=function(){return!!t;})();}import{keccak256}from'@ethersproject/keccak256';import{getMessage}from'cip-23';import{decrypt,secp256k1,uncompressPublicKey}from'@onekeyhq/core/src/secret';import{checkIsDefined}from'@onekeyhq/shared/src/utils/assertUtils';import bufferUtils from'@onekeyhq/shared/src/utils/bufferUtils';import{EMessageTypesEth}from'@onekeyhq/shared/types/message';import{CoreChainApiBase}from\"../../base/CoreChainApiBase\";import{ECoreApiExportedSecretKeyType}from\"../../types\";import{pubkeyToCfxAddress,signTransactionWithSigner}from\"./sdkCfx\";import{conflux}from\"./sdkCfx/conflux\";var curve='secp256k1';var{Message,PersonalMessage}=conflux;function hashCfxMessage(typedMessage){var{type,message}=typedMessage;switch(type){case undefined:case EMessageTypesEth.ETH_SIGN:return new Message(message).hash;case EMessageTypesEth.PERSONAL_SIGN:return new PersonalMessage(message).hash;case EMessageTypesEth.TYPED_DATA_V3:case EMessageTypesEth.TYPED_DATA_V4:return keccak256(getMessage(JSON.parse(message)));default:throw new Error(`Invalid messageType: ${type}`);}}var CoreChainSoftware=function(_CoreChainApiBase){_inherits(CoreChainSoftware,_CoreChainApiBase);var _super=_createSuper(CoreChainSoftware);function CoreChainSoftware(){return _super.apply(this,arguments);}var _proto=CoreChainSoftware.prototype;_proto.getExportedSecretKey=function(){var _getExportedSecretKey=_asyncToGenerator(function*(query){var{password,keyType,credentials}=query;var{privateKeyRaw}=yield this.baseGetDefaultPrivateKey(query);if(!privateKeyRaw){throw new Error('privateKeyRaw is required');}if(keyType===ECoreApiExportedSecretKeyType.privateKey){return`0x${decrypt(password,privateKeyRaw).toString('hex')}`;}throw new Error(`SecretKey type not support: ${keyType}`);});function getExportedSecretKey(_x){return _getExportedSecretKey.apply(this,arguments);}return getExportedSecretKey;}();_proto.getPrivateKeys=function(){var _getPrivateKeys=_asyncToGenerator(function*(payload){return this.baseGetPrivateKeys({payload,curve});});function getPrivateKeys(_x2){return _getPrivateKeys.apply(this,arguments);}return getPrivateKeys;}();_proto.signTransaction=function(){var _signTransaction=_asyncToGenerator(function*(payload){var{unsignedTx}=payload;var signer=yield this.baseGetSingleSigner({payload,curve});return signTransactionWithSigner(unsignedTx,signer);});function signTransaction(_x3){return _signTransaction.apply(this,arguments);}return signTransaction;}();_proto.signMessage=function(){var _signMessage=_asyncToGenerator(function*(payload){var unsignedMsg=payload.unsignedMsg;var signer=yield this.baseGetSingleSigner({payload,curve});return Message.sign(`0x${(yield signer.getPrvkey()).toString('hex')}`,hashCfxMessage(unsignedMsg));});function signMessage(_x4){return _signMessage.apply(this,arguments);}return signMessage;}();_proto.getAddressFromPrivate=function(){var _getAddressFromPrivate=_asyncToGenerator(function*(query){var{privateKeyRaw}=query;var privateKey=bufferUtils.toBuffer(privateKeyRaw);var pub=secp256k1.publicFromPrivate(privateKey);return this.getAddressFromPublic({publicKey:bufferUtils.bytesToHex(pub),networkInfo:query.networkInfo});});function getAddressFromPrivate(_x5){return _getAddressFromPrivate.apply(this,arguments);}return getAddressFromPrivate;}();_proto.getAddressFromPublic=function(){var _getAddressFromPublic=_asyncToGenerator(function*(query){var{publicKey}=query;var compressedPublicKey=bufferUtils.toBuffer(publicKey);var uncompressedPublicKey=uncompressPublicKey(curve,compressedPublicKey);var{chainId,networkId}=checkIsDefined(query.networkInfo);var cfxAddress=yield pubkeyToCfxAddress(uncompressedPublicKey,checkIsDefined(chainId));return Promise.resolve({address:'',addresses:{[checkIsDefined(networkId)]:cfxAddress},publicKey});});function getAddressFromPublic(_x6){return _getAddressFromPublic.apply(this,arguments);}return getAddressFromPublic;}();_proto.getAddressesFromHd=function(){var _getAddressesFromHd=_asyncToGenerator(function*(query){return this.baseGetAddressesFromHd(query,{curve});});function getAddressesFromHd(_x7){return _getAddressesFromHd.apply(this,arguments);}return getAddressesFromHd;}();return _createClass(CoreChainSoftware);}(CoreChainApiBase);export{CoreChainSoftware as default};","import coinselectUtils from'@onekeyfe/coinselect/utils';import accountUtils from'@onekeyhq/shared/src/utils/accountUtils';export function slicePathTemplate(template){return accountUtils.slicePathTemplate(template);}export function getUtxoAccountPrefixPath({fullPath}){var pathComponent=fullPath.split('/');pathComponent.pop();pathComponent.pop();var prefixPath=pathComponent.join('/');return prefixPath;}export function getBIP44Path(account,address){var realPath='';for(var[key,value]of Object.entries(account.addresses)){if(value===address){realPath=key;break;}}return`${account.path}/${realPath}`;}export function estimateTxSize(inputsForCoinSelect,outputsForCoinSelect){return coinselectUtils.transactionBytes(inputsForCoinSelect,outputsForCoinSelect);}"],"names":["TX_EMPTY_SIZE","TX_INPUT_BASE","TX_INPUT_PUBKEYHASH","TX_OUTPUT_BASE","TX_OUTPUT_PUBKEYHASH","OP_RETURN_OVERHEAD","inputBytes","input","script","length","outputBytes","output","dustThreshold","feeRate","transactionBytes","inputs","outputs","reduce","a","x","uintOrNaN","v","NaN","isFinite","Math","floor","sumOrNaN","range","value","BLANK_OUTPUT","module","exports","finalize","bytesAccum","feeAfterExtraOutput","remainderAfterExtraOutput","concat","fee","sumForgiving","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","result","Super","NewTarget","this","constructor","Reflect","construct","arguments","apply","t","Boolean","prototype","valueOf","call","ChainSigner","_Verifier","_super","encryptedPrivateKey","password","curve","_this","pub","N","key","chainCode","Buffer","alloc","toString","_getPrvkeyHex","_proto2","getPrvkey","Promise","resolve","getPrvkeyHex","bufferUtils","bytesToHex","sign","digest","signature","slice","Verifier","compressedPublicKey","from","uncompressedPublicKey","_getPubkeyHex","_proto","getPubkey","compressed","getPubkeyHex","_x","verify","verifySignature","publicKey","p","toBuffer","d","s","ownKeys","e","r","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","_objectSpread","forEach","getOwnPropertyDescriptors","defineProperties","defineProperty","CoreChainApiBase","_baseCreateSigner","_baseGetSingleSigner","_baseGetPrivateKeys","_baseGetPrivateKeysHd","_baseGetAddressesFromHd","_baseGetDefaultPrivateKey","_validateXpub","_validateXprvt","baseGetCurve","curveName","baseCreateSigner","privateKey","privateKeyBuffer","baseGetSingleSigner","payload","privateKeys","getPrivateKeys","accountPath","account","path","firstRelPath","relPaths","join","Error","_x2","baseGetPrivateKeys","credentials","hd","imported","baseGetPrivateKeysHd","hdCredential","credential","encryptPrivateKey","_x3","pathComponents","split","usedRelativePaths","pop","basePath","ret","extendedKey","_x4","baseGetAddressesFromHd","query","options","generateFrom","template","indexes","pathPrefix","pathSuffix","indexFormatted","map","index","replace","isPrivateKeyMode","pubkeyInfos","pvtkeyInfos","prefix","infos","_ref","addresses","all","info","privateKeyRaw","getAddressFromPrivate","networkInfo","privateKeyInfo","getAddressFromPublic","publicKeyInfo","_x7","_x5","_x6","baseGetCredentialsType","ECoreCredentialType","baseGetDefaultPrivateKey","params","privateKeysMap","values","_x8","validateXpub","_x9","validateXprvt","_x10","CoreChainImported","_CoreChainSoftware","_defineProperty","obj","configurable","writable","object","enumerableOnly","symbols","sym","_objectSpread2","target","i","source","_objectWithoutProperties","excluded","_objectWithoutPropertiesLoose","sourceKeys","indexOf","sourceSymbolKeys","propertyIsEnumerable","toFailures","context","fail","iteratorShift","done","next","undefined","Struct","props","type","schema","coercer","validator","refiner","StructError","TypeError","failure","moreFailures","branch","rest","failuresResult","super","JSON","stringify","assign","failures","stack","__proto__","coerce","struct","assert","validate","is","coercing","check","ctx","parent","pattern","S","regexp","refinement","test","fn","array","Element","Array","isArray","entries","intersection","Structs","never","number","isNaN","knowns","Never","createObjectCoercer","unknowns","Set","delete","Value","optional","record","Key","k","string","name","union","TYPE_REGEX","ARRAY_REGEX","BYTES_REGEX","NUMBER_REGEX","STATIC_TYPES","TYPE","isValidType","types","CIP_23_TYPE","CIP_23_DOMAIN_TYPE","version","chainId","verifyingContract","salt","CIP_23_TYPED_DATA_TYPE","CIP23Domain","primaryType","domain","message","EIP_712_TYPED_DATA_TYPE","EIP712Domain","includes","match","innerType","bytesMatch","Number","numberMatch","keccak256","data","encoding","update","startsWith","substring","position","Uint8Array","subarray","concatMultiple","buffers","buffer","set","addPadding","padding","max","isBuffer","stringValue","hex","padStart","BUFFER_WIDTH","toNumber","toHex","BigInt","numberToHex","encodeBytes","bufferValue","paddedSize","ceil","byteLength","decodeBytes","pointer","getByteLength","_type$match","bytes","isSigned","inRange","bits","_type$match$","rawBits","getBitLength","maxSignedValue","getType","parsers","address","encode","addressBuffer","write","decode","dynamic","actualType","arrayBuffer","pack","fill","arrayPointer","fixedBytes","_","numberValue","asNumber","asUintN","reverse","toTwosComplement","byte","asIntN","fromTwosComplement","window","TextDecoder","getParser","isFixedBytes","isNumber","staticBuffer","packedStaticBuffer","dynamicBuffer","packedDynamicBuffer","updateFunctions","packedUpdateFunctions","parser","offset","staticOffset","oldBuffer","updatedStaticBuffer","iterator","iterate","chunkSize","origin","normalizeAddress","hexAddress","EIP_191_PREFIX","getDependencies","typedData","dependencies","previous","newDependencies","dependency","getTypeHash","primary","sort","encodeType","encodeValue","arrayType","encodedData","item","getStructHash","field","encodedValue","encodeData","Message","PersonalMessage","conflux","hashCfxMessage","typedMessage","ETH_SIGN","hash","PERSONAL_SIGN","TYPED_DATA_V3","TYPED_DATA_V4","domainName","getMessage","parse","CoreChainSoftware","_CoreChainApiBase","_getExportedSecretKey","_getPrivateKeys","_signTransaction","_signMessage","_getAddressFromPrivate","_getAddressFromPublic","_getAddressesFromHd","getExportedSecretKey","keyType","ECoreApiExportedSecretKeyType","signTransaction","unsignedTx","signer","signMessage","unsignedMsg","publicFromPrivate","networkId","cfxAddress","getAddressesFromHd","slicePathTemplate","getUtxoAccountPrefixPath","fullPath","pathComponent","getBIP44Path","realPath","estimateTxSize","inputsForCoinSelect","outputsForCoinSelect"],"sourceRoot":""}
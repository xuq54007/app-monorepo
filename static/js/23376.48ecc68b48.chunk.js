/*! For license information please see 23376.48ecc68b48.chunk.js.LICENSE.txt */
!function(){try{var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},t=(new e.Error).stack;t&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[t]="740b49c5-f9d6-4c82-9ffe-b09a50ed6868",e._sentryDebugIdIdentifier="sentry-dbid-740b49c5-f9d6-4c82-9ffe-b09a50ed6868")}catch(e){}}();var _global="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};_global.SENTRY_RELEASE={id:"5.5.0 (2024121652)"},(self.webpackChunkweb=self.webpackChunkweb||[]).push([[23376],{451661:e=>{var t=10,r=41,n=107,o=9,i=25,s=10;function inputBytes(e){return r+(e.script?e.script.length:n)}function outputBytes(e){return e.script?s+e.script.length+(e.script.length>=74?2:1):o+(e.script?e.script.length:i)}function dustThreshold(e,t){return inputBytes({})*t}function transactionBytes(e,r){return t+e.reduce((function(e,t){return e+inputBytes(t)}),0)+r.reduce((function(e,t){return e+outputBytes(t)}),0)}function uintOrNaN(e){return"number"!=typeof e?NaN:isFinite(e)?Math.floor(e)!==e||e<0?NaN:e:NaN}function sumOrNaN(e){return e.reduce((function(e,t){return e+uintOrNaN(t.value)}),0)}var a=outputBytes({});e.exports={dustThreshold,finalize:function finalize(e,t,r){var n=transactionBytes(e,t),o=r*(n+a),i=sumOrNaN(e)-(sumOrNaN(t)+o);i>dustThreshold(0,r)&&(t=t.concat({value:i}));var s=sumOrNaN(e)-sumOrNaN(t);return isFinite(s)?{inputs:e,outputs:t,fee:s}:{fee:r*n}},inputBytes,outputBytes,sumOrNaN,sumForgiving:function sumForgiving(e){return e.reduce((function(e,t){return e+(isFinite(t.value)?t.value:0)}),0)},transactionBytes,uintOrNaN}},878918:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.s16=t.s8=t.nu64be=t.u48be=t.u40be=t.u32be=t.u24be=t.u16be=t.nu64=t.u48=t.u40=t.u32=t.u24=t.u16=t.u8=t.offset=t.greedy=t.Constant=t.UTF8=t.CString=t.Blob=t.Boolean=t.BitField=t.BitStructure=t.VariantLayout=t.Union=t.UnionLayoutDiscriminator=t.UnionDiscriminator=t.Structure=t.Sequence=t.DoubleBE=t.Double=t.FloatBE=t.Float=t.NearInt64BE=t.NearInt64=t.NearUInt64BE=t.NearUInt64=t.IntBE=t.Int=t.UIntBE=t.UInt=t.OffsetLayout=t.GreedyCount=t.ExternalLayout=t.bindConstructorLayout=t.nameWithProperty=t.Layout=t.uint8ArrayToBuffer=t.checkUint8Array=void 0,t.constant=t.utf8=t.cstr=t.blob=t.unionLayoutDiscriminator=t.union=t.seq=t.bits=t.struct=t.f64be=t.f64=t.f32be=t.f32=t.ns64be=t.s48be=t.s40be=t.s32be=t.s24be=t.s16be=t.ns64=t.s48=t.s40=t.s32=t.s24=void 0;const n=r(901048);function checkUint8Array(e){if(!(e instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}function uint8ArrayToBuffer(e){return checkUint8Array(e),n.Buffer.from(e.buffer,e.byteOffset,e.length)}t.checkUint8Array=checkUint8Array,t.uint8ArrayToBuffer=uint8ArrayToBuffer;class Layout{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}function nameWithProperty(e,t){return t.property?e+"["+t.property+"]":e}t.Layout=Layout,t.nameWithProperty=nameWithProperty,t.bindConstructorLayout=function bindConstructorLayout(e,t){if("function"!=typeof e)throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(e,"layout_"))throw new Error("Class is already bound to a layout");if(!(t&&t instanceof Layout))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(t,"boundConstructor_"))throw new Error("layout is already bound to a constructor");e.layout_=t,t.boundConstructor_=e,t.makeDestinationObject=()=>new e,Object.defineProperty(e.prototype,"encode",{value(e,r){return t.encode(this,e,r)},writable:!0}),Object.defineProperty(e,"decode",{value:(e,r)=>t.decode(e,r),writable:!0})};class ExternalLayout extends Layout{isCount(){throw new Error("ExternalLayout is abstract")}}t.ExternalLayout=ExternalLayout;class GreedyCount extends ExternalLayout{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){checkUint8Array(e);const r=e.length-t;return Math.floor(r/this.elementSpan)}encode(e,t,r){return 0}}t.GreedyCount=GreedyCount;class OffsetLayout extends ExternalLayout{constructor(e,t=0,r){if(!(e instanceof Layout))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,r||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof UInt||this.layout instanceof UIntBE}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,r=0){return this.layout.encode(e,t,r+this.offset)}}t.OffsetLayout=OffsetLayout;class UInt extends Layout{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return uint8ArrayToBuffer(e).readUIntLE(t,this.span)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeUIntLE(e,r,this.span),this.span}}t.UInt=UInt;class UIntBE extends Layout{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return uint8ArrayToBuffer(e).readUIntBE(t,this.span)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeUIntBE(e,r,this.span),this.span}}t.UIntBE=UIntBE;class Int extends Layout{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return uint8ArrayToBuffer(e).readIntLE(t,this.span)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeIntLE(e,r,this.span),this.span}}t.Int=Int;class IntBE extends Layout{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return uint8ArrayToBuffer(e).readIntBE(t,this.span)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeIntBE(e,r,this.span),this.span}}t.IntBE=IntBE;const o=Math.pow(2,32);function divmodInt64(e){const t=Math.floor(e/o);return{hi32:t,lo32:e-t*o}}function roundedInt64(e,t){return e*o+t}class NearUInt64 extends Layout{constructor(e){super(8,e)}decode(e,t=0){const r=uint8ArrayToBuffer(e),n=r.readUInt32LE(t);return roundedInt64(r.readUInt32LE(t+4),n)}encode(e,t,r=0){const n=divmodInt64(e),o=uint8ArrayToBuffer(t);return o.writeUInt32LE(n.lo32,r),o.writeUInt32LE(n.hi32,r+4),8}}t.NearUInt64=NearUInt64;class NearUInt64BE extends Layout{constructor(e){super(8,e)}decode(e,t=0){const r=uint8ArrayToBuffer(e);return roundedInt64(r.readUInt32BE(t),r.readUInt32BE(t+4))}encode(e,t,r=0){const n=divmodInt64(e),o=uint8ArrayToBuffer(t);return o.writeUInt32BE(n.hi32,r),o.writeUInt32BE(n.lo32,r+4),8}}t.NearUInt64BE=NearUInt64BE;class NearInt64 extends Layout{constructor(e){super(8,e)}decode(e,t=0){const r=uint8ArrayToBuffer(e),n=r.readUInt32LE(t);return roundedInt64(r.readInt32LE(t+4),n)}encode(e,t,r=0){const n=divmodInt64(e),o=uint8ArrayToBuffer(t);return o.writeUInt32LE(n.lo32,r),o.writeInt32LE(n.hi32,r+4),8}}t.NearInt64=NearInt64;class NearInt64BE extends Layout{constructor(e){super(8,e)}decode(e,t=0){const r=uint8ArrayToBuffer(e);return roundedInt64(r.readInt32BE(t),r.readUInt32BE(t+4))}encode(e,t,r=0){const n=divmodInt64(e),o=uint8ArrayToBuffer(t);return o.writeInt32BE(n.hi32,r),o.writeUInt32BE(n.lo32,r+4),8}}t.NearInt64BE=NearInt64BE;class Float extends Layout{constructor(e){super(4,e)}decode(e,t=0){return uint8ArrayToBuffer(e).readFloatLE(t)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeFloatLE(e,r),4}}t.Float=Float;class FloatBE extends Layout{constructor(e){super(4,e)}decode(e,t=0){return uint8ArrayToBuffer(e).readFloatBE(t)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeFloatBE(e,r),4}}t.FloatBE=FloatBE;class Double extends Layout{constructor(e){super(8,e)}decode(e,t=0){return uint8ArrayToBuffer(e).readDoubleLE(t)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeDoubleLE(e,r),8}}t.Double=Double;class DoubleBE extends Layout{constructor(e){super(8,e)}decode(e,t=0){return uint8ArrayToBuffer(e).readDoubleBE(t)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeDoubleBE(e,r),8}}t.DoubleBE=DoubleBE;class Sequence extends Layout{constructor(e,t,r){if(!(e instanceof Layout))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof ExternalLayout&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let n=-1;!(t instanceof ExternalLayout)&&0<e.span&&(n=t*e.span),super(n,r),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0,n=this.count;if(n instanceof ExternalLayout&&(n=n.decode(e,t)),0<this.elementLayout.span)r=n*this.elementLayout.span;else{let o=0;for(;o<n;)r+=this.elementLayout.getSpan(e,t+r),++o}return r}decode(e,t=0){const r=[];let n=0,o=this.count;for(o instanceof ExternalLayout&&(o=o.decode(e,t));n<o;)r.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),n+=1;return r}encode(e,t,r=0){const n=this.elementLayout,o=e.reduce(((e,o)=>e+n.encode(o,t,r+e)),0);return this.count instanceof ExternalLayout&&this.count.encode(e.length,t,r),o}}t.Sequence=Sequence;class Structure extends Layout{constructor(e,t,r){if(!Array.isArray(e)||!e.reduce(((e,t)=>e&&t instanceof Layout),!0))throw new TypeError("fields must be array of Layout instances");"boolean"==typeof t&&void 0===r&&(r=t,t=void 0);for(const t of e)if(0>t.span&&void 0===t.property)throw new Error("fields cannot contain unnamed variable-length layout");let n=-1;try{n=e.reduce(((e,t)=>e+t.getSpan()),0)}catch(e){}super(n,t),this.fields=e,this.decodePrefixes=!!r}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0;try{r=this.fields.reduce(((r,n)=>{const o=n.getSpan(e,t);return t+=o,r+o}),0)}catch(e){throw new RangeError("indeterminate span")}return r}decode(e,t=0){checkUint8Array(e);const r=this.makeDestinationObject();for(const n of this.fields)if(void 0!==n.property&&(r[n.property]=n.decode(e,t)),t+=n.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return r}encode(e,t,r=0){const n=r;let o=0,i=0;for(const n of this.fields){let s=n.span;if(i=0<s?s:0,void 0!==n.property){const o=e[n.property];void 0!==o&&(i=n.encode(o,t,r),0>s&&(s=n.getSpan(t,r)))}o=r,r+=s}return o+i-n}fromArray(e){const t=this.makeDestinationObject();for(const r of this.fields)void 0!==r.property&&0<e.length&&(t[r.property]=e.shift());return t}layoutFor(e){if("string"!=typeof e)throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if("string"!=typeof e)throw new TypeError("property must be string");let t=0;for(const r of this.fields){if(r.property===e)return t;0>r.span?t=-1:0<=t&&(t+=r.span)}}}t.Structure=Structure;class UnionDiscriminator{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,r){throw new Error("UnionDiscriminator is abstract")}}t.UnionDiscriminator=UnionDiscriminator;class UnionLayoutDiscriminator extends UnionDiscriminator{constructor(e,t){if(!(e instanceof ExternalLayout&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,r){return this.layout.encode(e,t,r)}}t.UnionLayoutDiscriminator=UnionLayoutDiscriminator;class Union extends Layout{constructor(e,t,r){let n;if(e instanceof UInt||e instanceof UIntBE)n=new UnionLayoutDiscriminator(new OffsetLayout(e));else if(e instanceof ExternalLayout&&e.isCount())n=new UnionLayoutDiscriminator(e);else{if(!(e instanceof UnionDiscriminator))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");n=e}if(void 0===t&&(t=null),!(null===t||t instanceof Layout))throw new TypeError("defaultLayout must be null or a Layout");if(null!==t){if(0>t.span)throw new Error("defaultLayout must have constant span");void 0===t.property&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof UInt||e instanceof UIntBE)&&(o+=n.layout.span)),super(o,r),this.discriminator=n,this.usesPrefixDiscriminator=e instanceof UInt||e instanceof UIntBE,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(e){return i(e)},this.configGetSourceVariant=function(e){i=e.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const r=this.getVariant(e,t);if(!r)throw new Error("unable to determine span for unrecognized variant");return r.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const r=this.registry[t];if(r.property&&Object.prototype.hasOwnProperty.call(e,r.property))return r}throw new Error("unable to infer src variant")}decode(e,t=0){let r;const n=this.discriminator,o=n.decode(e,t),i=this.registry[o];if(void 0===i){const i=this.defaultLayout;let s=0;this.usesPrefixDiscriminator&&(s=n.layout.span),r=this.makeDestinationObject(),r[n.property]=o,r[i.property]=i.decode(e,t+s)}else r=i.decode(e,t);return r}encode(e,t,r=0){const n=this.getSourceVariant(e);if(void 0===n){const n=this.discriminator,o=this.defaultLayout;let i=0;return this.usesPrefixDiscriminator&&(i=n.layout.span),n.encode(e[n.property],t,r),i+o.encode(e[o.property],t,r+i)}return n.encode(e,t,r)}addVariant(e,t,r){const n=new VariantLayout(this,e,t,r);return this.registry[e]=n,n}getVariant(e,t=0){let r;return r=e instanceof Uint8Array?this.discriminator.decode(e,t):e,this.registry[r]}}t.Union=Union;class VariantLayout extends Layout{constructor(e,t,r,n){if(!(e instanceof Union))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if("string"==typeof r&&void 0===n&&(n=r,r=null),r){if(!(r instanceof Layout))throw new TypeError("layout must be a Layout");if(null!==e.defaultLayout&&0<=r.span&&r.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if("string"!=typeof n)throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=r?r.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,n),this.union=e,this.variant=t,this.layout=r||null}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0;this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span);let n=0;return this.layout&&(n=this.layout.getSpan(e,t+r)),r+n}decode(e,t=0){const r=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let n=0;return this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),this.layout?r[this.property]=this.layout.decode(e,t+n):this.property?r[this.property]=!0:this.union.usesPrefixDiscriminator&&(r[this.union.discriminator.property]=this.variant),r}encode(e,t,r=0){let n=0;if(this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,r);let o=n;if(this.layout&&(this.layout.encode(e[this.property],t,r+n),o+=this.layout.getSpan(t,r+n),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}function fixBitwiseResult(e){return 0>e&&(e+=4294967296),e}t.VariantLayout=VariantLayout;class BitStructure extends Layout{constructor(e,t,r){if(!(e instanceof UInt||e instanceof UIntBE))throw new TypeError("word must be a UInt or UIntBE layout");if("string"==typeof t&&void 0===r&&(r=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,r),this.word=e,this.msb=!!t,this.fields=[];let n=0;this._packedSetValue=function(e){return n=fixBitwiseResult(e),this},this._packedGetValue=function(){return n}}decode(e,t=0){const r=this.makeDestinationObject(),n=this.word.decode(e,t);this._packedSetValue(n);for(const t of this.fields)void 0!==t.property&&(r[t.property]=t.decode(e));return r}encode(e,t,r=0){const n=this.word.decode(t,r);this._packedSetValue(n);for(const t of this.fields)if(void 0!==t.property){const r=e[t.property];void 0!==r&&t.encode(r)}return this.word.encode(this._packedGetValue(),t,r)}addField(e,t){const r=new BitField(this,e,t);return this.fields.push(r),r}addBoolean(e){const t=new Boolean(this,e);return this.fields.push(t),t}fieldFor(e){if("string"!=typeof e)throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}t.BitStructure=BitStructure;class BitField{constructor(e,t,r){if(!(e instanceof BitStructure))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const n=8*e.span,o=e.fields.reduce(((e,t)=>e+t.bits),0);if(t+o>n)throw new Error("bits too long for span remainder ("+(n-o)+" of "+n+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,32===t&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=n-o-t),this.wordMask=fixBitwiseResult(this.valueMask<<this.start),this.property=r}decode(e,t){return fixBitwiseResult(this.container._packedGetValue()&this.wordMask)>>>this.start}encode(e){if("number"!=typeof e||!Number.isInteger(e)||e!==fixBitwiseResult(e&this.valueMask))throw new TypeError(nameWithProperty("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),r=fixBitwiseResult(e<<this.start);this.container._packedSetValue(fixBitwiseResult(t&~this.wordMask)|r)}}t.BitField=BitField;class Boolean extends BitField{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){"boolean"==typeof e&&(e=+e),super.encode(e)}}t.Boolean=Boolean;class Blob extends Layout{constructor(e,t){if(!(e instanceof ExternalLayout&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let r=-1;e instanceof ExternalLayout||(r=e),super(r,t),this.length=e}getSpan(e,t){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),r}decode(e,t=0){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),uint8ArrayToBuffer(e).slice(t,t+r)}encode(e,t,r){let n=this.length;if(this.length instanceof ExternalLayout&&(n=e.length),!(e instanceof Uint8Array&&n===e.length))throw new TypeError(nameWithProperty("Blob.encode",this)+" requires (length "+n+") Uint8Array as src");if(r+n>t.length)throw new RangeError("encoding overruns Uint8Array");const o=uint8ArrayToBuffer(e);return uint8ArrayToBuffer(t).write(o.toString("hex"),r,n,"hex"),this.length instanceof ExternalLayout&&this.length.encode(n,t,r),n}}t.Blob=Blob;class CString extends Layout{constructor(e){super(-1,e)}getSpan(e,t=0){checkUint8Array(e);let r=t;for(;r<e.length&&0!==e[r];)r+=1;return 1+r-t}decode(e,t=0){const r=this.getSpan(e,t);return uint8ArrayToBuffer(e).slice(t,t+r-1).toString("utf-8")}encode(e,t,r=0){"string"!=typeof e&&(e=String(e));const o=n.Buffer.from(e,"utf8"),i=o.length;if(r+i>t.length)throw new RangeError("encoding overruns Buffer");const s=uint8ArrayToBuffer(t);return o.copy(s,r),s[r+i]=0,i+1}}t.CString=CString;class UTF8 extends Layout{constructor(e,t){if("string"==typeof e&&void 0===t&&(t=e,e=void 0),void 0===e)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return checkUint8Array(e),e.length-t}decode(e,t=0){const r=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<r)throw new RangeError("text length exceeds maxSpan");return uint8ArrayToBuffer(e).slice(t,t+r).toString("utf-8")}encode(e,t,r=0){"string"!=typeof e&&(e=String(e));const o=n.Buffer.from(e,"utf8"),i=o.length;if(0<=this.maxSpan&&this.maxSpan<i)throw new RangeError("text length exceeds maxSpan");if(r+i>t.length)throw new RangeError("encoding overruns Buffer");return o.copy(uint8ArrayToBuffer(t),r),i}}t.UTF8=UTF8;class Constant extends Layout{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,r){return 0}}t.Constant=Constant,t.greedy=(e,t)=>new GreedyCount(e,t),t.offset=(e,t,r)=>new OffsetLayout(e,t,r),t.u8=e=>new UInt(1,e),t.u16=e=>new UInt(2,e),t.u24=e=>new UInt(3,e),t.u32=e=>new UInt(4,e),t.u40=e=>new UInt(5,e),t.u48=e=>new UInt(6,e),t.nu64=e=>new NearUInt64(e),t.u16be=e=>new UIntBE(2,e),t.u24be=e=>new UIntBE(3,e),t.u32be=e=>new UIntBE(4,e),t.u40be=e=>new UIntBE(5,e),t.u48be=e=>new UIntBE(6,e),t.nu64be=e=>new NearUInt64BE(e),t.s8=e=>new Int(1,e),t.s16=e=>new Int(2,e),t.s24=e=>new Int(3,e),t.s32=e=>new Int(4,e),t.s40=e=>new Int(5,e),t.s48=e=>new Int(6,e),t.ns64=e=>new NearInt64(e),t.s16be=e=>new IntBE(2,e),t.s24be=e=>new IntBE(3,e),t.s32be=e=>new IntBE(4,e),t.s40be=e=>new IntBE(5,e),t.s48be=e=>new IntBE(6,e),t.ns64be=e=>new NearInt64BE(e),t.f32=e=>new Float(e),t.f32be=e=>new FloatBE(e),t.f64=e=>new Double(e),t.f64be=e=>new DoubleBE(e),t.struct=(e,t,r)=>new Structure(e,t,r),t.bits=(e,t,r)=>new BitStructure(e,t,r),t.seq=(e,t,r)=>new Sequence(e,t,r),t.union=(e,t,r)=>new Union(e,t,r),t.unionLayoutDiscriminator=(e,t)=>new UnionLayoutDiscriminator(e,t),t.blob=(e,t)=>new Blob(e,t),t.cstr=e=>new CString(e),t.utf8=(e,t)=>new UTF8(e,t),t.constant=(e,t)=>new Constant(e,t)},398532:(e,t,r)=>{"use strict";r.d(t,{kc:()=>AddressLookupTableAccount,$v:()=>ComputeBudgetInstruction,d_:()=>ComputeBudgetProgram,mj:()=>_e,J3:()=>PublicKey,Ur:()=>Ne,Sq:()=>SystemInstruction,yq:()=>SystemProgram,ZX:()=>Transaction,fH:()=>TransactionInstruction,wu:()=>TransactionMessage,Kt:()=>VersionedTransaction});var n={};r.r(n),r.d(n,{DO:()=>utils_abytes,OG:()=>bitMask,My:()=>abstract_utils_bytesToHex,bytesToNumberBE:()=>utils_bytesToNumberBE,lX:()=>utils_bytesToNumberLE,Id:()=>abstract_utils_concatBytes,fg:()=>createHmacDrbg,qj:()=>utils_ensureBytes,hexToBytes:()=>utils_hexToBytes,aY:()=>abstract_utils_isBytes,lq:()=>utils_numberToBytesBE,z:()=>utils_numberToBytesLE,Q5:()=>validateObject});var o=r(901048);function _assert_number(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function bytes(e,...t){if(!function isBytes(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function _assert_hash(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");_assert_number(e.outputLen),_assert_number(e.blockLen)}function exists(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function output(e,t){bytes(e);const r=t.outputLen;if(e.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}const i="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;const createView=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),rotr=(e,t)=>e<<32-t|e>>>t;new Uint8Array(new Uint32Array([287454020]).buffer)[0];function utils_utf8ToBytes(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}function toBytes(e){return"string"==typeof e&&(e=utils_utf8ToBytes(e)),bytes(e),e}function utils_concatBytes(...e){let t=0;for(let r=0;r<e.length;r++){const n=e[r];bytes(n),t+=n.length}const r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const o=e[t];r.set(o,n),n+=o.length}return r}class Hash{clone(){return this._cloneInto()}}function utils_wrapConstructor(e){const hashC=t=>e().update(toBytes(t)).digest(),t=e();return hashC.outputLen=t.outputLen,hashC.blockLen=t.blockLen,hashC.create=()=>e(),hashC}function utils_randomBytes(e=32){if(i&&"function"==typeof i.getRandomValues)return i.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}const Maj=(e,t,r)=>e&t^e&r^t&r;class HashMD extends Hash{constructor(e,t,r,n){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=createView(this.buffer)}update(e){exists(this);const{view:t,buffer:r,blockLen:n}=this,o=(e=toBytes(e)).length;for(let i=0;i<o;){const s=Math.min(n-this.pos,o-i);if(s!==n)r.set(e.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===n&&(this.process(t,0),this.pos=0);else{const t=createView(e);for(;n<=o-i;i+=n)this.process(t,i)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){exists(this),output(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:n,isLE:o}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>n-i&&(this.process(r,0),i=0);for(let e=i;e<n;e++)t[e]=0;!function setBigUint64(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const o=BigInt(32),i=BigInt(4294967295),s=Number(r>>o&i),a=Number(r&i),u=n?4:0,c=n?0:4;e.setUint32(t+u,s,n),e.setUint32(t+c,a,n)}(r,n-8,BigInt(8*this.length),o),this.process(r,0);const s=createView(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=a/4,c=this.get();if(u>c.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<u;e++)s.setUint32(4*e,c[e],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:n,finished:o,destroyed:i,pos:s}=this;return e.length=n,e.pos=s,e.finished=o,e.destroyed=i,n%t&&e.buffer.set(r),e}}const s=BigInt(2**32-1),a=BigInt(32);function fromBig(e,t=!1){return t?{h:Number(e&s),l:Number(e>>a&s)}:{h:0|Number(e>>a&s),l:0|Number(e&s)}}const u={fromBig,split:function split(e,t=!1){let r=new Uint32Array(e.length),n=new Uint32Array(e.length);for(let o=0;o<e.length;o++){const{h:i,l:s}=fromBig(e[o],t);[r[o],n[o]]=[i,s]}return[r,n]},toBig:(e,t)=>BigInt(e>>>0)<<a|BigInt(t>>>0),shrSH:(e,t,r)=>e>>>r,shrSL:(e,t,r)=>e<<32-r|t>>>r,rotrSH:(e,t,r)=>e>>>r|t<<32-r,rotrSL:(e,t,r)=>e<<32-r|t>>>r,rotrBH:(e,t,r)=>e<<64-r|t>>>r-32,rotrBL:(e,t,r)=>e>>>r-32|t<<64-r,rotr32H:(e,t)=>t,rotr32L:(e,t)=>e,rotlSH:(e,t,r)=>e<<r|t>>>32-r,rotlSL:(e,t,r)=>t<<r|e>>>32-r,rotlBH:(e,t,r)=>t<<r-32|e>>>64-r,rotlBL:(e,t,r)=>e<<r-32|t>>>64-r,add:function add(e,t,r,n){const o=(t>>>0)+(n>>>0);return{h:e+r+(o/2**32|0)|0,l:0|o}},add3L:(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),add3H:(e,t,r,n)=>t+r+n+(e/2**32|0)|0,add4L:(e,t,r,n)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0),add4H:(e,t,r,n,o)=>t+r+n+o+(e/2**32|0)|0,add5H:(e,t,r,n,o,i)=>t+r+n+o+i+(e/2**32|0)|0,add5L:(e,t,r,n,o)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0)+(o>>>0)},[c,d]=(()=>u.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((e=>BigInt(e)))))(),l=new Uint32Array(80),f=new Uint32Array(80);class SHA512 extends HashMD{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:r,Bl:n,Ch:o,Cl:i,Dh:s,Dl:a,Eh:u,El:c,Fh:d,Fl:l,Gh:f,Gl:p,Hh:y,Hl:g}=this;return[e,t,r,n,o,i,s,a,u,c,d,l,f,p,y,g]}set(e,t,r,n,o,i,s,a,u,c,d,l,f,p,y,g){this.Ah=0|e,this.Al=0|t,this.Bh=0|r,this.Bl=0|n,this.Ch=0|o,this.Cl=0|i,this.Dh=0|s,this.Dl=0|a,this.Eh=0|u,this.El=0|c,this.Fh=0|d,this.Fl=0|l,this.Gh=0|f,this.Gl=0|p,this.Hh=0|y,this.Hl=0|g}process(e,t){for(let r=0;r<16;r++,t+=4)l[r]=e.getUint32(t),f[r]=e.getUint32(t+=4);for(let e=16;e<80;e++){const t=0|l[e-15],r=0|f[e-15],n=u.rotrSH(t,r,1)^u.rotrSH(t,r,8)^u.shrSH(t,r,7),o=u.rotrSL(t,r,1)^u.rotrSL(t,r,8)^u.shrSL(t,r,7),i=0|l[e-2],s=0|f[e-2],a=u.rotrSH(i,s,19)^u.rotrBH(i,s,61)^u.shrSH(i,s,6),c=u.rotrSL(i,s,19)^u.rotrBL(i,s,61)^u.shrSL(i,s,6),d=u.add4L(o,c,f[e-7],f[e-16]),p=u.add4H(d,n,a,l[e-7],l[e-16]);l[e]=0|p,f[e]=0|d}let{Ah:r,Al:n,Bh:o,Bl:i,Ch:s,Cl:a,Dh:p,Dl:y,Eh:g,El:m,Fh:b,Fl:w,Gh:k,Gl:x,Hh:I,Hl:v}=this;for(let e=0;e<80;e++){const t=u.rotrSH(g,m,14)^u.rotrSH(g,m,18)^u.rotrBH(g,m,41),S=u.rotrSL(g,m,14)^u.rotrSL(g,m,18)^u.rotrBL(g,m,41),B=g&b^~g&k,E=m&w^~m&x,P=u.add5L(v,S,E,d[e],f[e]),_=u.add5H(P,I,t,B,c[e],l[e]),A=0|P,L=u.rotrSH(r,n,28)^u.rotrBH(r,n,34)^u.rotrBH(r,n,39),T=u.rotrSL(r,n,28)^u.rotrBL(r,n,34)^u.rotrBL(r,n,39),O=r&o^r&s^o&s,N=n&i^n&a^i&a;I=0|k,v=0|x,k=0|b,x=0|w,b=0|g,w=0|m,({h:g,l:m}=u.add(0|p,0|y,0|_,0|A)),p=0|s,y=0|a,s=0|o,a=0|i,o=0|r,i=0|n;const W=u.add3L(A,T,N);r=u.add3H(W,_,L,O),n=0|W}({h:r,l:n}=u.add(0|this.Ah,0|this.Al,0|r,0|n)),({h:o,l:i}=u.add(0|this.Bh,0|this.Bl,0|o,0|i)),({h:s,l:a}=u.add(0|this.Ch,0|this.Cl,0|s,0|a)),({h:p,l:y}=u.add(0|this.Dh,0|this.Dl,0|p,0|y)),({h:g,l:m}=u.add(0|this.Eh,0|this.El,0|g,0|m)),({h:b,l:w}=u.add(0|this.Fh,0|this.Fl,0|b,0|w)),({h:k,l:x}=u.add(0|this.Gh,0|this.Gl,0|k,0|x)),({h:I,l:v}=u.add(0|this.Hh,0|this.Hl,0|I,0|v)),this.set(r,n,o,i,s,a,p,y,g,m,b,w,k,x,I,v)}roundClean(){l.fill(0),f.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const p=utils_wrapConstructor((()=>new SHA512)),y=(BigInt(0),BigInt(1)),g=BigInt(2);function abstract_utils_isBytes(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}function utils_abytes(e){if(!abstract_utils_isBytes(e))throw new Error("Uint8Array expected")}const m=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function abstract_utils_bytesToHex(e){utils_abytes(e);let t="";for(let r=0;r<e.length;r++)t+=m[e[r]];return t}function hexToNumber(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return BigInt(""===e?"0":`0x${e}`)}const b={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function utils_asciiToBase16(e){return e>=b._0&&e<=b._9?e-b._0:e>=b._A&&e<=b._F?e-(b._A-10):e>=b._a&&e<=b._f?e-(b._a-10):void 0}function utils_hexToBytes(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length,r=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let t=0,o=0;t<r;t++,o+=2){const r=utils_asciiToBase16(e.charCodeAt(o)),i=utils_asciiToBase16(e.charCodeAt(o+1));if(void 0===r||void 0===i){const t=e[o]+e[o+1];throw new Error('hex string expected, got non-hex character "'+t+'" at index '+o)}n[t]=16*r+i}return n}function utils_bytesToNumberBE(e){return hexToNumber(abstract_utils_bytesToHex(e))}function utils_bytesToNumberLE(e){return utils_abytes(e),hexToNumber(abstract_utils_bytesToHex(Uint8Array.from(e).reverse()))}function utils_numberToBytesBE(e,t){return utils_hexToBytes(e.toString(16).padStart(2*t,"0"))}function utils_numberToBytesLE(e,t){return utils_numberToBytesBE(e,t).reverse()}function utils_ensureBytes(e,t,r){let n;if("string"==typeof t)try{n=utils_hexToBytes(t)}catch(r){throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${r}`)}else{if(!abstract_utils_isBytes(t))throw new Error(`${e} must be hex string or Uint8Array`);n=Uint8Array.from(t)}const o=n.length;if("number"==typeof r&&o!==r)throw new Error(`${e} expected ${r} bytes, got ${o}`);return n}function abstract_utils_concatBytes(...e){let t=0;for(let r=0;r<e.length;r++){const n=e[r];utils_abytes(n),t+=n.length}const r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const o=e[t];r.set(o,n),n+=o.length}return r}const bitMask=e=>(g<<BigInt(e-1))-y,u8n=e=>new Uint8Array(e),u8fr=e=>Uint8Array.from(e);function createHmacDrbg(e,t,r){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=u8n(e),o=u8n(e),i=0;const reset=()=>{n.fill(1),o.fill(0),i=0},h=(...e)=>r(o,n,...e),reseed=(e=u8n())=>{o=h(u8fr([0]),e),n=h(),0!==e.length&&(o=h(u8fr([1]),e),n=h())},gen=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const r=[];for(;e<t;){n=h();const t=n.slice();r.push(t),e+=n.length}return abstract_utils_concatBytes(...r)};return(e,t)=>{let r;for(reset(),reseed(e);!(r=t(gen()));)reseed();return reset(),r}}const w={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||abstract_utils_isBytes(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function validateObject(e,t,r={}){const checkField=(t,r,n)=>{const o=w[r];if("function"!=typeof o)throw new Error(`Invalid validator "${r}", expected function`);const i=e[t];if(!(n&&void 0===i||o(i,e)))throw new Error(`Invalid param ${String(t)}=${i} (${typeof i}), expected ${r}`)};for(const[e,r]of Object.entries(t))checkField(e,r,!1);for(const[e,t]of Object.entries(r))checkField(e,t,!0);return e}const k=BigInt(0),x=BigInt(1),I=BigInt(2),v=BigInt(3),S=BigInt(4),B=BigInt(5),E=BigInt(8);BigInt(9),BigInt(16);function modular_mod(e,t){const r=e%t;return r>=k?r:t+r}function pow(e,t,r){if(r<=k||t<k)throw new Error("Expected power/modulo > 0");if(r===x)return k;let n=x;for(;t>k;)t&x&&(n=n*e%r),e=e*e%r,t>>=x;return n}function modular_pow2(e,t,r){let n=e;for(;t-- >k;)n*=n,n%=r;return n}function invert(e,t){if(e===k||t<=k)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let r=modular_mod(e,t),n=t,o=k,i=x,s=x,a=k;for(;r!==k;){const e=n/r,t=n%r,u=o-s*e,c=i-a*e;n=r,r=t,o=s,i=a,s=u,a=c}if(n!==x)throw new Error("invert: does not exist");return modular_mod(o,t)}function FpSqrt(e){if(e%S===v){const t=(e+x)/S;return function sqrt3mod4(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}if(e%E===B){const t=(e-B)/E;return function sqrt5mod8(e,r){const n=e.mul(r,I),o=e.pow(n,t),i=e.mul(r,o),s=e.mul(e.mul(i,I),o),a=e.mul(i,e.sub(s,e.ONE));if(!e.eql(e.sqr(a),r))throw new Error("Cannot find square root");return a}}return function tonelliShanks(e){const t=(e-x)/I;let r,n,o;for(r=e-x,n=0;r%I===k;r/=I,n++);for(o=I;o<e&&pow(o,t,e)!==e-x;o++);if(1===n){const t=(e+x)/S;return function tonelliFast(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}const i=(r+x)/I;return function tonelliSlow(e,s){if(e.pow(s,t)===e.neg(e.ONE))throw new Error("Cannot find square root");let a=n,u=e.pow(e.mul(e.ONE,o),r),c=e.pow(s,i),d=e.pow(s,r);for(;!e.eql(d,e.ONE);){if(e.eql(d,e.ZERO))return e.ZERO;let t=1;for(let r=e.sqr(d);t<a&&!e.eql(r,e.ONE);t++)r=e.sqr(r);const r=e.pow(u,x<<BigInt(a-t-1));u=e.sqr(r),c=e.mul(c,r),d=e.mul(d,u),a=t}return c}}(e)}const modular_isNegativeLE=(e,t)=>(modular_mod(e,t)&x)===x,P=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function nLength(e,t){const r=void 0!==t?t:e.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Field(e,t,r=!1,n={}){if(e<=k)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:o,nByteLength:i}=nLength(e,t);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=FpSqrt(e),a=Object.freeze({ORDER:e,BITS:o,BYTES:i,MASK:bitMask(o),ZERO:k,ONE:x,create:t=>modular_mod(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("Invalid field element: expected bigint, got "+typeof t);return k<=t&&t<e},is0:e=>e===k,isOdd:e=>(e&x)===x,neg:t=>modular_mod(-t,e),eql:(e,t)=>e===t,sqr:t=>modular_mod(t*t,e),add:(t,r)=>modular_mod(t+r,e),sub:(t,r)=>modular_mod(t-r,e),mul:(t,r)=>modular_mod(t*r,e),pow:(e,t)=>function FpPow(e,t,r){if(r<k)throw new Error("Expected power > 0");if(r===k)return e.ONE;if(r===x)return t;let n=e.ONE,o=t;for(;r>k;)r&x&&(n=e.mul(n,o)),o=e.sqr(o),r>>=x;return n}(a,e,t),div:(t,r)=>modular_mod(t*invert(r,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>invert(t,e),sqrt:n.sqrt||(e=>s(a,e)),invertBatch:e=>function FpInvertBatch(e,t){const r=new Array(t.length),n=t.reduce(((t,n,o)=>e.is0(n)?t:(r[o]=t,e.mul(t,n))),e.ONE),o=e.inv(n);return t.reduceRight(((t,n,o)=>e.is0(n)?t:(r[o]=e.mul(t,r[o]),e.mul(t,n))),o),r}(a,e),cmov:(e,t,r)=>r?t:e,toBytes:e=>r?utils_numberToBytesLE(e,i):utils_numberToBytesBE(e,i),fromBytes:e=>{if(e.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${e.length}`);return r?utils_bytesToNumberLE(e):utils_bytesToNumberBE(e)}});return Object.freeze(a)}function getFieldBytesLength(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function getMinHashLength(e){const t=getFieldBytesLength(e);return t+Math.ceil(t/2)}const _=BigInt(0),A=BigInt(1);function wNAF(e,t){const constTimeNegate=(e,t)=>{const r=t.negate();return e?r:t},opts=e=>({windows:Math.ceil(t/e)+1,windowSize:2**(e-1)});return{constTimeNegate,unsafeLadder(t,r){let n=e.ZERO,o=t;for(;r>_;)r&A&&(n=n.add(o)),o=o.double(),r>>=A;return n},precomputeWindow(e,t){const{windows:r,windowSize:n}=opts(t),o=[];let i=e,s=i;for(let e=0;e<r;e++){s=i,o.push(s);for(let e=1;e<n;e++)s=s.add(i),o.push(s);i=s.double()}return o},wNAF(t,r,n){const{windows:o,windowSize:i}=opts(t);let s=e.ZERO,a=e.BASE;const u=BigInt(2**t-1),c=2**t,d=BigInt(t);for(let e=0;e<o;e++){const t=e*i;let o=Number(n&u);n>>=d,o>i&&(o-=c,n+=A);const l=t,f=t+Math.abs(o)-1,p=e%2!=0,y=o<0;0===o?a=a.add(constTimeNegate(p,r[l])):s=s.add(constTimeNegate(y,r[f]))}return{p:s,f:a}},wNAFCached(e,t,r,n){const o=e._WINDOW_SIZE||1;let i=t.get(e);return i||(i=this.precomputeWindow(e,o),1!==o&&t.set(e,n(i))),this.wNAF(o,i,r)}}}function validateBasic(e){return function validateField(e){return validateObject(e,P.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}(e.Fp),validateObject(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}const L=BigInt(0),T=BigInt(1),O=BigInt(2),N=BigInt(8),W={zip215:!0};function twistedEdwards(e){const t=function validateOpts(e){const t=validateBasic(e);return validateObject(e,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}(e),{Fp:r,n,prehash:o,hash:i,randomBytes:s,nByteLength:a,h:u}=t,c=O<<BigInt(8*a)-T,d=r.create,l=t.uvRatio||((e,t)=>{try{return{isValid:!0,value:r.sqrt(e*r.inv(t))}}catch(e){return{isValid:!1,value:L}}}),f=t.adjustScalarBytes||(e=>e),p=t.domain||((e,t,r)=>{if(t.length||r)throw new Error("Contexts/pre-hash are not supported");return e}),inBig=e=>"bigint"==typeof e&&L<e,inRange=(e,t)=>inBig(e)&&inBig(t)&&e<t,in0MaskRange=e=>e===L||inRange(e,c);function assertInRange(e,t){if(inRange(e,t))return e;throw new Error(`Expected valid scalar < ${t}, got ${typeof e} ${e}`)}function assertGE0(e){return e===L?e:assertInRange(e,n)}const y=new Map;function isPoint(e){if(!(e instanceof Point))throw new Error("ExtendedPoint expected")}class Point{constructor(e,t,r,n){if(this.ex=e,this.ey=t,this.ez=r,this.et=n,!in0MaskRange(e))throw new Error("x required");if(!in0MaskRange(t))throw new Error("y required");if(!in0MaskRange(r))throw new Error("z required");if(!in0MaskRange(n))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(e){if(e instanceof Point)throw new Error("extended point not allowed");const{x:t,y:r}=e||{};if(!in0MaskRange(t)||!in0MaskRange(r))throw new Error("invalid affine point");return new Point(t,r,T,d(t*r))}static normalizeZ(e){const t=r.invertBatch(e.map((e=>e.ez)));return e.map(((e,r)=>e.toAffine(t[r]))).map(Point.fromAffine)}_setWindowSize(e){this._WINDOW_SIZE=e,y.delete(this)}assertValidity(){const{a:e,d:r}=t;if(this.is0())throw new Error("bad point: ZERO");const{ex:n,ey:o,ez:i,et:s}=this,a=d(n*n),u=d(o*o),c=d(i*i),l=d(c*c),f=d(a*e);if(d(c*d(f+u))!==d(l+d(r*d(a*u))))throw new Error("bad point: equation left != right (1)");if(d(n*o)!==d(i*s))throw new Error("bad point: equation left != right (2)")}equals(e){isPoint(e);const{ex:t,ey:r,ez:n}=this,{ex:o,ey:i,ez:s}=e,a=d(t*s),u=d(o*n),c=d(r*s),l=d(i*n);return a===u&&c===l}is0(){return this.equals(Point.ZERO)}negate(){return new Point(d(-this.ex),this.ey,this.ez,d(-this.et))}double(){const{a:e}=t,{ex:r,ey:n,ez:o}=this,i=d(r*r),s=d(n*n),a=d(O*d(o*o)),u=d(e*i),c=r+n,l=d(d(c*c)-i-s),f=u+s,p=f-a,y=u-s,g=d(l*p),m=d(f*y),b=d(l*y),w=d(p*f);return new Point(g,m,w,b)}add(e){isPoint(e);const{a:r,d:n}=t,{ex:o,ey:i,ez:s,et:a}=this,{ex:u,ey:c,ez:l,et:f}=e;if(r===BigInt(-1)){const e=d((i-o)*(c+u)),t=d((i+o)*(c-u)),r=d(t-e);if(r===L)return this.double();const n=d(s*O*f),p=d(a*O*l),y=p+n,g=t+e,m=p-n,b=d(y*r),w=d(g*m),k=d(y*m),x=d(r*g);return new Point(b,w,x,k)}const p=d(o*u),y=d(i*c),g=d(a*n*f),m=d(s*l),b=d((o+i)*(u+c)-p-y),w=m-g,k=m+g,x=d(y-r*p),I=d(b*w),v=d(k*x),S=d(b*x),B=d(w*k);return new Point(I,v,B,S)}subtract(e){return this.add(e.negate())}wNAF(e){return b.wNAFCached(this,y,e,Point.normalizeZ)}multiply(e){const{p:t,f:r}=this.wNAF(assertInRange(e,n));return Point.normalizeZ([t,r])[0]}multiplyUnsafe(e){let t=assertGE0(e);return t===L?m:this.equals(m)||t===T?this:this.equals(g)?this.wNAF(t).p:b.unsafeLadder(this,t)}isSmallOrder(){return this.multiplyUnsafe(u).is0()}isTorsionFree(){return b.unsafeLadder(this,n).is0()}toAffine(e){const{ex:t,ey:n,ez:o}=this,i=this.is0();null==e&&(e=i?N:r.inv(o));const s=d(t*e),a=d(n*e),u=d(o*e);if(i)return{x:L,y:T};if(u!==T)throw new Error("invZ was invalid");return{x:s,y:a}}clearCofactor(){const{h:e}=t;return e===T?this:this.multiplyUnsafe(e)}static fromHex(e,n=!1){const{d:o,a:i}=t,s=r.BYTES,a=(e=utils_ensureBytes("pointHex",e,s)).slice(),u=e[s-1];a[s-1]=-129&u;const f=utils_bytesToNumberLE(a);f===L||assertInRange(f,n?c:r.ORDER);const p=d(f*f),y=d(p-T),g=d(o*p-i);let{isValid:m,value:b}=l(y,g);if(!m)throw new Error("Point.fromHex: invalid y coordinate");const w=(b&T)===T,k=!!(128&u);if(!n&&b===L&&k)throw new Error("Point.fromHex: x=0 and x_0=1");return k!==w&&(b=d(-b)),Point.fromAffine({x:b,y:f})}static fromPrivateKey(e){return getExtendedPublicKey(e).point}toRawBytes(){const{x:e,y:t}=this.toAffine(),n=utils_numberToBytesLE(t,r.BYTES);return n[n.length-1]|=e&T?128:0,n}toHex(){return abstract_utils_bytesToHex(this.toRawBytes())}}Point.BASE=new Point(t.Gx,t.Gy,T,d(t.Gx*t.Gy)),Point.ZERO=new Point(L,T,T,L);const{BASE:g,ZERO:m}=Point,b=wNAF(Point,8*a);function modN(e){return modular_mod(e,n)}function modN_LE(e){return modN(utils_bytesToNumberLE(e))}function getExtendedPublicKey(e){const t=a;e=utils_ensureBytes("private key",e,t);const r=utils_ensureBytes("hashed private key",i(e),2*t),n=f(r.slice(0,t)),o=r.slice(t,2*t),s=modN_LE(n),u=g.multiply(s),c=u.toRawBytes();return{head:n,prefix:o,scalar:s,point:u,pointBytes:c}}function hashDomainToScalar(e=new Uint8Array,...t){const r=abstract_utils_concatBytes(...t);return modN_LE(i(p(r,utils_ensureBytes("context",e),!!o)))}const w=W;g._setWindowSize(8);return{CURVE:t,getPublicKey:function getPublicKey(e){return getExtendedPublicKey(e).pointBytes},sign:function sign(e,t,n={}){e=utils_ensureBytes("message",e),o&&(e=o(e));const{prefix:i,scalar:s,pointBytes:u}=getExtendedPublicKey(t),c=hashDomainToScalar(n.context,i,e),d=g.multiply(c).toRawBytes(),l=modN(c+hashDomainToScalar(n.context,d,u,e)*s);return assertGE0(l),utils_ensureBytes("result",abstract_utils_concatBytes(d,utils_numberToBytesLE(l,r.BYTES)),2*a)},verify:function verify(e,t,n,i=w){const{context:s,zip215:a}=i,u=r.BYTES;e=utils_ensureBytes("signature",e,2*u),t=utils_ensureBytes("message",t),o&&(t=o(t));const c=utils_bytesToNumberLE(e.slice(u,2*u));let d,l,f;try{d=Point.fromHex(n,a),l=Point.fromHex(e.slice(0,u),a),f=g.multiplyUnsafe(c)}catch(e){return!1}if(!a&&d.isSmallOrder())return!1;const p=hashDomainToScalar(s,l.toRawBytes(),d.toRawBytes(),t);return l.add(d.multiplyUnsafe(p)).subtract(f).clearCofactor().equals(Point.ZERO)},ExtendedPoint:Point,utils:{getExtendedPublicKey,randomPrivateKey:()=>s(r.BYTES),precompute:(e=8,t=Point.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)}}}const K=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),R=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),j=(BigInt(0),BigInt(1)),C=BigInt(2),z=BigInt(5),q=BigInt(10),U=BigInt(20),D=BigInt(40),F=BigInt(80);function ed25519_pow_2_252_3(e){const t=K,r=e*e%t*e%t,n=modular_pow2(r,C,t)*r%t,o=modular_pow2(n,j,t)*e%t,i=modular_pow2(o,z,t)*o%t,s=modular_pow2(i,q,t)*i%t,a=modular_pow2(s,U,t)*s%t,u=modular_pow2(a,D,t)*a%t,c=modular_pow2(u,F,t)*u%t,d=modular_pow2(c,F,t)*u%t,l=modular_pow2(d,q,t)*i%t;return{pow_p_5_8:modular_pow2(l,C,t)*e%t,b2:r}}function adjustScalarBytes(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}function uvRatio(e,t){const r=K,n=modular_mod(t*t*t,r),o=modular_mod(n*n*t,r);let i=modular_mod(e*n*ed25519_pow_2_252_3(e*o).pow_p_5_8,r);const s=modular_mod(t*i*i,r),a=i,u=modular_mod(i*R,r),c=s===e,d=s===modular_mod(-e,r),l=s===modular_mod(-e*R,r);return c&&(i=a),(d||l)&&(i=u),modular_isNegativeLE(i,r)&&(i=modular_mod(-i,r)),{isValid:c||d,value:i}}const Y=Field(K,void 0,!0),M={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Y,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:p,randomBytes:utils_randomBytes,adjustScalarBytes,uvRatio},H=twistedEdwards(M);function ed25519_domain(e,t,r){if(t.length>255)throw new Error("Context is too big");return utils_concatBytes(utils_utf8ToBytes("SigEd25519 no Ed25519 collisions"),new Uint8Array([r?1:0,t.length]),t,e)}const V=(Y.ORDER+BigInt(3))/BigInt(8);Y.pow(C,V),Y.sqrt(Y.neg(Y.ONE)),Y.ORDER,BigInt(5),BigInt(8),BigInt(486662);(function FpSqrtEven(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const r=e.sqrt(t);return e.isOdd(r)?e.neg(r):r})(Y,Y.neg(BigInt(486664)));BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");var $=r(682823),G=r.n($),Z=r(939216),J=r.n(Z),X=r(552001),Q=r(881818),ee=r(878918),te=r(856115),re=r(727801),ne=(r(759499),r(516246)),oe=(r(885364),r(52494));const ie=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),se=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ae=new Uint32Array(64);class SHA256 extends HashMD{constructor(){super(64,32,8,!1),this.A=0|se[0],this.B=0|se[1],this.C=0|se[2],this.D=0|se[3],this.E=0|se[4],this.F=0|se[5],this.G=0|se[6],this.H=0|se[7]}get(){const{A:e,B:t,C:r,D:n,E:o,F:i,G:s,H:a}=this;return[e,t,r,n,o,i,s,a]}set(e,t,r,n,o,i,s,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|n,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)ae[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=ae[e-15],r=ae[e-2],n=rotr(t,7)^rotr(t,18)^t>>>3,o=rotr(r,17)^rotr(r,19)^r>>>10;ae[e]=o+ae[e-7]+n+ae[e-16]|0}let{A:r,B:n,C:o,D:i,E:s,F:a,G:u,H:c}=this;for(let e=0;e<64;e++){const t=c+(rotr(s,6)^rotr(s,11)^rotr(s,25))+((d=s)&a^~d&u)+ie[e]+ae[e]|0,l=(rotr(r,2)^rotr(r,13)^rotr(r,22))+Maj(r,n,o)|0;c=u,u=a,a=s,s=i+t|0,i=o,o=n,n=r,r=t+l|0}var d;r=r+this.A|0,n=n+this.B|0,o=o+this.C|0,i=i+this.D|0,s=s+this.E|0,a=a+this.F|0,u=u+this.G|0,c=c+this.H|0,this.set(r,n,o,i,s,a,u,c)}roundClean(){ae.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const ue=utils_wrapConstructor((()=>new SHA256));class HMAC extends Hash{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,_assert_hash(e);const r=toBytes(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,o=new Uint8Array(n);o.set(r.length>n?e.create().update(r).digest():r);for(let e=0;e<o.length;e++)o[e]^=54;this.iHash.update(o),this.oHash=e.create();for(let e=0;e<o.length;e++)o[e]^=106;this.oHash.update(o),o.fill(0)}update(e){return exists(this),this.iHash.update(e),this}digestInto(e){exists(this),bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:n,destroyed:o,blockLen:i,outputLen:s}=this;return e.finished=n,e.destroyed=o,e.blockLen=i,e.outputLen=s,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(e,t,r)=>new HMAC(e,t).update(r).digest();hmac.create=(e,t)=>new HMAC(e,t);const{bytesToNumberBE:ce,hexToBytes:de}=n,le={Err:class DERErr extends Error{constructor(e=""){super(e)}},_parseInt(e){const{Err:t}=le;if(e.length<2||2!==e[0])throw new t("Invalid signature integer tag");const r=e[1],n=e.subarray(2,r+2);if(!r||n.length!==r)throw new t("Invalid signature integer: wrong length");if(128&n[0])throw new t("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new t("Invalid signature integer: unnecessary leading zero");return{d:ce(n),l:e.subarray(r+2)}},toSig(e){const{Err:t}=le,r="string"==typeof e?de(e):e;utils_abytes(r);let n=r.length;if(n<2||48!=r[0])throw new t("Invalid signature tag");if(r[1]!==n-2)throw new t("Invalid signature: incorrect length");const{d:o,l:i}=le._parseInt(r.subarray(2)),{d:s,l:a}=le._parseInt(i);if(a.length)throw new t("Invalid signature: left bytes after parsing");return{r:o,s}},hexFromSig(e){const slice=e=>8&Number.parseInt(e[0],16)?"00"+e:e,h=e=>{const t=e.toString(16);return 1&t.length?`0${t}`:t},t=slice(h(e.s)),r=slice(h(e.r)),n=t.length/2,o=r.length/2,i=h(n),s=h(o);return`30${h(o+n+4)}02${s}${r}02${i}${t}`}},he=BigInt(0),fe=BigInt(1),pe=(BigInt(2),BigInt(3));BigInt(4);function weierstrassPoints(e){const t=function validatePointOpts(e){const t=validateBasic(e);validateObject(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:o}=t;if(r){if(!n.eql(o,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}(e),{Fp:r}=t,n=t.toBytes||((e,t,n)=>{const o=t.toAffine();return abstract_utils_concatBytes(Uint8Array.from([4]),r.toBytes(o.x),r.toBytes(o.y))}),o=t.fromBytes||(e=>{const t=e.subarray(1);return{x:r.fromBytes(t.subarray(0,r.BYTES)),y:r.fromBytes(t.subarray(r.BYTES,2*r.BYTES))}});function weierstrassEquation(e){const{a:n,b:o}=t,i=r.sqr(e),s=r.mul(i,e);return r.add(r.add(s,r.mul(e,n)),o)}if(!r.eql(r.sqr(t.Gy),weierstrassEquation(t.Gx)))throw new Error("bad generator point: equation left != right");function isWithinCurveOrder(e){return"bigint"==typeof e&&he<e&&e<t.n}function assertGE(e){if(!isWithinCurveOrder(e))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function normPrivateKeyToScalar(e){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:o,n:i}=t;if(r&&"bigint"!=typeof e){if(abstract_utils_isBytes(e)&&(e=abstract_utils_bytesToHex(e)),"string"!=typeof e||!r.includes(e.length))throw new Error("Invalid key");e=e.padStart(2*n,"0")}let s;try{s="bigint"==typeof e?e:utils_bytesToNumberBE(utils_ensureBytes("private key",e,n))}catch(t){throw new Error(`private key must be ${n} bytes, hex or bigint, not ${typeof e}`)}return o&&(s=modular_mod(s,i)),assertGE(s),s}const i=new Map;function assertPrjPoint(e){if(!(e instanceof Point))throw new Error("ProjectivePoint expected")}class Point{constructor(e,t,n){if(this.px=e,this.py=t,this.pz=n,null==e||!r.isValid(e))throw new Error("x required");if(null==t||!r.isValid(t))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required")}static fromAffine(e){const{x:t,y:n}=e||{};if(!e||!r.isValid(t)||!r.isValid(n))throw new Error("invalid affine point");if(e instanceof Point)throw new Error("projective point not allowed");const is0=e=>r.eql(e,r.ZERO);return is0(t)&&is0(n)?Point.ZERO:new Point(t,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(Point.fromAffine)}static fromHex(e){const t=Point.fromAffine(o(utils_ensureBytes("pointHex",e)));return t.assertValidity(),t}static fromPrivateKey(e){return Point.BASE.multiply(normPrivateKeyToScalar(e))}_setWindowSize(e){this._WINDOW_SIZE=e,i.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:e,y:n}=this.toAffine();if(!r.isValid(e)||!r.isValid(n))throw new Error("bad point: x or y not FE");const o=r.sqr(n),i=weierstrassEquation(e);if(!r.eql(o,i))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:e}=this.toAffine();if(r.isOdd)return!r.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){assertPrjPoint(e);const{px:t,py:n,pz:o}=this,{px:i,py:s,pz:a}=e,u=r.eql(r.mul(t,a),r.mul(i,o)),c=r.eql(r.mul(n,a),r.mul(s,o));return u&&c}negate(){return new Point(this.px,r.neg(this.py),this.pz)}double(){const{a:e,b:n}=t,o=r.mul(n,pe),{px:i,py:s,pz:a}=this;let u=r.ZERO,c=r.ZERO,d=r.ZERO,l=r.mul(i,i),f=r.mul(s,s),p=r.mul(a,a),y=r.mul(i,s);return y=r.add(y,y),d=r.mul(i,a),d=r.add(d,d),u=r.mul(e,d),c=r.mul(o,p),c=r.add(u,c),u=r.sub(f,c),c=r.add(f,c),c=r.mul(u,c),u=r.mul(y,u),d=r.mul(o,d),p=r.mul(e,p),y=r.sub(l,p),y=r.mul(e,y),y=r.add(y,d),d=r.add(l,l),l=r.add(d,l),l=r.add(l,p),l=r.mul(l,y),c=r.add(c,l),p=r.mul(s,a),p=r.add(p,p),l=r.mul(p,y),u=r.sub(u,l),d=r.mul(p,f),d=r.add(d,d),d=r.add(d,d),new Point(u,c,d)}add(e){assertPrjPoint(e);const{px:n,py:o,pz:i}=this,{px:s,py:a,pz:u}=e;let c=r.ZERO,d=r.ZERO,l=r.ZERO;const f=t.a,p=r.mul(t.b,pe);let y=r.mul(n,s),g=r.mul(o,a),m=r.mul(i,u),b=r.add(n,o),w=r.add(s,a);b=r.mul(b,w),w=r.add(y,g),b=r.sub(b,w),w=r.add(n,i);let k=r.add(s,u);return w=r.mul(w,k),k=r.add(y,m),w=r.sub(w,k),k=r.add(o,i),c=r.add(a,u),k=r.mul(k,c),c=r.add(g,m),k=r.sub(k,c),l=r.mul(f,w),c=r.mul(p,m),l=r.add(c,l),c=r.sub(g,l),l=r.add(g,l),d=r.mul(c,l),g=r.add(y,y),g=r.add(g,y),m=r.mul(f,m),w=r.mul(p,w),g=r.add(g,m),m=r.sub(y,m),m=r.mul(f,m),w=r.add(w,m),y=r.mul(g,w),d=r.add(d,y),y=r.mul(k,w),c=r.mul(b,c),c=r.sub(c,y),y=r.mul(b,g),l=r.mul(k,l),l=r.add(l,y),new Point(c,d,l)}subtract(e){return this.add(e.negate())}is0(){return this.equals(Point.ZERO)}wNAF(e){return a.wNAFCached(this,i,e,(e=>{const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(Point.fromAffine)}))}multiplyUnsafe(e){const n=Point.ZERO;if(e===he)return n;if(assertGE(e),e===fe)return this;const{endo:o}=t;if(!o)return a.unsafeLadder(this,e);let{k1neg:i,k1:s,k2neg:u,k2:c}=o.splitScalar(e),d=n,l=n,f=this;for(;s>he||c>he;)s&fe&&(d=d.add(f)),c&fe&&(l=l.add(f)),f=f.double(),s>>=fe,c>>=fe;return i&&(d=d.negate()),u&&(l=l.negate()),l=new Point(r.mul(l.px,o.beta),l.py,l.pz),d.add(l)}multiply(e){assertGE(e);let n,o,i=e;const{endo:s}=t;if(s){const{k1neg:e,k1:t,k2neg:u,k2:c}=s.splitScalar(i);let{p:d,f:l}=this.wNAF(t),{p:f,f:p}=this.wNAF(c);d=a.constTimeNegate(e,d),f=a.constTimeNegate(u,f),f=new Point(r.mul(f.px,s.beta),f.py,f.pz),n=d.add(f),o=l.add(p)}else{const{p:e,f:t}=this.wNAF(i);n=e,o=t}return Point.normalizeZ([n,o])[0]}multiplyAndAddUnsafe(e,t,r){const n=Point.BASE,mul=(e,t)=>t!==he&&t!==fe&&e.equals(n)?e.multiply(t):e.multiplyUnsafe(t),o=mul(this,t).add(mul(e,r));return o.is0()?void 0:o}toAffine(e){const{px:t,py:n,pz:o}=this,i=this.is0();null==e&&(e=i?r.ONE:r.inv(o));const s=r.mul(t,e),a=r.mul(n,e),u=r.mul(o,e);if(i)return{x:r.ZERO,y:r.ZERO};if(!r.eql(u,r.ONE))throw new Error("invZ was invalid");return{x:s,y:a}}isTorsionFree(){const{h:e,isTorsionFree:r}=t;if(e===fe)return!0;if(r)return r(Point,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:r}=t;return e===fe?this:r?r(Point,this):this.multiplyUnsafe(t.h)}toRawBytes(e=!0){return this.assertValidity(),n(Point,this,e)}toHex(e=!0){return abstract_utils_bytesToHex(this.toRawBytes(e))}}Point.BASE=new Point(t.Gx,t.Gy,r.ONE),Point.ZERO=new Point(r.ZERO,r.ONE,r.ZERO);const s=t.nBitLength,a=wNAF(Point,t.endo?Math.ceil(s/2):s);return{CURVE:t,ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder}}function weierstrass(e){const t=function weierstrass_validateOpts(e){const t=validateBasic(e);return validateObject(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}(e),{Fp:r,n}=t,o=r.BYTES+1,i=2*r.BYTES+1;function modN(e){return modular_mod(e,n)}function invN(e){return invert(e,n)}const{ProjectivePoint:s,normPrivateKeyToScalar:a,weierstrassEquation:u,isWithinCurveOrder:c}=weierstrassPoints({...t,toBytes(e,t,n){const o=t.toAffine(),i=r.toBytes(o.x),s=abstract_utils_concatBytes;return n?s(Uint8Array.from([t.hasEvenY()?2:3]),i):s(Uint8Array.from([4]),i,r.toBytes(o.y))},fromBytes(e){const t=e.length,n=e[0],s=e.subarray(1);if(t!==o||2!==n&&3!==n){if(t===i&&4===n){return{x:r.fromBytes(s.subarray(0,r.BYTES)),y:r.fromBytes(s.subarray(r.BYTES,2*r.BYTES))}}throw new Error(`Point of length ${t} was invalid. Expected ${o} compressed bytes or ${i} uncompressed bytes`)}{const e=utils_bytesToNumberBE(s);if(!function isValidFieldElement(e){return he<e&&e<r.ORDER}(e))throw new Error("Point is not on curve");const t=u(e);let o;try{o=r.sqrt(t)}catch(e){const t=e instanceof Error?": "+e.message:"";throw new Error("Point is not on curve"+t)}return!(1&~n)!==((o&fe)===fe)&&(o=r.neg(o)),{x:e,y:o}}}}),numToNByteStr=e=>abstract_utils_bytesToHex(utils_numberToBytesBE(e,t.nByteLength));function isBiggerThanHalfOrder(e){return e>n>>fe}const slcNum=(e,t,r)=>utils_bytesToNumberBE(e.slice(t,r));class Signature{constructor(e,t,r){this.r=e,this.s=t,this.recovery=r,this.assertValidity()}static fromCompact(e){const r=t.nByteLength;return e=utils_ensureBytes("compactSignature",e,2*r),new Signature(slcNum(e,0,r),slcNum(e,r,2*r))}static fromDER(e){const{r:t,s:r}=le.toSig(utils_ensureBytes("DER",e));return new Signature(t,r)}assertValidity(){if(!c(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!c(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(e){return new Signature(this.r,this.s,e)}recoverPublicKey(e){const{r:n,s:o,recovery:i}=this,a=f(utils_ensureBytes("msgHash",e));if(null==i||![0,1,2,3].includes(i))throw new Error("recovery id invalid");const u=2===i||3===i?n+t.n:n;if(u>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const c=1&i?"03":"02",d=s.fromHex(c+numToNByteStr(u)),l=invN(u),p=modN(-a*l),y=modN(o*l),g=s.BASE.multiplyAndAddUnsafe(d,p,y);if(!g)throw new Error("point at infinify");return g.assertValidity(),g}hasHighS(){return isBiggerThanHalfOrder(this.s)}normalizeS(){return this.hasHighS()?new Signature(this.r,modN(-this.s),this.recovery):this}toDERRawBytes(){return utils_hexToBytes(this.toDERHex())}toDERHex(){return le.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return utils_hexToBytes(this.toCompactHex())}toCompactHex(){return numToNByteStr(this.r)+numToNByteStr(this.s)}}const d={isValidPrivateKey(e){try{return a(e),!0}catch(e){return!1}},normPrivateKeyToScalar:a,randomPrivateKey:()=>{const e=getMinHashLength(t.n);return function mapHashToField(e,t,r=!1){const n=e.length,o=getFieldBytesLength(t),i=getMinHashLength(t);if(n<16||n<i||n>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${n}`);const s=modular_mod(r?utils_bytesToNumberBE(e):utils_bytesToNumberLE(e),t-x)+x;return r?utils_numberToBytesLE(s,o):utils_numberToBytesBE(s,o)}(t.randomBytes(e),t.n)},precompute:(e=8,t=s.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function isProbPub(e){const t=abstract_utils_isBytes(e),r="string"==typeof e,n=(t||r)&&e.length;return t?n===o||n===i:r?n===2*o||n===2*i:e instanceof s}const l=t.bits2int||function(e){const r=utils_bytesToNumberBE(e),n=8*e.length-t.nBitLength;return n>0?r>>BigInt(n):r},f=t.bits2int_modN||function(e){return modN(l(e))},p=bitMask(t.nBitLength);function int2octets(e){if("bigint"!=typeof e)throw new Error("bigint expected");if(!(he<=e&&e<p))throw new Error(`bigint expected < 2^${t.nBitLength}`);return utils_numberToBytesBE(e,t.nByteLength)}function prepSig(e,n,o=y){if(["recovered","canonical"].some((e=>e in o)))throw new Error("sign() legacy options not supported");const{hash:i,randomBytes:u}=t;let{lowS:d,prehash:p,extraEntropy:g}=o;null==d&&(d=!0),e=utils_ensureBytes("msgHash",e),p&&(e=utils_ensureBytes("prehashed msgHash",i(e)));const m=f(e),b=a(n),w=[int2octets(b),int2octets(m)];if(null!=g&&!1!==g){const e=!0===g?u(r.BYTES):g;w.push(utils_ensureBytes("extraEntropy",e))}const k=abstract_utils_concatBytes(...w),x=m;return{seed:k,k2sig:function k2sig(e){const t=l(e);if(!c(t))return;const r=invN(t),n=s.BASE.multiply(t).toAffine(),o=modN(n.x);if(o===he)return;const i=modN(r*modN(x+o*b));if(i===he)return;let a=(n.x===o?0:2)|Number(n.y&fe),u=i;return d&&isBiggerThanHalfOrder(i)&&(u=function normalizeS(e){return isBiggerThanHalfOrder(e)?modN(-e):e}(i),a^=1),new Signature(o,u,a)}}}const y={lowS:t.lowS,prehash:!1},g={lowS:t.lowS,prehash:!1};return s.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function getPublicKey(e,t=!0){return s.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function getSharedSecret(e,t,r=!0){if(isProbPub(e))throw new Error("first arg must be private key");if(!isProbPub(t))throw new Error("second arg must be public key");return s.fromHex(t).multiply(a(e)).toRawBytes(r)},sign:function sign(e,r,n=y){const{seed:o,k2sig:i}=prepSig(e,r,n),s=t;return createHmacDrbg(s.hash.outputLen,s.nByteLength,s.hmac)(o,i)},verify:function verify(e,r,n,o=g){const i=e;if(r=utils_ensureBytes("msgHash",r),n=utils_ensureBytes("publicKey",n),"strict"in o)throw new Error("options.strict was renamed to lowS");const{lowS:a,prehash:u}=o;let c,d;try{if("string"==typeof i||abstract_utils_isBytes(i))try{c=Signature.fromDER(i)}catch(e){if(!(e instanceof le.Err))throw e;c=Signature.fromCompact(i)}else{if("object"!=typeof i||"bigint"!=typeof i.r||"bigint"!=typeof i.s)throw new Error("PARSE");{const{r:e,s:t}=i;c=new Signature(e,t)}}d=s.fromHex(n)}catch(e){if("PARSE"===e.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(a&&c.hasHighS())return!1;u&&(r=t.hash(r));const{r:l,s:p}=c,y=f(r),m=invN(p),b=modN(y*m),w=modN(l*m),k=s.BASE.multiplyAndAddUnsafe(d,b,w)?.toAffine();return!!k&&modN(k.x)===l},ProjectivePoint:s,Signature,utils:d}}function getHash(e){return{hash:e,hmac:(t,...r)=>hmac(e,t,utils_concatBytes(...r)),randomBytes:utils_randomBytes}}const ye=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),ge=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),me=BigInt(1),be=BigInt(2),divNearest=(e,t)=>(e+t/be)/t;function sqrtMod(e){const t=ye,r=BigInt(3),n=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),a=BigInt(44),u=BigInt(88),c=e*e*e%t,d=c*c*e%t,l=modular_pow2(d,r,t)*d%t,f=modular_pow2(l,r,t)*d%t,p=modular_pow2(f,be,t)*c%t,y=modular_pow2(p,o,t)*p%t,g=modular_pow2(y,i,t)*y%t,m=modular_pow2(g,a,t)*g%t,b=modular_pow2(m,u,t)*m%t,w=modular_pow2(b,a,t)*g%t,k=modular_pow2(w,r,t)*d%t,x=modular_pow2(k,s,t)*y%t,I=modular_pow2(x,n,t)*c%t,v=modular_pow2(I,be,t);if(!we.eql(we.sqr(v),e))throw new Error("Cannot find square root");return v}const we=Field(ye,void 0,void 0,{sqrt:sqrtMod}),ke=function createCurve(e,t){const create=t=>weierstrass({...e,...getHash(t)});return Object.freeze({...create(t),create})}({a:BigInt(0),b:BigInt(7),Fp:we,n:ge,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=ge,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-me*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=r,s=BigInt("0x100000000000000000000000000000000"),a=divNearest(i*e,t),u=divNearest(-n*e,t);let c=modular_mod(e-a*r-u*o,t),d=modular_mod(-a*n-u*i,t);const l=c>s,f=d>s;if(l&&(c=t-c),f&&(d=t-d),c>s||d>s)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:l,k1:c,k2neg:f,k2:d}}}},ue);BigInt(0);ke.ProjectivePoint;H.utils.randomPrivateKey;const generateKeypair=()=>{const e=H.utils.randomPrivateKey(),t=xe(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),{publicKey:t,secretKey:r}},xe=H.getPublicKey;function isOnCurve(e){try{return H.ExtendedPoint.fromHex(e),!0}catch{return!1}}const sign=(e,t)=>H.sign(e,t.slice(0,32)),Ie=H.verify,toBuffer=e=>o.Buffer.isBuffer(e)?e:e instanceof Uint8Array?o.Buffer.from(e.buffer,e.byteOffset,e.byteLength):o.Buffer.from(e);class Struct{constructor(e){Object.assign(this,e)}encode(){return o.Buffer.from((0,Q.serialize)(ve,this))}static decode(e){return(0,Q.deserialize)(ve,this,e)}static decodeUnchecked(e){return(0,Q.deserializeUnchecked)(ve,this,e)}}const ve=new Map;var Se;let Be;const Ee=32;let Pe=1;Be=Symbol.toStringTag;class PublicKey extends Struct{constructor(e){if(super({}),this._bn=void 0,function isPublicKeyData(e){return void 0!==e._bn}(e))this._bn=e._bn;else{if("string"==typeof e){const t=J().decode(e);if(t.length!=Ee)throw new Error("Invalid public key input");this._bn=new(G())(t)}else this._bn=new(G())(e);if(this._bn.byteLength()>Ee)throw new Error("Invalid public key input")}}static unique(){const e=new PublicKey(Pe);return Pe+=1,new PublicKey(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return J().encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(o.Buffer);if(e.length===Ee)return e;const t=o.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Be](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,r){const n=o.Buffer.concat([e.toBuffer(),o.Buffer.from(t),r.toBuffer()]),i=(0,X.s)(n);return new PublicKey(i)}static createProgramAddressSync(e,t){let r=o.Buffer.alloc(0);e.forEach((function(e){if(e.length>32)throw new TypeError("Max seed length exceeded");r=o.Buffer.concat([r,toBuffer(e)])})),r=o.Buffer.concat([r,t.toBuffer(),o.Buffer.from("ProgramDerivedAddress")]);const n=(0,X.s)(r);if(isOnCurve(n))throw new Error("Invalid seeds, address must fall off the curve");return new PublicKey(n)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let r,n=255;for(;0!=n;){try{const i=e.concat(o.Buffer.from([n]));r=this.createProgramAddressSync(i,t)}catch(e){if(e instanceof TypeError)throw e;n--;continue}return[r,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){return isOnCurve(new PublicKey(e).toBytes())}}Se=PublicKey,PublicKey.default=new Se("11111111111111111111111111111111"),ve.set(PublicKey,{kind:"struct",fields:[["_bn","u256"]]});new PublicKey("BPFLoader1111111111111111111111111111111111");const _e=1232;class TransactionExpiredBlockheightExceededError extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class TransactionExpiredTimeoutError extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(TransactionExpiredTimeoutError.prototype,"name",{value:"TransactionExpiredTimeoutError"});class TransactionExpiredNonceInvalidError extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(TransactionExpiredNonceInvalidError.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class MessageAccountKeys{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const t=new Map;this.keySegments().flat().forEach(((e,r)=>{t.set(e.toBase58(),r)}));const findKeyIndex=e=>{const r=t.get(e.toBase58());if(void 0===r)throw new Error("Encountered an unknown instruction account key during compilation");return r};return e.map((e=>({programIdIndex:findKeyIndex(e.programId),accountKeyIndexes:e.keys.map((e=>findKeyIndex(e.pubkey))),data:e.data})))}}const publicKey=(e="publicKey")=>ee.blob(32,e),signature=(e="signature")=>ee.blob(64,e),rustString=(e="string")=>{const t=ee.struct([ee.u32("length"),ee.u32("lengthPadding"),ee.blob(ee.offset(ee.u32(),-8),"chars")],e),r=t.decode.bind(t),n=t.encode.bind(t),i=t;return i.decode=(e,t)=>r(e,t).chars.toString(),i.encode=(e,t,r)=>{const i={chars:o.Buffer.from(e,"utf8")};return n(i,t,r)},i.alloc=e=>ee.u32().span+ee.u32().span+o.Buffer.from(e,"utf8").length,i};function getAlloc(e,t){const getItemAlloc=e=>{if(e.span>=0)return e.span;if("function"==typeof e.alloc)return e.alloc(t[e.property]);if("count"in e&&"elementLayout"in e){const r=t[e.property];if(Array.isArray(r))return r.length*getItemAlloc(e.elementLayout)}else if("fields"in e)return getAlloc({layout:e},t[e.property]);return 0};let r=0;return e.layout.fields.forEach((e=>{r+=getItemAlloc(e)})),r}function decodeLength(e){let t=0,r=0;for(;;){let n=e.shift();if(t|=(127&n)<<7*r,r+=1,!(128&n))break}return t}function encodeLength(e,t){let r=t;for(;;){let t=127&r;if(r>>=7,0==r){e.push(t);break}t|=128,e.push(t)}}function index_browser_esm_assert(e,t){if(!e)throw new Error(t||"Assertion failed")}class CompiledKeys{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const r=new Map,getOrInsertDefault=e=>{const t=e.toBase58();let n=r.get(t);return void 0===n&&(n={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(t,n)),n},n=getOrInsertDefault(t);n.isSigner=!0,n.isWritable=!0;for(const t of e){getOrInsertDefault(t.programId).isInvoked=!0;for(const e of t.keys){const t=getOrInsertDefault(e.pubkey);t.isSigner||=e.isSigner,t.isWritable||=e.isWritable}}return new CompiledKeys(t,r)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];index_browser_esm_assert(e.length<=256,"Max static account keys length exceeded");const t=e.filter((([,e])=>e.isSigner&&e.isWritable)),r=e.filter((([,e])=>e.isSigner&&!e.isWritable)),n=e.filter((([,e])=>!e.isSigner&&e.isWritable)),o=e.filter((([,e])=>!e.isSigner&&!e.isWritable)),i={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:o.length};{index_browser_esm_assert(t.length>0,"Expected at least one writable signer key");const[e]=t[0];index_browser_esm_assert(e===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}return[i,[...t.map((([e])=>new PublicKey(e))),...r.map((([e])=>new PublicKey(e))),...n.map((([e])=>new PublicKey(e))),...o.map((([e])=>new PublicKey(e)))]]}extractTableLookup(e){const[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,(e=>!e.isSigner&&!e.isInvoked&&e.isWritable)),[n,o]=this.drainKeysFoundInLookupTable(e.state.addresses,(e=>!e.isSigner&&!e.isInvoked&&!e.isWritable));if(0!==t.length||0!==n.length)return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:n},{writable:r,readonly:o}]}drainKeysFoundInLookupTable(e,t){const r=new Array,n=new Array;for(const[o,i]of this.keyMetaMap.entries())if(t(i)){const t=new PublicKey(o),i=e.findIndex((e=>e.equals(t)));i>=0&&(index_browser_esm_assert(i<256,"Max lookup table index exceeded"),r.push(i),n.push(t),this.keyMetaMap.delete(o))}return[r,n]}}const Ae="Reached end of buffer unexpectedly";function guardedShift(e){if(0===e.length)throw new Error(Ae);return e.shift()}function guardedSplice(e,...t){const[r]=t;if(2===t.length?r+(t[1]??0)>e.length:r>=e.length)throw new Error(Ae);return e.splice(...t)}class Message{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map((e=>new PublicKey(e))),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach((e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex])))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map((e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:J().decode(e.data)})))}get addressTableLookups(){return[]}getAccountKeys(){return new MessageAccountKeys(this.staticAccountKeys)}static compile(e){const t=CompiledKeys.compile(e.instructions,e.payerKey),[r,n]=t.getMessageComponents(),o=new MessageAccountKeys(n).compileInstructions(e.instructions).map((e=>({programIdIndex:e.programIdIndex,accounts:e.accountKeyIndexes,data:J().encode(e.data)})));return new Message({header:r,accountKeys:n,recentBlockhash:e.recentBlockhash,instructions:o})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){return e-t<this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts}return e<t-this.header.numReadonlySignedAccounts}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter(((e,t)=>!this.isProgramId(t)))}serialize(){const e=this.accountKeys.length;let t=[];encodeLength(t,e);const r=this.instructions.map((e=>{const{accounts:t,programIdIndex:r}=e,n=Array.from(J().decode(e.data));let i=[];encodeLength(i,t.length);let s=[];return encodeLength(s,n.length),{programIdIndex:r,keyIndicesCount:o.Buffer.from(i),keyIndices:t,dataLength:o.Buffer.from(s),data:n}}));let n=[];encodeLength(n,r.length);let i=o.Buffer.alloc(_e);o.Buffer.from(n).copy(i);let s=n.length;r.forEach((e=>{const t=ee.struct([ee.u8("programIdIndex"),ee.blob(e.keyIndicesCount.length,"keyIndicesCount"),ee.seq(ee.u8("keyIndex"),e.keyIndices.length,"keyIndices"),ee.blob(e.dataLength.length,"dataLength"),ee.seq(ee.u8("userdatum"),e.data.length,"data")]).encode(e,i,s);s+=t})),i=i.slice(0,s);const a=ee.struct([ee.blob(1,"numRequiredSignatures"),ee.blob(1,"numReadonlySignedAccounts"),ee.blob(1,"numReadonlyUnsignedAccounts"),ee.blob(t.length,"keyCount"),ee.seq(publicKey("key"),e,"keys"),publicKey("recentBlockhash")]),u={numRequiredSignatures:o.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:o.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:o.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:o.Buffer.from(t),keys:this.accountKeys.map((e=>toBuffer(e.toBytes()))),recentBlockhash:J().decode(this.recentBlockhash)};let c=o.Buffer.alloc(2048);const d=a.encode(u,c);return i.copy(c,d),c.slice(0,d+i.length)}static from(e){let t=[...e];const r=guardedShift(t);if(r!==(127&r))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const n=guardedShift(t),i=guardedShift(t),s=decodeLength(t);let a=[];for(let e=0;e<s;e++){const e=guardedSplice(t,0,Ee);a.push(new PublicKey(o.Buffer.from(e)))}const u=guardedSplice(t,0,Ee),c=decodeLength(t);let d=[];for(let e=0;e<c;e++){const e=guardedShift(t),r=guardedSplice(t,0,decodeLength(t)),n=guardedSplice(t,0,decodeLength(t)),i=J().encode(o.Buffer.from(n));d.push({programIdIndex:e,accounts:r,data:i})}const l={header:{numRequiredSignatures:r,numReadonlySignedAccounts:n,numReadonlyUnsignedAccounts:i},recentBlockhash:J().encode(o.Buffer.from(u)),accountKeys:a,instructions:d};return new Message(l)}}class MessageV0{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new MessageAccountKeys(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(e>=r){return e-r<this.addressTableLookups.reduce(((e,t)=>e+t.writableIndexes.length),0)}if(e>=this.header.numRequiredSignatures){return e-t<r-t-this.header.numReadonlyUnsignedAccounts}return e<t-this.header.numReadonlySignedAccounts}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const r of this.addressTableLookups){const n=e.find((e=>e.key.equals(r.accountKey)));if(!n)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const e of r.writableIndexes){if(!(e<n.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${r.accountKey.toBase58()}`);t.writable.push(n.state.addresses[e])}for(const e of r.readonlyIndexes){if(!(e<n.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${r.accountKey.toBase58()}`);t.readonly.push(n.state.addresses[e])}}return t}static compile(e){const t=CompiledKeys.compile(e.instructions,e.payerKey),r=new Array,n={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(const e of o){const o=t.extractTableLookup(e);if(void 0!==o){const[e,{writable:t,readonly:i}]=o;r.push(e),n.writable.push(...t),n.readonly.push(...i)}}const[i,s]=t.getMessageComponents(),a=new MessageAccountKeys(s,n).compileInstructions(e.instructions);return new MessageV0({header:i,staticAccountKeys:s,recentBlockhash:e.recentBlockhash,compiledInstructions:a,addressTableLookups:r})}serialize(){const e=Array();encodeLength(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),r=Array();encodeLength(r,this.compiledInstructions.length);const n=this.serializeAddressTableLookups(),o=Array();encodeLength(o,this.addressTableLookups.length);const i=ee.struct([ee.u8("prefix"),ee.struct([ee.u8("numRequiredSignatures"),ee.u8("numReadonlySignedAccounts"),ee.u8("numReadonlyUnsignedAccounts")],"header"),ee.blob(e.length,"staticAccountKeysLength"),ee.seq(publicKey(),this.staticAccountKeys.length,"staticAccountKeys"),publicKey("recentBlockhash"),ee.blob(r.length,"instructionsLength"),ee.blob(t.length,"serializedInstructions"),ee.blob(o.length,"addressTableLookupsLength"),ee.blob(n.length,"serializedAddressTableLookups")]),s=new Uint8Array(_e),a=i.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map((e=>e.toBytes())),recentBlockhash:J().decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:n},s);return s.slice(0,a)}serializeInstructions(){let e=0;const t=new Uint8Array(_e);for(const r of this.compiledInstructions){const n=Array();encodeLength(n,r.accountKeyIndexes.length);const o=Array();encodeLength(o,r.data.length);e+=ee.struct([ee.u8("programIdIndex"),ee.blob(n.length,"encodedAccountKeyIndexesLength"),ee.seq(ee.u8(),r.accountKeyIndexes.length,"accountKeyIndexes"),ee.blob(o.length,"encodedDataLength"),ee.blob(r.data.length,"data")]).encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(n),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:r.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(_e);for(const r of this.addressTableLookups){const n=Array();encodeLength(n,r.writableIndexes.length);const o=Array();encodeLength(o,r.readonlyIndexes.length);e+=ee.struct([publicKey("accountKey"),ee.blob(n.length,"encodedWritableIndexesLength"),ee.seq(ee.u8(),r.writableIndexes.length,"writableIndexes"),ee.blob(o.length,"encodedReadonlyIndexesLength"),ee.seq(ee.u8(),r.readonlyIndexes.length,"readonlyIndexes")]).encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(n),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:r.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const r=guardedShift(t),n=127&r;index_browser_esm_assert(r!==n,"Expected versioned message but received legacy message");index_browser_esm_assert(0===n,`Expected versioned message with version 0 but found version ${n}`);const o={numRequiredSignatures:guardedShift(t),numReadonlySignedAccounts:guardedShift(t),numReadonlyUnsignedAccounts:guardedShift(t)},i=[],s=decodeLength(t);for(let e=0;e<s;e++)i.push(new PublicKey(guardedSplice(t,0,Ee)));const a=J().encode(guardedSplice(t,0,Ee)),u=decodeLength(t),c=[];for(let e=0;e<u;e++){const e=guardedShift(t),r=guardedSplice(t,0,decodeLength(t)),n=decodeLength(t),o=new Uint8Array(guardedSplice(t,0,n));c.push({programIdIndex:e,accountKeyIndexes:r,data:o})}const d=decodeLength(t),l=[];for(let e=0;e<d;e++){const e=new PublicKey(guardedSplice(t,0,Ee)),r=guardedSplice(t,0,decodeLength(t)),n=guardedSplice(t,0,decodeLength(t));l.push({accountKey:e,writableIndexes:r,readonlyIndexes:n})}return new MessageV0({header:o,staticAccountKeys:i,recentBlockhash:a,compiledInstructions:c,addressTableLookups:l})}}const Le={deserializeMessageVersion(e){const t=e[0],r=127&t;return r===t?"legacy":r},deserialize:e=>{const t=Le.deserializeMessageVersion(e);if("legacy"===t)return Message.from(e);if(0===t)return MessageV0.deserialize(e);throw new Error(`Transaction message version ${t} deserialization is not supported`)}};const Te=o.Buffer.alloc(64).fill(0);class TransactionInstruction{constructor(e){this.keys=void 0,this.programId=void 0,this.data=o.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map((({pubkey:e,isSigner:t,isWritable:r})=>({pubkey:e.toJSON(),isSigner:t,isWritable:r}))),programId:this.programId.toJSON(),data:[...this.data]}}}class Transaction{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:r}=e;this.minNonceContextSlot=t,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:r}=e;this.recentBlockhash=t,this.lastValidBlockHeight=r}else{const{recentBlockhash:t,nonceInfo:r}=e;r&&(this.nonceInfo=r),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map((e=>e.toJSON())),signers:this.signatures.map((({publicKey:e})=>e.toJSON()))}}add(...e){if(0===e.length)throw new Error("No instructions");return e.forEach((e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new TransactionInstruction(e))})),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t,r;if(this.nonceInfo?(e=this.nonceInfo.nonce,t=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");if(t.length<1&&console.warn("No instructions provided"),this.feePayer)r=this.feePayer;else{if(!(this.signatures.length>0&&this.signatures[0].publicKey))throw new Error("Transaction fee payer required");r=this.signatures[0].publicKey}for(let e=0;e<t.length;e++)if(void 0===t[e].programId)throw new Error(`Transaction instruction index ${e} has undefined program id`);const n=[],o=[];t.forEach((e=>{e.keys.forEach((e=>{o.push({...e})}));const t=e.programId.toString();n.includes(t)||n.push(t)})),n.forEach((e=>{o.push({pubkey:new PublicKey(e),isSigner:!1,isWritable:!1})}));const i=[];o.forEach((e=>{const t=e.pubkey.toString(),r=i.findIndex((e=>e.pubkey.toString()===t));r>-1?(i[r].isWritable=i[r].isWritable||e.isWritable,i[r].isSigner=i[r].isSigner||e.isSigner):i.push(e)})),i.sort((function(e,t){if(e.isSigner!==t.isSigner)return e.isSigner?-1:1;if(e.isWritable!==t.isWritable)return e.isWritable?-1:1;return e.pubkey.toBase58().localeCompare(t.pubkey.toBase58(),"en",{localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"})}));const s=i.findIndex((e=>e.pubkey.equals(r)));if(s>-1){const[e]=i.splice(s,1);e.isSigner=!0,e.isWritable=!0,i.unshift(e)}else i.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const e of this.signatures){const t=i.findIndex((t=>t.pubkey.equals(e.publicKey)));if(!(t>-1))throw new Error(`unknown signer: ${e.publicKey.toString()}`);i[t].isSigner||(i[t].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))}let a=0,u=0,c=0;const d=[],l=[];i.forEach((({pubkey:e,isSigner:t,isWritable:r})=>{t?(d.push(e.toString()),a+=1,r||(u+=1)):(l.push(e.toString()),r||(c+=1))}));const f=d.concat(l),p=t.map((e=>{const{data:t,programId:r}=e;return{programIdIndex:f.indexOf(r.toString()),accounts:e.keys.map((e=>f.indexOf(e.pubkey.toString()))),data:J().encode(t)}}));return p.forEach((e=>{index_browser_esm_assert(e.programIdIndex>=0),e.accounts.forEach((e=>index_browser_esm_assert(e>=0)))})),new Message({header:{numRequiredSignatures:a,numReadonlySignedAccounts:u,numReadonlyUnsignedAccounts:c},accountKeys:f,recentBlockhash:e,instructions:p})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);if(this.signatures.length===t.length){if(this.signatures.every(((e,r)=>t[r].equals(e.publicKey))))return e}return this.signatures=t.map((e=>({signature:null,publicKey:e}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(0===e.length)throw new Error("No signers");const t=new Set;this.signatures=e.filter((e=>{const r=e.toString();return!t.has(r)&&(t.add(r),!0)})).map((e=>({signature:null,publicKey:e})))}sign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,r=[];for(const n of e){const e=n.publicKey.toString();t.has(e)||(t.add(e),r.push(n))}this.signatures=r.map((e=>({signature:null,publicKey:e.publicKey})));const n=this._compile();this._partialSign(n,...r)}partialSign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,r=[];for(const n of e){const e=n.publicKey.toString();t.has(e)||(t.add(e),r.push(n))}const n=this._compile();this._partialSign(n,...r)}_partialSign(e,...t){const r=e.serialize();t.forEach((e=>{const t=sign(r,e.secretKey);this._addSignature(e.publicKey,toBuffer(t))}))}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){index_browser_esm_assert(64===t.length);const r=this.signatures.findIndex((t=>e.equals(t.publicKey)));if(r<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[r].signature=o.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const r={};for(const{signature:n,publicKey:o}of this.signatures)null===n?t&&(r.missing||=[]).push(o):Ie(n,e,o.toBytes())||(r.invalid||=[]).push(o);return r.invalid||r.missing?r:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),n=this.serializeMessage();if(r){const e=this._getMessageSignednessErrors(n,t);if(e){let t="Signature verification failed.";throw e.invalid&&(t+=`\nInvalid signature for public key${1===e.invalid.length?"":"(s)"} [\`${e.invalid.map((e=>e.toBase58())).join("`, `")}\`].`),e.missing&&(t+=`\nMissing signature for public key${1===e.missing.length?"":"(s)"} [\`${e.missing.map((e=>e.toBase58())).join("`, `")}\`].`),new Error(t)}}return this._serialize(n)}_serialize(e){const{signatures:t}=this,r=[];encodeLength(r,t.length);const n=r.length+64*t.length+e.length,i=o.Buffer.alloc(n);return index_browser_esm_assert(t.length<256),o.Buffer.from(r).copy(i,0),t.forEach((({signature:e},t)=>{null!==e&&(index_browser_esm_assert(64===e.length,"signature has invalid length"),o.Buffer.from(e).copy(i,r.length+64*t))})),e.copy(i,r.length+64*t.length),index_browser_esm_assert(i.length<=_e,`Transaction too large: ${i.length} > ${_e}`),i}get keys(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].keys.map((e=>e.pubkey))}get programId(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].programId}get data(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].data}static from(e){let t=[...e];const r=decodeLength(t);let n=[];for(let e=0;e<r;e++){const e=guardedSplice(t,0,64);n.push(J().encode(o.Buffer.from(e)))}return Transaction.populate(Message.from(t),n)}static populate(e,t=[]){const r=new Transaction;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach(((t,n)=>{const o={signature:t==J().encode(Te)?null:J().decode(t),publicKey:e.accountKeys[n]};r.signatures.push(o)})),e.instructions.forEach((t=>{const n=t.accounts.map((t=>{const n=e.accountKeys[t];return{pubkey:n,isSigner:r.signatures.some((e=>e.publicKey.toString()===n.toString()))||e.isAccountSigner(t),isWritable:e.isAccountWritable(t)}}));r.instructions.push(new TransactionInstruction({keys:n,programId:e.accountKeys[t.programIdIndex],data:J().decode(t.data)}))})),r._message=e,r._json=r.toJSON(),r}}class TransactionMessage{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:r,compiledInstructions:n,recentBlockhash:o}=e,{numRequiredSignatures:i,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:a}=r,u=i-s;index_browser_esm_assert(u>0,"Message header is invalid");const c=e.staticAccountKeys.length-i-a;index_browser_esm_assert(c>=0,"Message header is invalid");const d=e.getAccountKeys(t),l=d.get(0);if(void 0===l)throw new Error("Failed to decompile message because no account keys were found");const f=[];for(const e of n){const t=[];for(const n of e.accountKeyIndexes){const e=d.get(n);if(void 0===e)throw new Error(`Failed to find key for account key index ${n}`);let o;o=n<i?n<u:n<d.staticAccountKeys.length?n-i<c:n-d.staticAccountKeys.length<d.accountKeysFromLookups.writable.length,t.push({pubkey:e,isSigner:n<r.numRequiredSignatures,isWritable:o})}const n=d.get(e.programIdIndex);if(void 0===n)throw new Error(`Failed to find program id for program id index ${e.programIdIndex}`);f.push(new TransactionInstruction({programId:n,data:toBuffer(e.data),keys:t}))}return new TransactionMessage({payerKey:l,instructions:f,recentBlockhash:o})}compileToLegacyMessage(){return Message.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return MessageV0.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class VersionedTransaction{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,void 0!==t)index_browser_esm_assert(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const t=[];for(let r=0;r<e.header.numRequiredSignatures;r++)t.push(new Uint8Array(64));this.signatures=t}this.message=e}serialize(){const e=this.message.serialize(),t=Array();encodeLength(t,this.signatures.length);const r=ee.struct([ee.blob(t.length,"encodedSignaturesLength"),ee.seq(signature(),this.signatures.length,"signatures"),ee.blob(e.length,"serializedMessage")]),n=new Uint8Array(2048),o=r.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},n);return n.slice(0,o)}static deserialize(e){let t=[...e];const r=[],n=decodeLength(t);for(let e=0;e<n;e++)r.push(new Uint8Array(guardedSplice(t,0,64)));const o=Le.deserialize(new Uint8Array(t));return new VersionedTransaction(o,r)}sign(e){const t=this.message.serialize(),r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const n of e){const e=r.findIndex((e=>e.equals(n.publicKey)));index_browser_esm_assert(e>=0,`Cannot sign with non signer key ${n.publicKey.toBase58()}`),this.signatures[e]=sign(t,n.secretKey)}}addSignature(e,t){index_browser_esm_assert(64===t.byteLength,"Signature must be 64 bytes long");const r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex((t=>t.equals(e)));index_browser_esm_assert(r>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[r]=t}}const Oe=new PublicKey("SysvarC1ock11111111111111111111111111111111"),Ne=(new PublicKey("SysvarEpochSchedu1e111111111111111111111111"),new PublicKey("Sysvar1nstructions1111111111111111111111111")),We=new PublicKey("SysvarRecentB1ockHashes11111111111111111111"),Ke=new PublicKey("SysvarRent111111111111111111111111111111111"),Re=(new PublicKey("SysvarRewards111111111111111111111111111111"),new PublicKey("SysvarS1otHashes111111111111111111111111111"),new PublicKey("SysvarS1otHistory11111111111111111111111111"),new PublicKey("SysvarStakeHistory1111111111111111111111111"));async function sendAndConfirmTransaction(e,t,r,n){const o=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},i=await e.sendTransaction(t,r,o);let s;if(null!=t.recentBlockhash&&null!=t.lastValidBlockHeight)s=(await e.confirmTransaction({abortSignal:n?.abortSignal,signature:i,blockhash:t.recentBlockhash,lastValidBlockHeight:t.lastValidBlockHeight},n&&n.commitment)).value;else if(null!=t.minNonceContextSlot&&null!=t.nonceInfo){const{nonceInstruction:r}=t.nonceInfo,o=r.keys[0].pubkey;s=(await e.confirmTransaction({abortSignal:n?.abortSignal,minContextSlot:t.minNonceContextSlot,nonceAccountPubkey:o,nonceValue:t.nonceInfo.nonce,signature:i},n&&n.commitment)).value}else null!=n?.abortSignal&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),s=(await e.confirmTransaction(i,n&&n.commitment)).value;if(s.err)throw new Error(`Transaction ${i} failed (${JSON.stringify(s)})`);return i}function sleep(e){return new Promise((t=>setTimeout(t,e)))}function encodeData(e,t){const r=e.layout.span>=0?e.layout.span:getAlloc(e,t),n=o.Buffer.alloc(r),i=Object.assign({instruction:e.index},t);return e.layout.encode(i,n),n}function decodeData$1(e,t){let r;try{r=e.layout.decode(t)}catch(e){throw new Error("invalid instruction; "+e)}if(r.instruction!==e.index)throw new Error(`invalid instruction; instruction index mismatch ${r.instruction} != ${e.index}`);return r}const je=ee.nu64("lamportsPerSignature"),Ce=ee.struct([ee.u32("version"),ee.u32("state"),publicKey("authorizedPubkey"),publicKey("nonce"),ee.struct([je],"feeCalculator")]),ze=Ce.span;const qe=(Ue=8,e=>{const t=(0,ee.blob)(Ue,e),{encode:r,decode:n}=(e=>({decode:e.decode.bind(e),encode:e.encode.bind(e)}))(t),i=t;return i.decode=(e,t)=>{const r=n(e,t);return(0,te.toBigIntLE)(o.Buffer.from(r))},i.encode=(e,t,n)=>{const o=(0,te.toBufferLE)(e,Ue);return r(o,t,n)},i});var Ue;class SystemInstruction{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=ee.u32("instruction").decode(e.data);let r;for(const[e,n]of Object.entries(De))if(n.index==t){r=e;break}if(!r)throw new Error("Instruction type incorrect; not a SystemInstruction");return r}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t,space:r,programId:n}=decodeData$1(De.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:r,programId:new PublicKey(n)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t}=decodeData$1(De.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t,seed:r,programId:n}=decodeData$1(De.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:r,programId:new PublicKey(n)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:t}=decodeData$1(De.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,space:n,programId:o}=decodeData$1(De.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new PublicKey(t),seed:r,space:n,programId:new PublicKey(o)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:t}=decodeData$1(De.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new PublicKey(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,programId:n}=decodeData$1(De.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new PublicKey(t),seed:r,programId:new PublicKey(n)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:t,seed:r,lamports:n,space:o,programId:i}=decodeData$1(De.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new PublicKey(t),seed:r,lamports:n,space:o,programId:new PublicKey(i)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:t}=decodeData$1(De.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new PublicKey(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),decodeData$1(De.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=decodeData$1(De.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t}=decodeData$1(De.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new PublicKey(t)}}static checkProgramId(e){if(!e.equals(SystemProgram.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const De=Object.freeze({Create:{index:0,layout:ee.struct([ee.u32("instruction"),ee.ns64("lamports"),ee.ns64("space"),publicKey("programId")])},Assign:{index:1,layout:ee.struct([ee.u32("instruction"),publicKey("programId")])},Transfer:{index:2,layout:ee.struct([ee.u32("instruction"),qe("lamports")])},CreateWithSeed:{index:3,layout:ee.struct([ee.u32("instruction"),publicKey("base"),rustString("seed"),ee.ns64("lamports"),ee.ns64("space"),publicKey("programId")])},AdvanceNonceAccount:{index:4,layout:ee.struct([ee.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:ee.struct([ee.u32("instruction"),ee.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:ee.struct([ee.u32("instruction"),publicKey("authorized")])},AuthorizeNonceAccount:{index:7,layout:ee.struct([ee.u32("instruction"),publicKey("authorized")])},Allocate:{index:8,layout:ee.struct([ee.u32("instruction"),ee.ns64("space")])},AllocateWithSeed:{index:9,layout:ee.struct([ee.u32("instruction"),publicKey("base"),rustString("seed"),ee.ns64("space"),publicKey("programId")])},AssignWithSeed:{index:10,layout:ee.struct([ee.u32("instruction"),publicKey("base"),rustString("seed"),publicKey("programId")])},TransferWithSeed:{index:11,layout:ee.struct([ee.u32("instruction"),qe("lamports"),rustString("seed"),publicKey("programId")])},UpgradeNonceAccount:{index:12,layout:ee.struct([ee.u32("instruction")])}});class SystemProgram{constructor(){}static createAccount(e){const t=encodeData(De.Create,{lamports:e.lamports,space:e.space,programId:toBuffer(e.programId.toBuffer())});return new TransactionInstruction({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:t})}static transfer(e){let t,r;if("basePubkey"in e){t=encodeData(De.TransferWithSeed,{lamports:BigInt(e.lamports),seed:e.seed,programId:toBuffer(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{t=encodeData(De.Transfer,{lamports:BigInt(e.lamports)}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new TransactionInstruction({keys:r,programId:this.programId,data:t})}static assign(e){let t,r;if("basePubkey"in e){t=encodeData(De.AssignWithSeed,{base:toBuffer(e.basePubkey.toBuffer()),seed:e.seed,programId:toBuffer(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{t=encodeData(De.Assign,{programId:toBuffer(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new TransactionInstruction({keys:r,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=encodeData(De.CreateWithSeed,{base:toBuffer(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:toBuffer(e.programId.toBuffer())});let r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&r.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new TransactionInstruction({keys:r,programId:this.programId,data:t})}static createNonceAccount(e){const t=new Transaction;"basePubkey"in e&&"seed"in e?t.add(SystemProgram.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:ze,programId:this.programId})):t.add(SystemProgram.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:ze,programId:this.programId}));const r={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(r)),t}static nonceInitialize(e){const t=encodeData(De.InitializeNonceAccount,{authorized:toBuffer(e.authorizedPubkey.toBuffer())}),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1}],programId:this.programId,data:t};return new TransactionInstruction(r)}static nonceAdvance(e){const t=encodeData(De.AdvanceNonceAccount),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t};return new TransactionInstruction(r)}static nonceWithdraw(e){const t=encodeData(De.WithdrawNonceAccount,{lamports:e.lamports});return new TransactionInstruction({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t})}static nonceAuthorize(e){const t=encodeData(De.AuthorizeNonceAccount,{authorized:toBuffer(e.newAuthorizedPubkey.toBuffer())});return new TransactionInstruction({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t})}static allocate(e){let t,r;if("basePubkey"in e){t=encodeData(De.AllocateWithSeed,{base:toBuffer(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:toBuffer(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{t=encodeData(De.Allocate,{space:e.space}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new TransactionInstruction({keys:r,programId:this.programId,data:t})}}SystemProgram.programId=new PublicKey("11111111111111111111111111111111");const Fe=_e-300;class Loader{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/Loader.chunkSize)+1+1)}static async load(e,t,r,n,i){{const o=await e.getMinimumBalanceForRentExemption(i.length),s=await e.getAccountInfo(r.publicKey,"confirmed");let a=null;if(null!==s){if(s.executable)return console.error("Program load failed, account is already executable"),!1;s.data.length!==i.length&&(a=a||new Transaction,a.add(SystemProgram.allocate({accountPubkey:r.publicKey,space:i.length}))),s.owner.equals(n)||(a=a||new Transaction,a.add(SystemProgram.assign({accountPubkey:r.publicKey,programId:n}))),s.lamports<o&&(a=a||new Transaction,a.add(SystemProgram.transfer({fromPubkey:t.publicKey,toPubkey:r.publicKey,lamports:o-s.lamports})))}else a=(new Transaction).add(SystemProgram.createAccount({fromPubkey:t.publicKey,newAccountPubkey:r.publicKey,lamports:o>0?o:1,space:i.length,programId:n}));null!==a&&await sendAndConfirmTransaction(e,a,[t,r],{commitment:"confirmed"})}const s=ee.struct([ee.u32("instruction"),ee.u32("offset"),ee.u32("bytesLength"),ee.u32("bytesLengthPadding"),ee.seq(ee.u8("byte"),ee.offset(ee.u32(),-8),"bytes")]),a=Loader.chunkSize;let u=0,c=i,d=[];for(;c.length>0;){const i=c.slice(0,a),l=o.Buffer.alloc(a+16);s.encode({instruction:0,offset:u,bytes:i,bytesLength:0,bytesLengthPadding:0},l);const f=(new Transaction).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:n,data:l});if(d.push(sendAndConfirmTransaction(e,f,[t,r],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")){const e=4;await sleep(1e3/e)}u+=a,c=c.slice(a)}await Promise.all(d);{const i=ee.struct([ee.u32("instruction")]),s=o.Buffer.alloc(i.span);i.encode({instruction:1},s);const a=(new Transaction).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1}],programId:n,data:s}),u="processed",c=await e.sendTransaction(a,[t,r],{preflightCommitment:u}),{context:d,value:l}=await e.confirmTransaction({signature:c,lastValidBlockHeight:a.lastValidBlockHeight,blockhash:a.recentBlockhash},u);if(l.err)throw new Error(`Transaction ${c} failed (${JSON.stringify(l)})`);for(;;){try{if(await e.getSlot({commitment:u})>d.slot)break}catch{}await new Promise((e=>setTimeout(e,Math.round(200))))}}return!0}}Loader.chunkSize=Fe;new PublicKey("BPFLoader2111111111111111111111111111111111");Object.prototype.toString,Object.keys;Error;Error;globalThis.fetch;ne.A;class AddressLookupTableAccount{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=function decodeData(e,t){let r;try{r=e.layout.decode(t)}catch(e){throw new Error("invalid instruction; "+e)}if(r.typeIndex!==e.index)throw new Error(`invalid account data; account type mismatch ${r.typeIndex} != ${e.index}`);return r}(Ye,e),r=e.length-56;index_browser_esm_assert(r>=0,"lookup table is invalid"),index_browser_esm_assert(r%32==0,"lookup table is invalid");const n=r/32,{addresses:o}=ee.struct([ee.seq(publicKey(),n,"addresses")]).decode(e.slice(56));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:0!==t.authority.length?new PublicKey(t.authority[0]):void 0,addresses:o.map((e=>new PublicKey(e)))}}}const Ye={index:1,layout:ee.struct([ee.u32("typeIndex"),qe("deactivationSlot"),ee.nu64("lastExtendedSlot"),ee.u8("lastExtendedStartIndex"),ee.u8(),ee.seq(publicKey(),ee.offset(ee.u8(),-1),"authority")])};const Me=(0,re.au)((0,re.KJ)(PublicKey),(0,re.Yj)(),(e=>new PublicKey(e))),He=(0,re.PV)([(0,re.Yj)(),(0,re.eu)("base64")]),Ve=(0,re.au)((0,re.KJ)(o.Buffer),He,(e=>o.Buffer.from(e[0],"base64")));function createRpcResult(e){return(0,re.KC)([(0,re.NW)({jsonrpc:(0,re.eu)("2.0"),id:(0,re.Yj)(),result:e}),(0,re.NW)({jsonrpc:(0,re.eu)("2.0"),id:(0,re.Yj)(),error:(0,re.NW)({code:(0,re.L5)(),message:(0,re.Yj)(),data:(0,re.lq)((0,re.bz)())})})])}const $e=createRpcResult((0,re.L5)());function jsonRpcResult(e){return(0,re.au)(createRpcResult(e),$e,(t=>"error"in t?t:{...t,result:(0,re.vt)(t.result,e)}))}function jsonRpcResultAndContext(e){return jsonRpcResult((0,re.NW)({context:(0,re.NW)({slot:(0,re.ai)()}),value:e}))}function notificationResultAndContext(e){return(0,re.NW)({context:(0,re.NW)({slot:(0,re.ai)()}),value:e})}const Ge=(0,re.NW)({foundation:(0,re.ai)(),foundationTerm:(0,re.ai)(),initial:(0,re.ai)(),taper:(0,re.ai)(),terminal:(0,re.ai)()}),Ze=(jsonRpcResult((0,re.YO)((0,re.me)((0,re.NW)({epoch:(0,re.ai)(),effectiveSlot:(0,re.ai)(),amount:(0,re.ai)(),postBalance:(0,re.ai)(),commission:(0,re.lq)((0,re.me)((0,re.ai)()))})))),(0,re.YO)((0,re.NW)({slot:(0,re.ai)(),prioritizationFee:(0,re.ai)()}))),Je=(0,re.NW)({total:(0,re.ai)(),validator:(0,re.ai)(),foundation:(0,re.ai)(),epoch:(0,re.ai)()}),Xe=(0,re.NW)({epoch:(0,re.ai)(),slotIndex:(0,re.ai)(),slotsInEpoch:(0,re.ai)(),absoluteSlot:(0,re.ai)(),blockHeight:(0,re.lq)((0,re.ai)()),transactionCount:(0,re.lq)((0,re.ai)())}),Qe=(0,re.NW)({slotsPerEpoch:(0,re.ai)(),leaderScheduleSlotOffset:(0,re.ai)(),warmup:(0,re.zM)(),firstNormalEpoch:(0,re.ai)(),firstNormalSlot:(0,re.ai)()}),et=(0,re.g1)((0,re.Yj)(),(0,re.YO)((0,re.ai)())),tt=(0,re.me)((0,re.KC)([(0,re.NW)({}),(0,re.Yj)()])),rt=(0,re.NW)({err:tt}),nt=(0,re.eu)("receivedSignature");(0,re.NW)({"solana-core":(0,re.Yj)(),"feature-set":(0,re.lq)((0,re.ai)())}),jsonRpcResultAndContext((0,re.NW)({err:(0,re.me)((0,re.KC)([(0,re.NW)({}),(0,re.Yj)()])),logs:(0,re.me)((0,re.YO)((0,re.Yj)())),accounts:(0,re.lq)((0,re.me)((0,re.YO)((0,re.me)((0,re.NW)({executable:(0,re.zM)(),owner:(0,re.Yj)(),lamports:(0,re.ai)(),data:(0,re.YO)((0,re.Yj)()),rentEpoch:(0,re.lq)((0,re.ai)())}))))),unitsConsumed:(0,re.lq)((0,re.ai)()),returnData:(0,re.lq)((0,re.me)((0,re.NW)({programId:(0,re.Yj)(),data:(0,re.PV)([(0,re.Yj)(),(0,re.eu)("base64")])})))})),jsonRpcResultAndContext((0,re.NW)({byIdentity:(0,re.g1)((0,re.Yj)(),(0,re.YO)((0,re.ai)())),range:(0,re.NW)({firstSlot:(0,re.ai)(),lastSlot:(0,re.ai)()})}));jsonRpcResult(Ge),jsonRpcResult(Je),jsonRpcResult(Ze),jsonRpcResult(Xe),jsonRpcResult(Qe),jsonRpcResult(et),jsonRpcResult((0,re.ai)()),jsonRpcResultAndContext((0,re.NW)({total:(0,re.ai)(),circulating:(0,re.ai)(),nonCirculating:(0,re.ai)(),nonCirculatingAccounts:(0,re.YO)(Me)}));const ot=(0,re.NW)({amount:(0,re.Yj)(),uiAmount:(0,re.me)((0,re.ai)()),decimals:(0,re.ai)(),uiAmountString:(0,re.lq)((0,re.Yj)())}),it=(jsonRpcResultAndContext((0,re.YO)((0,re.NW)({address:Me,amount:(0,re.Yj)(),uiAmount:(0,re.me)((0,re.ai)()),decimals:(0,re.ai)(),uiAmountString:(0,re.lq)((0,re.Yj)())}))),jsonRpcResultAndContext((0,re.YO)((0,re.NW)({pubkey:Me,account:(0,re.NW)({executable:(0,re.zM)(),owner:Me,lamports:(0,re.ai)(),data:Ve,rentEpoch:(0,re.ai)()})}))),(0,re.NW)({program:(0,re.Yj)(),parsed:(0,re.L5)(),space:(0,re.ai)()})),st=(jsonRpcResultAndContext((0,re.YO)((0,re.NW)({pubkey:Me,account:(0,re.NW)({executable:(0,re.zM)(),owner:Me,lamports:(0,re.ai)(),data:it,rentEpoch:(0,re.ai)()})}))),jsonRpcResultAndContext((0,re.YO)((0,re.NW)({lamports:(0,re.ai)(),address:Me}))),(0,re.NW)({executable:(0,re.zM)(),owner:Me,lamports:(0,re.ai)(),data:Ve,rentEpoch:(0,re.ai)()})),at=((0,re.NW)({pubkey:Me,account:st}),(0,re.au)((0,re.KC)([(0,re.KJ)(o.Buffer),it]),(0,re.KC)([He,it]),(e=>Array.isArray(e)?(0,re.vt)(e,Ve):e))),ut=(0,re.NW)({executable:(0,re.zM)(),owner:Me,lamports:(0,re.ai)(),data:at,rentEpoch:(0,re.ai)()}),ct=((0,re.NW)({pubkey:Me,account:ut}),(0,re.NW)({state:(0,re.KC)([(0,re.eu)("active"),(0,re.eu)("inactive"),(0,re.eu)("activating"),(0,re.eu)("deactivating")]),active:(0,re.ai)(),inactive:(0,re.ai)()}),jsonRpcResult((0,re.YO)((0,re.NW)({signature:(0,re.Yj)(),slot:(0,re.ai)(),err:tt,memo:(0,re.me)((0,re.Yj)()),blockTime:(0,re.lq)((0,re.me)((0,re.ai)()))}))),jsonRpcResult((0,re.YO)((0,re.NW)({signature:(0,re.Yj)(),slot:(0,re.ai)(),err:tt,memo:(0,re.me)((0,re.Yj)()),blockTime:(0,re.lq)((0,re.me)((0,re.ai)()))}))),(0,re.NW)({subscription:(0,re.ai)(),result:notificationResultAndContext(st)}),(0,re.NW)({pubkey:Me,account:st})),dt=((0,re.NW)({subscription:(0,re.ai)(),result:notificationResultAndContext(ct)}),(0,re.NW)({parent:(0,re.ai)(),slot:(0,re.ai)(),root:(0,re.ai)()})),lt=((0,re.NW)({subscription:(0,re.ai)(),result:dt}),(0,re.KC)([(0,re.NW)({type:(0,re.KC)([(0,re.eu)("firstShredReceived"),(0,re.eu)("completed"),(0,re.eu)("optimisticConfirmation"),(0,re.eu)("root")]),slot:(0,re.ai)(),timestamp:(0,re.ai)()}),(0,re.NW)({type:(0,re.eu)("createdBank"),parent:(0,re.ai)(),slot:(0,re.ai)(),timestamp:(0,re.ai)()}),(0,re.NW)({type:(0,re.eu)("frozen"),slot:(0,re.ai)(),timestamp:(0,re.ai)(),stats:(0,re.NW)({numTransactionEntries:(0,re.ai)(),numSuccessfulTransactions:(0,re.ai)(),numFailedTransactions:(0,re.ai)(),maxTransactionsPerEntry:(0,re.ai)()})}),(0,re.NW)({type:(0,re.eu)("dead"),slot:(0,re.ai)(),timestamp:(0,re.ai)(),err:(0,re.Yj)()})])),ht=((0,re.NW)({subscription:(0,re.ai)(),result:lt}),(0,re.NW)({subscription:(0,re.ai)(),result:notificationResultAndContext((0,re.KC)([rt,nt]))}),(0,re.NW)({subscription:(0,re.ai)(),result:(0,re.ai)()}),(0,re.NW)({pubkey:(0,re.Yj)(),gossip:(0,re.me)((0,re.Yj)()),tpu:(0,re.me)((0,re.Yj)()),rpc:(0,re.me)((0,re.Yj)()),version:(0,re.me)((0,re.Yj)())}),(0,re.NW)({votePubkey:(0,re.Yj)(),nodePubkey:(0,re.Yj)(),activatedStake:(0,re.ai)(),epochVoteAccount:(0,re.zM)(),epochCredits:(0,re.YO)((0,re.PV)([(0,re.ai)(),(0,re.ai)(),(0,re.ai)()])),commission:(0,re.ai)(),lastVote:(0,re.ai)(),rootSlot:(0,re.me)((0,re.ai)())})),ft=(jsonRpcResult((0,re.NW)({current:(0,re.YO)(ht),delinquent:(0,re.YO)(ht)})),(0,re.KC)([(0,re.eu)("processed"),(0,re.eu)("confirmed"),(0,re.eu)("finalized")])),pt=(0,re.NW)({slot:(0,re.ai)(),confirmations:(0,re.me)((0,re.ai)()),err:tt,confirmationStatus:(0,re.lq)(ft)}),yt=(jsonRpcResultAndContext((0,re.YO)((0,re.me)(pt))),jsonRpcResult((0,re.ai)()),(0,re.NW)({accountKey:Me,writableIndexes:(0,re.YO)((0,re.ai)()),readonlyIndexes:(0,re.YO)((0,re.ai)())})),gt=(0,re.NW)({signatures:(0,re.YO)((0,re.Yj)()),message:(0,re.NW)({accountKeys:(0,re.YO)((0,re.Yj)()),header:(0,re.NW)({numRequiredSignatures:(0,re.ai)(),numReadonlySignedAccounts:(0,re.ai)(),numReadonlyUnsignedAccounts:(0,re.ai)()}),instructions:(0,re.YO)((0,re.NW)({accounts:(0,re.YO)((0,re.ai)()),data:(0,re.Yj)(),programIdIndex:(0,re.ai)()})),recentBlockhash:(0,re.Yj)(),addressTableLookups:(0,re.lq)((0,re.YO)(yt))})}),mt=(0,re.NW)({pubkey:Me,signer:(0,re.zM)(),writable:(0,re.zM)(),source:(0,re.lq)((0,re.KC)([(0,re.eu)("transaction"),(0,re.eu)("lookupTable")]))}),bt=(0,re.NW)({accountKeys:(0,re.YO)(mt),signatures:(0,re.YO)((0,re.Yj)())}),wt=(0,re.NW)({parsed:(0,re.L5)(),program:(0,re.Yj)(),programId:Me}),kt=(0,re.NW)({accounts:(0,re.YO)(Me),data:(0,re.Yj)(),programId:Me}),xt=(0,re.KC)([kt,wt]),It=(0,re.KC)([(0,re.NW)({parsed:(0,re.L5)(),program:(0,re.Yj)(),programId:(0,re.Yj)()}),(0,re.NW)({accounts:(0,re.YO)((0,re.Yj)()),data:(0,re.Yj)(),programId:(0,re.Yj)()})]),vt=(0,re.au)(xt,It,(e=>"accounts"in e?(0,re.vt)(e,kt):(0,re.vt)(e,wt))),St=(0,re.NW)({signatures:(0,re.YO)((0,re.Yj)()),message:(0,re.NW)({accountKeys:(0,re.YO)(mt),instructions:(0,re.YO)(vt),recentBlockhash:(0,re.Yj)(),addressTableLookups:(0,re.lq)((0,re.me)((0,re.YO)(yt)))})}),Bt=(0,re.NW)({accountIndex:(0,re.ai)(),mint:(0,re.Yj)(),owner:(0,re.lq)((0,re.Yj)()),uiTokenAmount:ot}),Et=(0,re.NW)({writable:(0,re.YO)(Me),readonly:(0,re.YO)(Me)}),Pt=(0,re.NW)({err:tt,fee:(0,re.ai)(),innerInstructions:(0,re.lq)((0,re.me)((0,re.YO)((0,re.NW)({index:(0,re.ai)(),instructions:(0,re.YO)((0,re.NW)({accounts:(0,re.YO)((0,re.ai)()),data:(0,re.Yj)(),programIdIndex:(0,re.ai)()}))})))),preBalances:(0,re.YO)((0,re.ai)()),postBalances:(0,re.YO)((0,re.ai)()),logMessages:(0,re.lq)((0,re.me)((0,re.YO)((0,re.Yj)()))),preTokenBalances:(0,re.lq)((0,re.me)((0,re.YO)(Bt))),postTokenBalances:(0,re.lq)((0,re.me)((0,re.YO)(Bt))),loadedAddresses:(0,re.lq)(Et),computeUnitsConsumed:(0,re.lq)((0,re.ai)())}),_t=(0,re.NW)({err:tt,fee:(0,re.ai)(),innerInstructions:(0,re.lq)((0,re.me)((0,re.YO)((0,re.NW)({index:(0,re.ai)(),instructions:(0,re.YO)(vt)})))),preBalances:(0,re.YO)((0,re.ai)()),postBalances:(0,re.YO)((0,re.ai)()),logMessages:(0,re.lq)((0,re.me)((0,re.YO)((0,re.Yj)()))),preTokenBalances:(0,re.lq)((0,re.me)((0,re.YO)(Bt))),postTokenBalances:(0,re.lq)((0,re.me)((0,re.YO)(Bt))),loadedAddresses:(0,re.lq)(Et),computeUnitsConsumed:(0,re.lq)((0,re.ai)())}),At=(0,re.KC)([(0,re.eu)(0),(0,re.eu)("legacy")]),Lt=(0,re.NW)({pubkey:(0,re.Yj)(),lamports:(0,re.ai)(),postBalance:(0,re.me)((0,re.ai)()),rewardType:(0,re.me)((0,re.Yj)()),commission:(0,re.lq)((0,re.me)((0,re.ai)()))}),Tt=(jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),transactions:(0,re.YO)((0,re.NW)({transaction:gt,meta:(0,re.me)(Pt),version:(0,re.lq)(At)})),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),transactions:(0,re.YO)((0,re.NW)({transaction:bt,meta:(0,re.me)(Pt),version:(0,re.lq)(At)})),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),transactions:(0,re.YO)((0,re.NW)({transaction:St,meta:(0,re.me)(_t),version:(0,re.lq)(At)})),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),transactions:(0,re.YO)((0,re.NW)({transaction:bt,meta:(0,re.me)(_t),version:(0,re.lq)(At)})),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),transactions:(0,re.YO)((0,re.NW)({transaction:gt,meta:(0,re.me)(Pt)})),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),signatures:(0,re.YO)((0,re.Yj)()),blockTime:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({slot:(0,re.ai)(),meta:(0,re.me)(Pt),blockTime:(0,re.lq)((0,re.me)((0,re.ai)())),transaction:gt,version:(0,re.lq)(At)}))),jsonRpcResult((0,re.me)((0,re.NW)({slot:(0,re.ai)(),transaction:St,meta:(0,re.me)(_t),blockTime:(0,re.lq)((0,re.me)((0,re.ai)())),version:(0,re.lq)(At)}))),jsonRpcResultAndContext((0,re.NW)({blockhash:(0,re.Yj)(),feeCalculator:(0,re.NW)({lamportsPerSignature:(0,re.ai)()})})),jsonRpcResultAndContext((0,re.NW)({blockhash:(0,re.Yj)(),lastValidBlockHeight:(0,re.ai)()})),jsonRpcResultAndContext((0,re.zM)()),(0,re.NW)({slot:(0,re.ai)(),numTransactions:(0,re.ai)(),numSlots:(0,re.ai)(),samplePeriodSecs:(0,re.ai)()})),Ot=(jsonRpcResult((0,re.YO)(Tt)),jsonRpcResultAndContext((0,re.me)((0,re.NW)({feeCalculator:(0,re.NW)({lamportsPerSignature:(0,re.ai)()})}))),jsonRpcResult((0,re.Yj)()),jsonRpcResult((0,re.Yj)()),(0,re.NW)({err:tt,logs:(0,re.YO)((0,re.Yj)()),signature:(0,re.Yj)()}));(0,re.NW)({result:notificationResultAndContext(Ot),subscription:(0,re.ai)()});class Keypair{constructor(e){this._keypair=void 0,this._keypair=e??generateKeypair()}static generate(){return new Keypair(generateKeypair())}static fromSecretKey(e,t){if(64!==e.byteLength)throw new Error("bad secret key size");const r=e.slice(32,64);if(!t||!t.skipValidation){const t=e.slice(0,32),n=xe(t);for(let e=0;e<32;e++)if(r[e]!==n[e])throw new Error("provided secretKey is invalid")}return new Keypair({publicKey:r,secretKey:e})}static fromSeed(e){const t=xe(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),new Keypair({publicKey:t,secretKey:r})}get publicKey(){return new PublicKey(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const Nt=Object.freeze({CreateLookupTable:{index:0,layout:ee.struct([ee.u32("instruction"),qe("recentSlot"),ee.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:ee.struct([ee.u32("instruction")])},ExtendLookupTable:{index:2,layout:ee.struct([ee.u32("instruction"),qe(),ee.seq(publicKey(),ee.offset(ee.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:ee.struct([ee.u32("instruction")])},CloseLookupTable:{index:4,layout:ee.struct([ee.u32("instruction")])}});class AddressLookupTableProgram{constructor(){}static createLookupTable(e){const[t,r]=PublicKey.findProgramAddressSync([e.authority.toBuffer(),(0,te.toBufferLE)(BigInt(e.recentSlot),8)],this.programId),n=encodeData(Nt.CreateLookupTable,{recentSlot:BigInt(e.recentSlot),bumpSeed:r}),o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:SystemProgram.programId,isSigner:!1,isWritable:!1}];return[new TransactionInstruction({programId:this.programId,keys:o,data:n}),t]}static freezeLookupTable(e){const t=encodeData(Nt.FreezeLookupTable),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new TransactionInstruction({programId:this.programId,keys:r,data:t})}static extendLookupTable(e){const t=encodeData(Nt.ExtendLookupTable,{addresses:e.addresses.map((e=>e.toBytes()))}),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&r.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:SystemProgram.programId,isSigner:!1,isWritable:!1}),new TransactionInstruction({programId:this.programId,keys:r,data:t})}static deactivateLookupTable(e){const t=encodeData(Nt.DeactivateLookupTable),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new TransactionInstruction({programId:this.programId,keys:r,data:t})}static closeLookupTable(e){const t=encodeData(Nt.CloseLookupTable),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new TransactionInstruction({programId:this.programId,keys:r,data:t})}}AddressLookupTableProgram.programId=new PublicKey("AddressLookupTab1e1111111111111111111111111");class ComputeBudgetInstruction{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=ee.u8("instruction").decode(e.data);let r;for(const[e,n]of Object.entries(Wt))if(n.index==t){r=e;break}if(!r)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return r}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:t,additionalFee:r}=decodeData$1(Wt.RequestUnits,e.data);return{units:t,additionalFee:r}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:t}=decodeData$1(Wt.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:t}=decodeData$1(Wt.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:t}=decodeData$1(Wt.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals(ComputeBudgetProgram.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const Wt=Object.freeze({RequestUnits:{index:0,layout:ee.struct([ee.u8("instruction"),ee.u32("units"),ee.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:ee.struct([ee.u8("instruction"),ee.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:ee.struct([ee.u8("instruction"),ee.u32("units")])},SetComputeUnitPrice:{index:3,layout:ee.struct([ee.u8("instruction"),qe("microLamports")])}});class ComputeBudgetProgram{constructor(){}static requestUnits(e){const t=encodeData(Wt.RequestUnits,e);return new TransactionInstruction({keys:[],programId:this.programId,data:t})}static requestHeapFrame(e){const t=encodeData(Wt.RequestHeapFrame,e);return new TransactionInstruction({keys:[],programId:this.programId,data:t})}static setComputeUnitLimit(e){const t=encodeData(Wt.SetComputeUnitLimit,e);return new TransactionInstruction({keys:[],programId:this.programId,data:t})}static setComputeUnitPrice(e){const t=encodeData(Wt.SetComputeUnitPrice,{microLamports:BigInt(e.microLamports)});return new TransactionInstruction({keys:[],programId:this.programId,data:t})}}ComputeBudgetProgram.programId=new PublicKey("ComputeBudget111111111111111111111111111111");const Kt=ee.struct([ee.u8("numSignatures"),ee.u8("padding"),ee.u16("signatureOffset"),ee.u16("signatureInstructionIndex"),ee.u16("publicKeyOffset"),ee.u16("publicKeyInstructionIndex"),ee.u16("messageDataOffset"),ee.u16("messageDataSize"),ee.u16("messageInstructionIndex")]);class Ed25519Program{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,instructionIndex:i}=e;index_browser_esm_assert(32===t.length,`Public Key must be 32 bytes but received ${t.length} bytes`),index_browser_esm_assert(64===n.length,`Signature must be 64 bytes but received ${n.length} bytes`);const s=Kt.span,a=s+t.length,u=a+n.length,c=o.Buffer.alloc(u+r.length),d=null==i?65535:i;return Kt.encode({numSignatures:1,padding:0,signatureOffset:a,signatureInstructionIndex:d,publicKeyOffset:s,publicKeyInstructionIndex:d,messageDataOffset:u,messageDataSize:r.length,messageInstructionIndex:d},c),c.fill(t,s),c.fill(n,a),c.fill(r,u),new TransactionInstruction({keys:[],programId:Ed25519Program.programId,data:c})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;index_browser_esm_assert(64===t.length,`Private key must be 64 bytes but received ${t.length} bytes`);try{const e=Keypair.fromSecretKey(t),o=e.publicKey.toBytes(),i=sign(r,e.secretKey);return this.createInstructionWithPublicKey({publicKey:o,message:r,signature:i,instructionIndex:n})}catch(e){throw new Error(`Error creating instruction; ${e}`)}}}Ed25519Program.programId=new PublicKey("Ed25519SigVerify111111111111111111111111111");ke.utils.isValidPrivateKey;const Rt=ke.getPublicKey,jt=ee.struct([ee.u8("numSignatures"),ee.u16("signatureOffset"),ee.u8("signatureInstructionIndex"),ee.u16("ethAddressOffset"),ee.u8("ethAddressInstructionIndex"),ee.u16("messageDataOffset"),ee.u16("messageDataSize"),ee.u8("messageInstructionIndex"),ee.blob(20,"ethAddress"),ee.blob(64,"signature"),ee.u8("recoveryId")]);class Secp256k1Program{constructor(){}static publicKeyToEthAddress(e){index_browser_esm_assert(64===e.length,`Public key must be 64 bytes but received ${e.length} bytes`);try{return o.Buffer.from((0,oe.lY)(toBuffer(e))).slice(-20)}catch(e){throw new Error(`Error constructing Ethereum address: ${e}`)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,recoveryId:o,instructionIndex:i}=e;return Secp256k1Program.createInstructionWithEthAddress({ethAddress:Secp256k1Program.publicKeyToEthAddress(t),message:r,signature:n,recoveryId:o,instructionIndex:i})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:r,signature:n,recoveryId:i,instructionIndex:s=0}=e;let a;a="string"==typeof t?t.startsWith("0x")?o.Buffer.from(t.substr(2),"hex"):o.Buffer.from(t,"hex"):t,index_browser_esm_assert(20===a.length,`Address must be 20 bytes but received ${a.length} bytes`);const u=12+a.length,c=u+n.length+1,d=o.Buffer.alloc(jt.span+r.length);return jt.encode({numSignatures:1,signatureOffset:u,signatureInstructionIndex:s,ethAddressOffset:12,ethAddressInstructionIndex:s,messageDataOffset:c,messageDataSize:r.length,messageInstructionIndex:s,signature:toBuffer(n),ethAddress:toBuffer(a),recoveryId:i},d),d.fill(toBuffer(r),jt.span),new TransactionInstruction({keys:[],programId:Secp256k1Program.programId,data:d})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;index_browser_esm_assert(32===t.length,`Private key must be 32 bytes but received ${t.length} bytes`);try{const e=toBuffer(t),i=Rt(e,!1).slice(1),s=o.Buffer.from((0,oe.lY)(toBuffer(r))),[a,u]=((e,t)=>{const r=ke.sign(e,t);return[r.toCompactRawBytes(),r.recovery]})(s,e);return this.createInstructionWithPublicKey({publicKey:i,message:r,signature:a,recoveryId:u,instructionIndex:n})}catch(e){throw new Error(`Error creating instruction; ${e}`)}}}var Ct;Secp256k1Program.programId=new PublicKey("KeccakSecp256k11111111111111111111111111111");const zt=new PublicKey("StakeConfig11111111111111111111111111111111");class Lockup{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}Ct=Lockup,Lockup.default=new Ct(0,0,PublicKey.default);const qt=Object.freeze({Initialize:{index:0,layout:ee.struct([ee.u32("instruction"),((e="authorized")=>ee.struct([publicKey("staker"),publicKey("withdrawer")],e))(),((e="lockup")=>ee.struct([ee.ns64("unixTimestamp"),ee.ns64("epoch"),publicKey("custodian")],e))()])},Authorize:{index:1,layout:ee.struct([ee.u32("instruction"),publicKey("newAuthorized"),ee.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:ee.struct([ee.u32("instruction")])},Split:{index:3,layout:ee.struct([ee.u32("instruction"),ee.ns64("lamports")])},Withdraw:{index:4,layout:ee.struct([ee.u32("instruction"),ee.ns64("lamports")])},Deactivate:{index:5,layout:ee.struct([ee.u32("instruction")])},Merge:{index:7,layout:ee.struct([ee.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:ee.struct([ee.u32("instruction"),publicKey("newAuthorized"),ee.u32("stakeAuthorizationType"),rustString("authoritySeed"),publicKey("authorityOwner")])}});Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class StakeProgram{constructor(){}static initialize(e){const{stakePubkey:t,authorized:r,lockup:n}=e,o=n||Lockup.default,i=encodeData(qt.Initialize,{authorized:{staker:toBuffer(r.staker.toBuffer()),withdrawer:toBuffer(r.withdrawer.toBuffer())},lockup:{unixTimestamp:o.unixTimestamp,epoch:o.epoch,custodian:toBuffer(o.custodian.toBuffer())}}),s={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1}],programId:this.programId,data:i};return new TransactionInstruction(s)}static createAccountWithSeed(e){const t=new Transaction;t.add(SystemProgram.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:o}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:o}))}static createAccount(e){const t=new Transaction;t.add(SystemProgram.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:o}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:o}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:r,votePubkey:n}=e,o=encodeData(qt.Delegate);return(new Transaction).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:Oe,isSigner:!1,isWritable:!1},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:zt,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static authorize(e){const{stakePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,stakeAuthorizationType:o,custodianPubkey:i}=e,s=encodeData(qt.Authorize,{newAuthorized:toBuffer(n.toBuffer()),stakeAuthorizationType:o.index}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Oe,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return i&&a.push({pubkey:i,isSigner:!0,isWritable:!1}),(new Transaction).add({keys:a,programId:this.programId,data:s})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:r,authoritySeed:n,authorityOwner:o,newAuthorizedPubkey:i,stakeAuthorizationType:s,custodianPubkey:a}=e,u=encodeData(qt.AuthorizeWithSeed,{newAuthorized:toBuffer(i.toBuffer()),stakeAuthorizationType:s.index,authoritySeed:n,authorityOwner:toBuffer(o.toBuffer())}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:Oe,isSigner:!1,isWritable:!1}];return a&&c.push({pubkey:a,isSigner:!0,isWritable:!1}),(new Transaction).add({keys:c,programId:this.programId,data:u})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,lamports:o}=e,i=encodeData(qt.Split,{lamports:o});return new TransactionInstruction({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static split(e,t){const r=new Transaction;return r.add(SystemProgram.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),r.add(this.splitInstruction(e))}static splitWithSeed(e,t){const{stakePubkey:r,authorizedPubkey:n,splitStakePubkey:o,basePubkey:i,seed:s,lamports:a}=e,u=new Transaction;return u.add(SystemProgram.allocate({accountPubkey:o,basePubkey:i,seed:s,space:this.space,programId:this.programId})),t&&t>0&&u.add(SystemProgram.transfer({fromPubkey:e.authorizedPubkey,toPubkey:o,lamports:t})),u.add(this.splitInstruction({stakePubkey:r,authorizedPubkey:n,splitStakePubkey:o,lamports:a}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:r,authorizedPubkey:n}=e,o=encodeData(qt.Merge);return(new Transaction).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Oe,isSigner:!1,isWritable:!1},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:r,toPubkey:n,lamports:o,custodianPubkey:i}=e,s=encodeData(qt.Withdraw,{lamports:o}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:Oe,isSigner:!1,isWritable:!1},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return i&&a.push({pubkey:i,isSigner:!0,isWritable:!1}),(new Transaction).add({keys:a,programId:this.programId,data:s})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:r}=e,n=encodeData(qt.Deactivate);return(new Transaction).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Oe,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}}StakeProgram.programId=new PublicKey("Stake11111111111111111111111111111111111111"),StakeProgram.space=200;const Ut=Object.freeze({InitializeAccount:{index:0,layout:ee.struct([ee.u32("instruction"),((e="voteInit")=>ee.struct([publicKey("nodePubkey"),publicKey("authorizedVoter"),publicKey("authorizedWithdrawer"),ee.u8("commission")],e))()])},Authorize:{index:1,layout:ee.struct([ee.u32("instruction"),publicKey("newAuthorized"),ee.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:ee.struct([ee.u32("instruction"),ee.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:ee.struct([ee.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:ee.struct([ee.u32("instruction"),((e="voteAuthorizeWithSeedArgs")=>ee.struct([ee.u32("voteAuthorizationType"),publicKey("currentAuthorityDerivedKeyOwnerPubkey"),rustString("currentAuthorityDerivedKeySeed"),publicKey("newAuthorized")],e))()])}});Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class VoteProgram{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:r,voteInit:n}=e,o=encodeData(Ut.InitializeAccount,{voteInit:{nodePubkey:toBuffer(n.nodePubkey.toBuffer()),authorizedVoter:toBuffer(n.authorizedVoter.toBuffer()),authorizedWithdrawer:toBuffer(n.authorizedWithdrawer.toBuffer()),commission:n.commission}}),i={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Oe,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:o};return new TransactionInstruction(i)}static createAccount(e){const t=new Transaction;return t.add(SystemProgram.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,voteAuthorizationType:o}=e,i=encodeData(Ut.Authorize,{newAuthorized:toBuffer(n.toBuffer()),voteAuthorizationType:o.index}),s=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Oe,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:s,programId:this.programId,data:i})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:o,voteAuthorizationType:i,votePubkey:s}=e,a=encodeData(Ut.AuthorizeWithSeed,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:toBuffer(r.toBuffer()),currentAuthorityDerivedKeySeed:n,newAuthorized:toBuffer(o.toBuffer()),voteAuthorizationType:i.index}}),u=[{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:Oe,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:u,programId:this.programId,data:a})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,lamports:n,toPubkey:o}=e,i=encodeData(Ut.Withdraw,{lamports:n}),s=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:s,programId:this.programId,data:i})}static safeWithdraw(e,t,r){if(e.lamports>t-r)throw new Error("Withdraw will leave vote account with insufficient funds.");return VoteProgram.withdraw(e)}static updateValidatorIdentity(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,nodePubkey:n}=e,o=encodeData(Ut.UpdateValidatorIdentity),i=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:i,programId:this.programId,data:o})}}VoteProgram.programId=new PublicKey("Vote111111111111111111111111111111111111111"),VoteProgram.space=3762;new PublicKey("Va1idator1nfo111111111111111111111111111111"),(0,re.NW)({name:(0,re.Yj)(),website:(0,re.lq)((0,re.Yj)()),details:(0,re.lq)((0,re.Yj)()),keybaseUsername:(0,re.lq)((0,re.Yj)())});new PublicKey("Vote111111111111111111111111111111111111111"),ee.struct([publicKey("nodePubkey"),publicKey("authorizedWithdrawer"),ee.u8("commission"),ee.nu64(),ee.seq(ee.struct([ee.nu64("slot"),ee.u32("confirmationCount")]),ee.offset(ee.u32(),-8),"votes"),ee.u8("rootSlotValid"),ee.nu64("rootSlot"),ee.nu64(),ee.seq(ee.struct([ee.nu64("epoch"),publicKey("authorizedVoter")]),ee.offset(ee.u32(),-8),"authorizedVoters"),ee.struct([ee.seq(ee.struct([publicKey("authorizedPubkey"),ee.nu64("epochOfLastAuthorizedSwitch"),ee.nu64("targetEpoch")]),32,"buf"),ee.nu64("idx"),ee.u8("isEmpty")],"priorVoters"),ee.nu64(),ee.seq(ee.struct([ee.nu64("epoch"),ee.nu64("credits"),ee.nu64("prevCredits")]),ee.offset(ee.u32(),-8),"epochCredits"),ee.struct([ee.nu64("slot"),ee.nu64("timestamp")],"lastTimestamp")])},856115:(e,t,r)=>{"use strict";var n=r(901048).Buffer;Object.defineProperty(t,"__esModule",{value:!0}),t.toBigIntLE=function toBigIntLE(e){{const t=n.from(e);t.reverse();const r=t.toString("hex");return 0===r.length?BigInt(0):BigInt(`0x${r}`)}},t.toBigIntBE=function toBigIntBE(e){{const t=e.toString("hex");return 0===t.length?BigInt(0):BigInt(`0x${t}`)}},t.toBufferLE=function toBufferLE(e,t){{const r=e.toString(16),o=n.from(r.padStart(2*t,"0").slice(0,2*t),"hex");return o.reverse(),o}},t.toBufferBE=function toBufferBE(e,t){{const r=e.toString(16);return n.from(r.padStart(2*t,"0").slice(0,2*t),"hex")}}},759499:(e,t,r)=>{"use strict";const n=r(354994).v4,o=r(393514),ClientBrowser=function(e,t){if(!(this instanceof ClientBrowser))return new ClientBrowser(e,t);t||(t={}),this.options={reviver:void 0!==t.reviver?t.reviver:null,replacer:void 0!==t.replacer?t.replacer:null,generator:void 0!==t.generator?t.generator:function(){return n()},version:void 0!==t.version?t.version:2,notificationIdNull:"boolean"==typeof t.notificationIdNull&&t.notificationIdNull},this.callServer=e};e.exports=ClientBrowser,ClientBrowser.prototype.request=function(e,t,r,n){const i=this;let s=null;const a=Array.isArray(e)&&"function"==typeof t;if(1===this.options.version&&a)throw new TypeError("JSON-RPC 1.0 does not support batching");if(a||!a&&e&&"object"==typeof e&&"function"==typeof t)n=t,s=e;else{"function"==typeof r&&(n=r,r=void 0);const i="function"==typeof n;try{s=o(e,t,r,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(e){if(i)return n(e);throw e}if(!i)return s}let u;try{u=JSON.stringify(s,this.options.replacer)}catch(e){return n(e)}return this.callServer(u,(function(e,t){i._parseResponse(e,t,n)})),s},ClientBrowser.prototype._parseResponse=function(e,t,r){if(e)return void r(e);if(!t)return r();let n;try{n=JSON.parse(t,this.options.reviver)}catch(e){return r(e)}if(3===r.length){if(Array.isArray(n)){const isError=function(e){return void 0!==e.error},isNotError=function(e){return!isError(e)};return r(null,n.filter(isError),n.filter(isNotError))}return r(null,n.error,n.result)}r(null,n)}},393514:(e,t,r)=>{"use strict";const n=r(354994).v4;e.exports=function(e,t,r,o){if("string"!=typeof e)throw new TypeError(e+" must be a string");const i="number"==typeof(o=o||{}).version?o.version:2;if(1!==i&&2!==i)throw new TypeError(i+" must be 1 or 2");const s={method:e};if(2===i&&(s.jsonrpc="2.0"),t){if("object"!=typeof t&&!Array.isArray(t))throw new TypeError(t+" must be an object, array or omitted");s.params=t}if(void 0===r){const e="function"==typeof o.generator?o.generator:function(){return n()};s.id=e(s,o)}else 2===i&&null===r?o.notificationIdNull&&(s.id=null):s.id=r;return s}},354994:(e,t,r)=>{"use strict";var n;r.d(t,{v4:()=>d});var o=new Uint8Array(16);function rng(){if(!n&&!(n="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return n(o)}const i=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;const s=function validate(e){return"string"==typeof e&&i.test(e)};for(var a=[],u=0;u<256;++u)a.push((u+256).toString(16).substr(1));const c=function stringify(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=(a[e[t+0]]+a[e[t+1]]+a[e[t+2]]+a[e[t+3]]+"-"+a[e[t+4]]+a[e[t+5]]+"-"+a[e[t+6]]+a[e[t+7]]+"-"+a[e[t+8]]+a[e[t+9]]+"-"+a[e[t+10]]+a[e[t+11]]+a[e[t+12]]+a[e[t+13]]+a[e[t+14]]+a[e[t+15]]).toLowerCase();if(!s(r))throw TypeError("Stringified UUID is invalid");return r};const d=function v4(e,t,r){var n=(e=e||{}).random||(e.rng||rng)();if(n[6]=15&n[6]|64,n[8]=63&n[8]|128,t){r=r||0;for(var o=0;o<16;++o)t[r+o]=n[o];return t}return c(n)}},516246:(e,t,r)=>{"use strict";var n=r(901048).Buffer,o=r(204293);t.A=void 0;var i=o(r(575799)),s=o(r(199436)),a=o(r(114319)),u=o(r(105018)),c=o(r(244668)),d=o(r(940906)),l=o(r(563315)),f=o(r(730409)),p=r(828985),y=r(839768);function _createSuper(e){var t=function _isNativeReflectConstruct(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function _createSuperInternal(){var r,n=(0,f.default)(e);if(t){var o=(0,f.default)(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return(0,l.default)(this,r)}}var __rest=function(e,t){var r={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(n=Object.getOwnPropertySymbols(e);o<n.length;o++)t.indexOf(n[o])<0&&Object.prototype.propertyIsEnumerable.call(e,n[o])&&(r[n[o]]=e[n[o]])}return r},g=function(e){(0,d.default)(CommonClient,e);var t,r,o,l,f=_createSuper(CommonClient);function CommonClient(e){var t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"ws://localhost:8080",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=arguments.length>3?arguments[3]:void 0,i=arguments.length>4?arguments[4]:void 0;(0,u.default)(this,CommonClient);var s=n.autoconnect,a=void 0===s||s,c=n.reconnect,d=void 0===c||c,l=n.reconnect_interval,p=void 0===l?1e3:l,g=n.max_reconnects,m=void 0===g?5:g,b=__rest(n,["autoconnect","reconnect","reconnect_interval","max_reconnects"]);return(t=f.call(this)).webSocketFactory=e,t.queue={},t.rpc_id=0,t.address=r,t.autoconnect=a,t.ready=!1,t.reconnect=d,t.reconnect_timer_id=void 0,t.reconnect_interval=p,t.max_reconnects=m,t.rest_options=b,t.current_reconnects=0,t.generate_request_id=o||function(){return++t.rpc_id},t.dataPack=i||new y.DefaultDataPack,t.autoconnect&&t._connect(t.address,Object.assign({autoconnect:t.autoconnect,reconnect:t.reconnect,reconnect_interval:t.reconnect_interval,max_reconnects:t.max_reconnects},t.rest_options)),t}return(0,c.default)(CommonClient,[{key:"connect",value:function connect(){this.socket||this._connect(this.address,Object.assign({autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects},this.rest_options))}},{key:"call",value:function call(e,t,r,n){var o=this;return n||"object"!==(0,a.default)(r)||(n=r,r=null),new Promise((function(i,s){if(!o.ready)return s(new Error("socket not ready"));var a=o.generate_request_id(e,t),u={jsonrpc:"2.0",method:e,params:t||void 0,id:a};o.socket.send(o.dataPack.encode(u),n,(function(e){if(e)return s(e);o.queue[a]={promise:[i,s]},r&&(o.queue[a].timeout=setTimeout((function(){delete o.queue[a],s(new Error("reply timeout"))}),r))}))}))}},{key:"login",value:(l=(0,s.default)(i.default.mark((function _callee(e){var t;return i.default.wrap((function _callee$(r){for(;;)switch(r.prev=r.next){case 0:return r.next=2,this.call("rpc.login",e);case 2:if(t=r.sent){r.next=5;break}throw new Error("authentication failed");case 5:return r.abrupt("return",t);case 6:case"end":return r.stop()}}),_callee,this)}))),function login(e){return l.apply(this,arguments)})},{key:"listMethods",value:(o=(0,s.default)(i.default.mark((function _callee2(){return i.default.wrap((function _callee2$(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.call("__listMethods");case 2:return e.abrupt("return",e.sent);case 3:case"end":return e.stop()}}),_callee2,this)}))),function listMethods(){return o.apply(this,arguments)})},{key:"notify",value:function notify(e,t){var r=this;return new Promise((function(n,o){if(!r.ready)return o(new Error("socket not ready"));var i={jsonrpc:"2.0",method:e,params:t};r.socket.send(r.dataPack.encode(i),(function(e){if(e)return o(e);n()}))}))}},{key:"subscribe",value:(r=(0,s.default)(i.default.mark((function _callee3(e){var t;return i.default.wrap((function _callee3$(r){for(;;)switch(r.prev=r.next){case 0:return"string"==typeof e&&(e=[e]),r.next=3,this.call("rpc.on",e);case 3:if(t=r.sent,"string"!=typeof e||"ok"===t[e]){r.next=6;break}throw new Error("Failed subscribing to an event '"+e+"' with: "+t[e]);case 6:return r.abrupt("return",t);case 7:case"end":return r.stop()}}),_callee3,this)}))),function subscribe(e){return r.apply(this,arguments)})},{key:"unsubscribe",value:(t=(0,s.default)(i.default.mark((function _callee4(e){var t;return i.default.wrap((function _callee4$(r){for(;;)switch(r.prev=r.next){case 0:return"string"==typeof e&&(e=[e]),r.next=3,this.call("rpc.off",e);case 3:if(t=r.sent,"string"!=typeof e||"ok"===t[e]){r.next=6;break}throw new Error("Failed unsubscribing from an event with: "+t);case 6:return r.abrupt("return",t);case 7:case"end":return r.stop()}}),_callee4,this)}))),function unsubscribe(e){return t.apply(this,arguments)})},{key:"close",value:function close(e,t){this.socket.close(e||1e3,t)}},{key:"_connect",value:function _connect(e,t){var r=this;clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(e,t),this.socket.addEventListener("open",(function(){r.ready=!0,r.emit("open"),r.current_reconnects=0})),this.socket.addEventListener("message",(function(e){var t=e.data;t instanceof ArrayBuffer&&(t=n.from(t).toString());try{t=r.dataPack.decode(t)}catch(e){return}if(t.notification&&r.listeners(t.notification).length){if(!Object.keys(t.params).length)return r.emit(t.notification);var o=[t.notification];if(t.params.constructor===Object)o.push(t.params);else for(var i=0;i<t.params.length;i++)o.push(t.params[i]);return Promise.resolve().then((function(){r.emit.apply(r,o)}))}if(!r.queue[t.id])return t.method?Promise.resolve().then((function(){r.emit(t.method,null==t?void 0:t.params)})):void 0;"error"in t=="result"in t&&r.queue[t.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),r.queue[t.id].timeout&&clearTimeout(r.queue[t.id].timeout),t.error?r.queue[t.id].promise[1](t.error):r.queue[t.id].promise[0](t.result),delete r.queue[t.id]})),this.socket.addEventListener("error",(function(e){return r.emit("error",e)})),this.socket.addEventListener("close",(function(n){var o=n.code,i=n.reason;r.ready&&setTimeout((function(){return r.emit("close",o,i)}),0),r.ready=!1,r.socket=void 0,1e3!==o&&(r.current_reconnects++,r.reconnect&&(r.max_reconnects>r.current_reconnects||0===r.max_reconnects)&&(r.reconnect_timer_id=setTimeout((function(){return r._connect(e,t)}),r.reconnect_interval)))}))}}]),CommonClient}(p.EventEmitter);t.A=g},885364:(e,t,r)=>{"use strict";var n=r(204293);t.A=function _default(e,t){return new c(e,t)};var o=n(r(105018)),i=n(r(244668)),s=n(r(940906)),a=n(r(563315)),u=n(r(730409));function _createSuper(e){var t=function _isNativeReflectConstruct(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function _createSuperInternal(){var r,n=(0,u.default)(e);if(t){var o=(0,u.default)(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return(0,a.default)(this,r)}}var c=function(e){(0,s.default)(WebSocketBrowserImpl,e);var t=_createSuper(WebSocketBrowserImpl);function WebSocketBrowserImpl(e,r,n){var i;return(0,o.default)(this,WebSocketBrowserImpl),(i=t.call(this)).socket=new window.WebSocket(e,n),i.socket.onopen=function(){return i.emit("open")},i.socket.onmessage=function(e){return i.emit("message",e.data)},i.socket.onerror=function(e){return i.emit("error",e)},i.socket.onclose=function(e){i.emit("close",e.code,e.reason)},i}return(0,i.default)(WebSocketBrowserImpl,[{key:"send",value:function send(e,t,r){var n=r||t;try{this.socket.send(e),n()}catch(e){n(e)}}},{key:"close",value:function close(e,t){this.socket.close(e,t)}},{key:"addEventListener",value:function addEventListener(e,t,r){this.socket.addEventListener(e,t,r)}}]),WebSocketBrowserImpl}(r(828985).EventEmitter)},839768:(e,t,r)=>{"use strict";var n=r(204293);Object.defineProperty(t,"__esModule",{value:!0}),t.DefaultDataPack=void 0,t.createError=function createError(e,t){var r={code:e,message:s.get(e)||"Internal Server Error"};t&&(r.data=t);return r};var o=n(r(105018)),i=n(r(244668)),s=new Map([[-32e3,"Event not provided"],[-32600,"Invalid Request"],[-32601,"Method not found"],[-32602,"Invalid params"],[-32603,"Internal error"],[-32604,"Params not found"],[-32605,"Method forbidden"],[-32606,"Event forbidden"],[-32700,"Parse error"]]),a=function(){function DefaultDataPack(){(0,o.default)(this,DefaultDataPack)}return(0,i.default)(DefaultDataPack,[{key:"encode",value:function encode(e){return JSON.stringify(e)}},{key:"decode",value:function decode(e){return JSON.parse(e)}}]),DefaultDataPack}();t.DefaultDataPack=a},765372:e=>{e.exports=function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e},e.exports.__esModule=!0,e.exports.default=e.exports},199436:e=>{function asyncGeneratorStep(e,t,r,n,o,i,s){try{var a=e[i](s),u=a.value}catch(e){return void r(e)}a.done?t(u):Promise.resolve(u).then(n,o)}e.exports=function _asyncToGenerator(e){return function(){var t=this,r=arguments;return new Promise((function(n,o){var i=e.apply(t,r);function _next(e){asyncGeneratorStep(i,n,o,_next,_throw,"next",e)}function _throw(e){asyncGeneratorStep(i,n,o,_next,_throw,"throw",e)}_next(void 0)}))}},e.exports.__esModule=!0,e.exports.default=e.exports},105018:e=>{e.exports=function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")},e.exports.__esModule=!0,e.exports.default=e.exports},244668:(e,t,r)=>{var n=r(356347);function _defineProperties(e,t){for(var r=0;r<t.length;r++){var o=t[r];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,n(o.key),o)}}e.exports=function _createClass(e,t,r){return t&&_defineProperties(e.prototype,t),r&&_defineProperties(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e},e.exports.__esModule=!0,e.exports.default=e.exports},730409:e=>{function _getPrototypeOf(t){return e.exports=_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function _getPrototypeOf(e){return e.__proto__||Object.getPrototypeOf(e)},e.exports.__esModule=!0,e.exports.default=e.exports,_getPrototypeOf(t)}e.exports=_getPrototypeOf,e.exports.__esModule=!0,e.exports.default=e.exports},940906:(e,t,r)=>{var n=r(469893);e.exports=function _inherits(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&n(e,t)},e.exports.__esModule=!0,e.exports.default=e.exports},204293:e=>{e.exports=function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}},e.exports.__esModule=!0,e.exports.default=e.exports},563315:(e,t,r)=>{var n=r(114319).default,o=r(765372);e.exports=function _possibleConstructorReturn(e,t){if(t&&("object"===n(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return o(e)},e.exports.__esModule=!0,e.exports.default=e.exports},217048:(e,t,r)=>{var n=r(114319).default;function _regeneratorRuntime(){"use strict";e.exports=_regeneratorRuntime=function _regeneratorRuntime(){return r},e.exports.__esModule=!0,e.exports.default=e.exports;var t,r={},o=Object.prototype,i=o.hasOwnProperty,s=Object.defineProperty||function(e,t,r){e[t]=r.value},a="function"==typeof Symbol?Symbol:{},u=a.iterator||"@@iterator",c=a.asyncIterator||"@@asyncIterator",d=a.toStringTag||"@@toStringTag";function define(e,t,r){return Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{define({},"")}catch(t){define=function define(e,t,r){return e[t]=r}}function wrap(e,t,r,n){var o=t&&t.prototype instanceof Generator?t:Generator,i=Object.create(o.prototype),a=new Context(n||[]);return s(i,"_invoke",{value:makeInvokeMethod(e,r,a)}),i}function tryCatch(e,t,r){try{return{type:"normal",arg:e.call(t,r)}}catch(e){return{type:"throw",arg:e}}}r.wrap=wrap;var l="suspendedStart",f="suspendedYield",p="executing",y="completed",g={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var m={};define(m,u,(function(){return this}));var b=Object.getPrototypeOf,w=b&&b(b(values([])));w&&w!==o&&i.call(w,u)&&(m=w);var k=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(m);function defineIteratorMethods(e){["next","throw","return"].forEach((function(t){define(e,t,(function(e){return this._invoke(t,e)}))}))}function AsyncIterator(e,t){function invoke(r,o,s,a){var u=tryCatch(e[r],e,o);if("throw"!==u.type){var c=u.arg,d=c.value;return d&&"object"==n(d)&&i.call(d,"__await")?t.resolve(d.__await).then((function(e){invoke("next",e,s,a)}),(function(e){invoke("throw",e,s,a)})):t.resolve(d).then((function(e){c.value=e,s(c)}),(function(e){return invoke("throw",e,s,a)}))}a(u.arg)}var r;s(this,"_invoke",{value:function value(e,n){function callInvokeWithMethodAndArg(){return new t((function(t,r){invoke(e,n,t,r)}))}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=l;return function(i,s){if(o===p)throw new Error("Generator is already running");if(o===y){if("throw"===i)throw s;return{value:t,done:!0}}for(n.method=i,n.arg=s;;){var a=n.delegate;if(a){var u=maybeInvokeDelegate(a,n);if(u){if(u===g)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===l)throw o=y,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=p;var c=tryCatch(e,r,n);if("normal"===c.type){if(o=n.done?y:f,c.arg===g)continue;return{value:c.arg,done:n.done}}"throw"===c.type&&(o=y,n.method="throw",n.arg=c.arg)}}}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n+"' method")),g;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,g;var s=i.arg;return s?s.done?(r[e.resultName]=s.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,g):s:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,g)}function pushTryEntry(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function resetTryEntry(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function Context(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(pushTryEntry,this),this.reset(!0)}function values(e){if(e||""===e){var r=e[u];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,s=function next(){for(;++o<e.length;)if(i.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return s.next=s}}throw new TypeError(n(e)+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,s(k,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),s(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,d,"GeneratorFunction"),r.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===GeneratorFunction||"GeneratorFunction"===(t.displayName||t.name))},r.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,GeneratorFunctionPrototype):(e.__proto__=GeneratorFunctionPrototype,define(e,d,"GeneratorFunction")),e.prototype=Object.create(k),e},r.awrap=function(e){return{__await:e}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){return this})),r.AsyncIterator=AsyncIterator,r.async=function(e,t,n,o,i){void 0===i&&(i=Promise);var s=new AsyncIterator(wrap(e,t,n,o),i);return r.isGeneratorFunction(t)?s:s.next().then((function(e){return e.done?e.value:s.next()}))},defineIteratorMethods(k),define(k,d,"Generator"),define(k,u,(function(){return this})),define(k,"toString",(function(){return"[object Generator]"})),r.keys=function(e){var t=Object(e),r=[];for(var n in t)r.push(n);return r.reverse(),function next(){for(;r.length;){var e=r.pop();if(e in t)return next.value=e,next.done=!1,next}return next.done=!0,next}},r.values=values,Context.prototype={constructor:Context,reset:function reset(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&i.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function stop(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function dispatchException(e){if(this.done)throw e;var r=this;function handle(n,o){return s.type="throw",s.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var n=this.tryEntries.length-1;n>=0;--n){var o=this.tryEntries[n],s=o.completion;if("root"===o.tryLoc)return handle("end");if(o.tryLoc<=this.prev){var a=i.call(o,"catchLoc"),u=i.call(o,"finallyLoc");if(a&&u){if(this.prev<o.catchLoc)return handle(o.catchLoc,!0);if(this.prev<o.finallyLoc)return handle(o.finallyLoc)}else if(a){if(this.prev<o.catchLoc)return handle(o.catchLoc,!0)}else{if(!u)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return handle(o.finallyLoc)}}}},abrupt:function abrupt(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&i.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var o=n;break}}o&&("break"===e||"continue"===e)&&o.tryLoc<=t&&t<=o.finallyLoc&&(o=null);var s=o?o.completion:{};return s.type=e,s.arg=t,o?(this.method="next",this.next=o.finallyLoc,g):this.complete(s)},complete:function complete(e,t){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&t&&(this.next=t),g},finish:function finish(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.finallyLoc===e)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),g}},catch:function _catch(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc===e){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function delegateYield(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),g}},r}e.exports=_regeneratorRuntime,e.exports.__esModule=!0,e.exports.default=e.exports},469893:e=>{function _setPrototypeOf(t,r){return e.exports=_setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function _setPrototypeOf(e,t){return e.__proto__=t,e},e.exports.__esModule=!0,e.exports.default=e.exports,_setPrototypeOf(t,r)}e.exports=_setPrototypeOf,e.exports.__esModule=!0,e.exports.default=e.exports},423878:(e,t,r)=>{var n=r(114319).default;e.exports=function toPrimitive(e,t){if("object"!=n(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var o=r.call(e,t||"default");if("object"!=n(o))return o;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)},e.exports.__esModule=!0,e.exports.default=e.exports},356347:(e,t,r)=>{var n=r(114319).default,o=r(423878);e.exports=function toPropertyKey(e){var t=o(e,"string");return"symbol"==n(t)?t:String(t)},e.exports.__esModule=!0,e.exports.default=e.exports},114319:e=>{function _typeof(t){return e.exports=_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},e.exports.__esModule=!0,e.exports.default=e.exports,_typeof(t)}e.exports=_typeof,e.exports.__esModule=!0,e.exports.default=e.exports},575799:(e,t,r)=>{var n=r(217048)();e.exports=n;try{regeneratorRuntime=n}catch(e){"object"==typeof globalThis?globalThis.regeneratorRuntime=n:Function("r","regeneratorRuntime = r")(n)}},52494:(e,t,r)=>{"use strict";r.d(t,{a0:()=>w,lY:()=>b});var n=r(226879),o=r(249964),i=r(830036);const[s,a,u]=[[],[],[]],c=BigInt(0),d=BigInt(1),l=BigInt(2),f=BigInt(7),p=BigInt(256),y=BigInt(113);for(let e=0,t=d,r=1,n=0;e<24;e++){[r,n]=[n,(2*r+3*n)%5],s.push(2*(5*n+r)),a.push((e+1)*(e+2)/2%64);let o=c;for(let e=0;e<7;e++)t=(t<<d^(t>>f)*y)%p,t&l&&(o^=d<<(d<<BigInt(e))-d);u.push(o)}const[g,m]=(0,o.lD)(u,!0),rotlH=(e,t,r)=>r>32?(0,o.WM)(e,t,r):(0,o.P5)(e,t,r),rotlL=(e,t,r)=>r>32?(0,o.im)(e,t,r):(0,o.B4)(e,t,r);class Keccak extends i.Vw{constructor(e,t,r,o=!1,s=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=r,this.enableXOF=o,this.rounds=s,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,(0,n.ai)(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,i.DH)(this.state)}keccak(){!function keccakP(e,t=24){const r=new Uint32Array(10);for(let n=24-t;n<24;n++){for(let t=0;t<10;t++)r[t]=e[t]^e[t+10]^e[t+20]^e[t+30]^e[t+40];for(let t=0;t<10;t+=2){const n=(t+8)%10,o=(t+2)%10,i=r[o],s=r[o+1],a=rotlH(i,s,1)^r[n],u=rotlL(i,s,1)^r[n+1];for(let r=0;r<50;r+=10)e[t+r]^=a,e[t+r+1]^=u}let t=e[2],o=e[3];for(let r=0;r<24;r++){const n=a[r],i=rotlH(t,o,n),u=rotlL(t,o,n),c=s[r];t=e[c],o=e[c+1],e[c]=i,e[c+1]=u}for(let t=0;t<50;t+=10){for(let n=0;n<10;n++)r[n]=e[t+n];for(let n=0;n<10;n++)e[t+n]^=~r[(n+2)%10]&r[(n+4)%10]}e[0]^=g[n],e[1]^=m[n]}r.fill(0)}(this.state32,this.rounds),this.posOut=0,this.pos=0}update(e){(0,n.t2)(this);const{blockLen:t,state:r}=this,o=(e=(0,i.ZJ)(e)).length;for(let n=0;n<o;){const i=Math.min(t-this.pos,o-n);for(let t=0;t<i;t++)r[this.pos++]^=e[n++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:r,blockLen:n}=this;e[r]^=t,128&t&&r===n-1&&this.keccak(),e[n-1]^=128,this.keccak()}writeInto(e){(0,n.t2)(this,!1),(0,n.ee)(e),this.finish();const t=this.state,{blockLen:r}=this;for(let n=0,o=e.length;n<o;){this.posOut>=r&&this.keccak();const i=Math.min(r-this.posOut,o-n);e.set(t.subarray(this.posOut,this.posOut+i),n),this.posOut+=i,n+=i}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return(0,n.ai)(e),this.xofInto(new Uint8Array(e))}digestInto(e){if((0,n.CG)(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:r,outputLen:n,rounds:o,enableXOF:i}=this;return e||(e=new Keccak(t,r,n,i,o)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=r,e.outputLen=n,e.enableXOF=i,e.destroyed=this.destroyed,e}}const gen=(e,t,r)=>(0,i.ld)((()=>new Keccak(t,e,r))),b=gen(1,136,32),w=gen(1,72,64)},727801:(e,t,r)=>{"use strict";r.d(t,{KC:()=>union,KJ:()=>instance,L5:()=>unknown,NW:()=>type,PV:()=>tuple,YO:()=>array,Yj:()=>string,ai:()=>number,au:()=>coerce,bz:()=>any,eu:()=>literal,g1:()=>record,lq:()=>optional,me:()=>nullable,vA:()=>assert,vt:()=>create,zM:()=>boolean});class StructError extends TypeError{constructor(e,t){let r;const{message:n,...o}=e,{path:i}=e;super(0===i.length?n:"At path: "+i.join(".")+" -- "+n),Object.assign(this,o),this.name=this.constructor.name,this.failures=()=>{var n;return null!=(n=r)?n:r=[e,...t()]}}}function isObject(e){return"object"==typeof e&&null!=e}function print(e){return"string"==typeof e?JSON.stringify(e):""+e}function toFailure(e,t,r,n){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});const{path:o,branch:i}=t,{type:s}=r,{refinement:a,message:u="Expected a value of type `"+s+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+print(n)+"`"}=e;return{value:n,type:s,refinement:a,key:o[o.length-1],path:o,branch:i,...e,message:u}}function*toFailures(e,t,r,n){(function isIterable(e){return isObject(e)&&"function"==typeof e[Symbol.iterator]})(e)||(e=[e]);for(const o of e){const e=toFailure(o,t,r,n);e&&(yield e)}}function*run(e,t,r={}){const{path:n=[],branch:o=[e],coerce:i=!1,mask:s=!1}=r,a={path:n,branch:o};if(i&&(e=t.coercer(e,a),s&&"type"!==t.type&&isObject(t.schema)&&isObject(e)&&!Array.isArray(e)))for(const r in e)void 0===t.schema[r]&&delete e[r];let u=!0;for(const r of t.validator(e,a))u=!1,yield[r,void 0];for(let[r,c,d]of t.entries(e,a)){const t=run(c,d,{path:void 0===r?n:[...n,r],branch:void 0===r?o:[...o,c],coerce:i,mask:s});for(const n of t)n[0]?(u=!1,yield[n[0],void 0]):i&&(c=n[1],void 0===r?e=c:e instanceof Map?e.set(r,c):e instanceof Set?e.add(c):isObject(e)&&(e[r]=c))}if(u)for(const r of t.refiner(e,a))u=!1,yield[r,void 0];u&&(yield[void 0,e])}class Struct{constructor(e){const{type:t,schema:r,validator:n,refiner:o,coercer:i=(e=>e),entries:s=function*(){}}=e;this.type=t,this.schema=r,this.entries=s,this.coercer=i,this.validator=n?(e,t)=>toFailures(n(e,t),t,this,e):()=>[],this.refiner=o?(e,t)=>toFailures(o(e,t),t,this,e):()=>[]}assert(e){return assert(e,this)}create(e){return create(e,this)}is(e){return is(e,this)}mask(e){return function mask(e,t){const r=validate(e,t,{coerce:!0,mask:!0});if(r[0])throw r[0];return r[1]}(e,this)}validate(e,t={}){return validate(e,this,t)}}function assert(e,t){const r=validate(e,t);if(r[0])throw r[0]}function create(e,t){const r=validate(e,t,{coerce:!0});if(r[0])throw r[0];return r[1]}function is(e,t){return!validate(e,t)[0]}function validate(e,t,r={}){const n=run(e,t,r),o=function shiftIterator(e){const{done:t,value:r}=e.next();return t?void 0:r}(n);if(o[0]){return[new StructError(o[0],(function*(){for(const e of n)e[0]&&(yield e[0])})),void 0]}return[void 0,o[1]]}function define(e,t){return new Struct({type:e,schema:null,validator:t})}function any(){return define("any",(()=>!0))}function array(e){return new Struct({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[r,n]of t.entries())yield[r,n,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||"Expected an array value, but received: "+print(e)})}function boolean(){return define("boolean",(e=>"boolean"==typeof e))}function instance(e){return define("instance",(t=>t instanceof e||"Expected a `"+e.name+"` instance, but received: "+print(t)))}function literal(e){const t=print(e),r=typeof e;return new Struct({type:"literal",schema:"string"===r||"number"===r||"boolean"===r?e:null,validator:r=>r===e||"Expected the literal `"+t+"`, but received: "+print(r)})}function never(){return define("never",(()=>!1))}function nullable(e){return new Struct({...e,validator:(t,r)=>null===t||e.validator(t,r),refiner:(t,r)=>null===t||e.refiner(t,r)})}function number(){return define("number",(e=>"number"==typeof e&&!isNaN(e)||"Expected a number, but received: "+print(e)))}function optional(e){return new Struct({...e,validator:(t,r)=>void 0===t||e.validator(t,r),refiner:(t,r)=>void 0===t||e.refiner(t,r)})}function record(e,t){return new Struct({type:"record",schema:null,*entries(r){if(isObject(r))for(const n in r){const o=r[n];yield[n,n,e],yield[n,o,t]}},validator:e=>isObject(e)||"Expected an object, but received: "+print(e)})}function string(){return define("string",(e=>"string"==typeof e||"Expected a string, but received: "+print(e)))}function tuple(e){const t=never();return new Struct({type:"tuple",schema:null,*entries(r){if(Array.isArray(r)){const n=Math.max(e.length,r.length);for(let o=0;o<n;o++)yield[o,r[o],e[o]||t]}},validator:e=>Array.isArray(e)||"Expected an array, but received: "+print(e)})}function type(e){const t=Object.keys(e);return new Struct({type:"type",schema:e,*entries(r){if(isObject(r))for(const n of t)yield[n,r[n],e[n]]},validator:e=>isObject(e)||"Expected an object, but received: "+print(e)})}function union(e){const t=e.map((e=>e.type)).join(" | ");return new Struct({type:"union",schema:null,validator(r,n){const o=[];for(const t of e){const[...e]=run(r,t,n),[i]=e;if(!i[0])return[];for(const[t]of e)t&&o.push(t)}return["Expected the value to satisfy a union of `"+t+"`, but received: "+print(r),...o]}})}function unknown(){return define("unknown",(()=>!0))}function coerce(e,t,r){return new Struct({...e,coercer:(n,o)=>is(n,t)?e.coercer(r(n,o),o):e.coercer(n,o)})}}}]);
//# sourceMappingURL=23376.48ecc68b48.chunk.js.map
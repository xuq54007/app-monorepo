{"version":3,"file":"static/js/39430.d7890c7883.chunk.js","mappings":"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","sources":["webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/node_modules/big-integer/BigInteger.js","webpack://web/../../node_modules/bchaddrjs/node_modules/bs58check/base.js","webpack://web/../../node_modules/bchaddrjs/node_modules/bs58check/index.js","webpack://web/../../node_modules/bchaddrjs/src/bchaddr.js","webpack://web/../../node_modules/cashaddrjs/node_modules/big-integer/BigInteger.js","webpack://web/../../node_modules/cashaddrjs/src/base32.js","webpack://web/../../node_modules/cashaddrjs/src/cashaddr.js","webpack://web/../../node_modules/cashaddrjs/src/convertBits.js","webpack://web/../../node_modules/cashaddrjs/src/validation.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/cashaddr/validation.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/cashaddr/base32.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/cashaddr/index.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/cashaddr/convertBits.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/networks.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/bip66.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/ops.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/push_data.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/types.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/script_signature.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/script.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/script_number.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/payments/lazy.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/payments/p2ms.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/payments/p2pk.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/crypto.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/node_modules/base-x/src/esm/index.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/node_modules/bs58/src/esm/index.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/node_modules/bs58check/src/esm/index.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/node_modules/bs58check/src/esm/base.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/payments/p2pkh.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/payments/p2sh.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/payments/p2wpkh.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/payments/p2wsh.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/ecc_lib.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/bufferutils.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/payments/bip341.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/payments/p2tr.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/address.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/transaction.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/block.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/psbt/psbtutils.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/psbt/bip371.js","webpack://web/../../node_modules/@onekeyfe/bitcoinforksjs-lib/src/esm/psbt.js"],"sourcesContent":["var bigInt = (function (undefined) {\r\n    \"use strict\";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\n\r\n    var supportsNativeBigInt = typeof BigInt === \"function\";\r\n\r\n    function Integer(v, radix, alphabet, caseSensitive) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function NativeBigInt(value) {\r\n        this.value = value;\r\n    }\r\n    NativeBigInt.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    NativeBigInt.prototype.add = function (v) {\r\n        return new NativeBigInt(this.value + parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a, b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    NativeBigInt.prototype.subtract = function (v) {\r\n        return new NativeBigInt(this.value - parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n    NativeBigInt.prototype.negate = function () {\r\n        return new NativeBigInt(-this.value);\r\n    }\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n    NativeBigInt.prototype.abs = function () {\r\n        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\r\n    }\r\n\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n        if (isPrecise(a.value * this.value)) {\r\n            return new SmallInteger(a.value * this.value);\r\n        }\r\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n        if (a.value === 0) return Integer[0];\r\n        if (a.value === 1) return this;\r\n        if (a.value === -1) return this.negate();\r\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    NativeBigInt.prototype.multiply = function (v) {\r\n        return new NativeBigInt(this.value * parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\r\n\r\n    function square(a) {\r\n        //console.assert(2 * BASE * BASE < MAX_INT);\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            carry = 0 - a_i * a_i;\r\n            for (var j = i; j < l; j++) {\r\n                a_j = a[j];\r\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n            }\r\n            r[i + l] = carry;\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    NativeBigInt.prototype.square = function (v) {\r\n        return new NativeBigInt(this.value * this.value);\r\n    }\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        if (supportsNativeBigInt) {\r\n            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];\r\n        }\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {\r\n        return new NativeBigInt(this.value / parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {\r\n        return new NativeBigInt(this.value % parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    NativeBigInt.prototype.pow = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value, b = n.value;\r\n        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\r\n        if (b === _0) return Integer[1];\r\n        if (a === _0) return Integer[0];\r\n        if (a === _1) return Integer[1];\r\n        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.isNegative()) return new NativeBigInt(_0);\r\n        var x = this;\r\n        var y = Integer[1];\r\n        while (true) {\r\n            if ((b & _1) === _1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === _0) break;\r\n            b /= _2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    }\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        if (exp.isNegative()) {\r\n            exp = exp.multiply(Integer[-1]);\r\n            base = base.modInv(mod);\r\n        }\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n    NativeBigInt.prototype.compareAbs = function (v) {\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        a = a >= 0 ? a : -a;\r\n        b = b >= 0 ? b : -b;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    NativeBigInt.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n    NativeBigInt.prototype.isEven = function () {\r\n        return (this.value & BigInt(1)) === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n    NativeBigInt.prototype.isOdd = function () {\r\n        return (this.value & BigInt(1)) === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n    NativeBigInt.prototype.isUnit = function () {\r\n        return this.abs().value === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    NativeBigInt.prototype.isZero = function () {\r\n        return this.value === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        if (n.isZero()) return false;\r\n        if (n.isUnit()) return true;\r\n        if (n.compareAbs(2) === 0) return this.isEven();\r\n        return this.mod(n).isZero();\r\n    };\r\n    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(49)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n\r\n    function millerRabinTest(n, a) {\r\n        var nPrev = n.prev(),\r\n            b = nPrev,\r\n            r = 0,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2), r++;\r\n        next: for (i = 0; i < a.length; i++) {\r\n            if (n.lesser(a[i])) continue;\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.isUnit() || x.equals(nPrev)) continue;\r\n            for (d = r - 1; d != 0; d--) {\r\n                x = x.square().mod(n);\r\n                if (x.isUnit()) return false;\r\n                if (x.equals(nPrev)) continue next;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Set \"strict\" to true to force GRH-supported lower bound of 2*log(N)^2\r\n    BigInteger.prototype.isPrime = function (strict) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var bits = n.bitLength();\r\n        if (bits <= 64)\r\n            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\r\n        var logN = Math.log(2) * bits.toJSNumber();\r\n        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt(i + 2));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations, rng) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt.randBetween(2, n.minus(2), rng));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.isZero()) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.isUnit()) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n    NativeBigInt.prototype.next = function () {\r\n        return new NativeBigInt(this.value + BigInt(1));\r\n    }\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n    NativeBigInt.prototype.prev = function () {\r\n        return new NativeBigInt(this.value - BigInt(1));\r\n    }\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return Math.abs(n) <= BASE;\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (v) {\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        if (result.isZero()) return result;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (v) {\r\n        var remQuo;\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value,\r\n            x = typeof v === \"number\" ? v | LOBMASK_I :\r\n                typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) :\r\n                    v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function integerLogarithm(value, base) {\r\n        if (base.compareTo(value) <= 0) {\r\n            var tmp = integerLogarithm(value, base.square(base));\r\n            var p = tmp.p;\r\n            var e = tmp.e;\r\n            var t = p.multiply(base);\r\n            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };\r\n        }\r\n        return { p: bigInt(1), e: 0 };\r\n    }\r\n\r\n    BigInteger.prototype.bitLength = function () {\r\n        var n = this;\r\n        if (n.compareTo(bigInt(0)) < 0) {\r\n            n = n.negate().subtract(bigInt(1));\r\n        }\r\n        if (n.compareTo(bigInt(0)) === 0) {\r\n            return bigInt(0);\r\n        }\r\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\r\n    }\r\n    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b, rng) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var usedRNG = rng || Math.random;\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));\r\n        var digits = toBase(range, BASE).value;\r\n        var result = [], restricted = true;\r\n        for (var i = 0; i < digits.length; i++) {\r\n            var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;\r\n            var digit = truncate(usedRNG() * top);\r\n            result.push(digit);\r\n            if (digit < digits[i]) restricted = false;\r\n        }\r\n        return low.add(Integer.fromArray(result, BASE, false));\r\n    }\r\n\r\n    var parseBase = function (text, base, alphabet, caseSensitive) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        text = String(text);\r\n        if (!caseSensitive) {\r\n            text = text.toLowerCase();\r\n            alphabet = alphabet.toLowerCase();\r\n        }\r\n        var length = text.length;\r\n        var i;\r\n        var absBase = Math.abs(base);\r\n        var alphabetValues = {};\r\n        for (i = 0; i < alphabet.length; i++) {\r\n            alphabetValues[alphabet[i]] = i;\r\n        }\r\n        for (i = 0; i < length; i++) {\r\n            var c = text[i];\r\n            if (c === \"-\") continue;\r\n            if (c in alphabetValues) {\r\n                if (alphabetValues[c] >= absBase) {\r\n                    if (c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                }\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i];\r\n            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\" && i < text.length);\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit, alphabet) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        if (digit < alphabet.length) {\r\n            return alphabet[digit];\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            if (n.isNegative())\r\n                return {\r\n                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))\r\n                        .map(Array.prototype.valueOf, [1, 0])\r\n                    ),\r\n                    isNegative: false\r\n                };\r\n\r\n            var arr = Array.apply(null, Array(n.toJSNumber() - 1))\r\n                .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n                value: [].concat.apply([], arr),\r\n                isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.isUnit()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n\r\n            return {\r\n                value: Array.apply(null, Array(n.toJSNumber()))\r\n                    .map(Number.prototype.valueOf, 1),\r\n                isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return { value: out.reverse(), isNegative: neg };\r\n    }\r\n\r\n    function toBaseString(n, base, alphabet) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function (x) {\r\n            return stringify(x, alphabet);\r\n        }).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    NativeBigInt.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10) return toBaseString(this, radix, alphabet);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10) return toBaseString(this, radix, alphabet);\r\n        return String(this.value);\r\n    };\r\n\r\n    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\r\n\r\n    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); }\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {\r\n        return parseInt(this.toString(), 10);\r\n    }\r\n\r\n    function parseStringValue(v) {\r\n        if (isPrecise(+v)) {\r\n            var x = +v;\r\n            if (x === truncate(x))\r\n                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\r\n            throw new Error(\"Invalid integer: \" + v);\r\n        }\r\n        var sign = v[0] === \"-\";\r\n        if (sign) v = v.slice(1);\r\n        var split = v.split(/e/i);\r\n        if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n        if (split.length === 2) {\r\n            var exp = split[1];\r\n            if (exp[0] === \"+\") exp = exp.slice(1);\r\n            exp = +exp;\r\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n            var text = split[0];\r\n            var decimalPlace = text.indexOf(\".\");\r\n            if (decimalPlace >= 0) {\r\n                exp -= text.length - decimalPlace - 1;\r\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n            }\r\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n            text += (new Array(exp + 1)).join(\"0\");\r\n            v = text;\r\n        }\r\n        var isValid = /^([0-9][0-9]*)$/.test(v);\r\n        if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(sign ? \"-\" + v : v));\r\n        }\r\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n        while (max > 0) {\r\n            r.push(+v.slice(min, max));\r\n            min -= l;\r\n            if (min < 0) min = 0;\r\n            max -= l;\r\n        }\r\n        trim(r);\r\n        return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(v));\r\n        }\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        if (typeof v === \"bigint\") {\r\n            return new NativeBigInt(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = parseValue(i);\r\n        if (i > 0) Integer[-i] = parseValue(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif (typeof define === \"function\" && define.amd) {\r\n    define( function () {\r\n        return bigInt;\r\n    });\r\n}\r\n","'use strict'\n\nvar base58 = require('bs58')\nvar Buffer = require('safe-buffer').Buffer\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode (payload) {\n    var checksum = checksumFn(payload)\n\n    return base58.encode(Buffer.concat([\n      payload,\n      checksum\n    ], payload.length + 4))\n  }\n\n  function decodeRaw (buffer) {\n    var payload = buffer.slice(0, -4)\n    var checksum = buffer.slice(-4)\n    var newChecksum = checksumFn(payload)\n\n    if (checksum[0] ^ newChecksum[0] |\n        checksum[1] ^ newChecksum[1] |\n        checksum[2] ^ newChecksum[2] |\n        checksum[3] ^ newChecksum[3]) return\n\n    return payload\n  }\n\n  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n  function decodeUnsafe (string) {\n    var buffer = base58.decodeUnsafe(string)\n    if (!buffer) return\n\n    return decodeRaw(buffer)\n  }\n\n  function decode (string) {\n    var buffer = base58.decode(string)\n    var payload = decodeRaw(buffer, checksumFn)\n    if (!payload) throw new Error('Invalid checksum')\n    return payload\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  }\n}\n","'use strict'\n\nvar createHash = require('create-hash')\nvar bs58checkBase = require('./base')\n\n// SHA256(SHA256(buffer))\nfunction sha256x2 (buffer) {\n  var tmp = createHash('sha256').update(buffer).digest()\n  return createHash('sha256').update(tmp).digest()\n}\n\nmodule.exports = bs58checkBase(sha256x2)\n","/***\n * @license\n * https://github.com/ealmansi/bchaddrjs\n * Copyright (c) 2018-2020 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\n\nvar bs58check = require('bs58check')\nvar cashaddr = require('cashaddrjs')\nvar Buffer = require('buffer/').Buffer\n\n/**\n * General purpose Bitcoin Cash address detection and translation.<br />\n * Supports all major Bitcoin Cash address formats.<br />\n * Currently:\n * <ul>\n *    <li> Legacy format </li>\n *    <li> Bitpay format </li>\n *    <li> Cashaddr format </li>\n * </ul>\n * @module bchaddr\n */\n\n/**\n * @static\n * Supported Bitcoin Cash address formats.\n */\nvar Format = {}\nFormat.Legacy = 'legacy'\nFormat.Bitpay = 'bitpay'\nFormat.Cashaddr = 'cashaddr'\n\n/**\n * @static\n * Supported networks.\n */\nvar Network = {}\nNetwork.Mainnet = 'mainnet'\nNetwork.Testnet = 'testnet'\n\n/**\n * @static\n * Supported address types.\n */\nvar Type = {}\nType.P2PKH = 'p2pkh'\nType.P2SH = 'p2sh'\n\n/**\n * Returns a boolean indicating whether the given input is a valid Bitcoin Cash address.\n * @static\n * @param {*} input - Any input to check for validity.\n * @returns {boolean}\n */\nfunction isValidAddress (input) {\n  try {\n    decodeAddress(input)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\n/**\n * Detects what is the given address' format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\nfunction detectAddressFormat (address) {\n  return decodeAddress(address).format\n}\n\n/**\n * Detects what is the given address' network.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\nfunction detectAddressNetwork (address) {\n  return decodeAddress(address).network\n}\n\n/**\n * Detects what is the given address' type.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\nfunction detectAddressType (address) {\n  return decodeAddress(address).type\n}\n\n/**\n * Translates the given address into legacy format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\nfunction toLegacyAddress (address) {\n  var decoded = decodeAddress(address)\n  if (decoded.format === Format.Legacy) {\n    return address\n  }\n  return encodeAsLegacy(decoded)\n}\n\n/**\n * Translates the given address into bitpay format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\nfunction toBitpayAddress (address) {\n  var decoded = decodeAddress(address)\n  if (decoded.format === Format.Bitpay) {\n    return address\n  }\n  return encodeAsBitpay(decoded)\n}\n\n/**\n * Translates the given address into cashaddr format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\nfunction toCashAddress (address) {\n  var decoded = decodeAddress(address)\n  return encodeAsCashaddr(decoded)\n}\n\n/**\n * Version byte table for base58 formats.\n * @private\n */\nvar VERSION_BYTE = {}\nVERSION_BYTE[Format.Legacy] = {}\nVERSION_BYTE[Format.Legacy][Network.Mainnet] = {}\nVERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH] = 0\nVERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH] = 5\nVERSION_BYTE[Format.Legacy][Network.Testnet] = {}\nVERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH] = 111\nVERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH] = 196\nVERSION_BYTE[Format.Bitpay] = {}\nVERSION_BYTE[Format.Bitpay][Network.Mainnet] = {}\nVERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH] = 28\nVERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH] = 40\nVERSION_BYTE[Format.Bitpay][Network.Testnet] = {}\nVERSION_BYTE[Format.Bitpay][Network.Testnet][Type.P2PKH] = 111\nVERSION_BYTE[Format.Bitpay][Network.Testnet][Type.P2SH] = 196\n\n/**\n * Decodes the given address into its constituting hash, format, network and type.\n * @private\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {object}\n * @throws {InvalidAddressError}\n */\nfunction decodeAddress (address) {\n  try {\n    return decodeBase58Address(address)\n  } catch (error) {\n  }\n  try {\n    return decodeCashAddress(address)\n  } catch (error) {\n  }\n  throw new InvalidAddressError()\n}\n\n/**\n * Length of a valid base58check encoding payload: 1 byte for\n * the version byte plus 20 bytes for a RIPEMD-160 hash.\n * @private\n */\nvar BASE_58_CHECK_PAYLOAD_LENGTH = 21\n\n/**\n * Attempts to decode the given address assuming it is a base58 address.\n * @private\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {object}\n * @throws {InvalidAddressError}\n */\nfunction decodeBase58Address (address) {\n  try {\n    var payload = bs58check.decode(address)\n    if (payload.length !== BASE_58_CHECK_PAYLOAD_LENGTH) {\n      throw new InvalidAddressError()\n    }\n    var versionByte = payload[0]\n    var hash = Array.prototype.slice.call(payload, 1)\n    switch (versionByte) {\n      case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Mainnet,\n          type: Type.P2PKH\n        }\n      case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Mainnet,\n          type: Type.P2SH\n        }\n      case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Testnet,\n          type: Type.P2PKH\n        }\n      case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Testnet,\n          type: Type.P2SH\n        }\n      case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Bitpay,\n          network: Network.Mainnet,\n          type: Type.P2PKH\n        }\n      case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Bitpay,\n          network: Network.Mainnet,\n          type: Type.P2SH\n        }\n    }\n  } catch (error) {\n  }\n  throw new InvalidAddressError()\n}\n\n/**\n * Attempts to decode the given address assuming it is a cashaddr address.\n * @private\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {object}\n * @throws {InvalidAddressError}\n */\nfunction decodeCashAddress (address) {\n  if (address.indexOf(':') !== -1) {\n    try {\n      return decodeCashAddressWithPrefix(address)\n    } catch (error) {\n    }\n  } else {\n    var prefixes = ['bitcoincash', 'bchtest', 'bchreg']\n    for (var i = 0; i < prefixes.length; ++i) {\n      try {\n        var prefix = prefixes[i]\n        return decodeCashAddressWithPrefix(prefix + ':' + address)\n      } catch (error) {\n      }\n    }\n  }\n  throw new InvalidAddressError()\n}\n\n/**\n * Attempts to decode the given address assuming it is a cashaddr address with explicit prefix.\n * @private\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {object}\n * @throws {InvalidAddressError}\n */\nfunction decodeCashAddressWithPrefix (address) {\n  try {\n    var decoded = cashaddr.decode(address)\n    var hash = Array.prototype.slice.call(decoded.hash, 0)\n    var type = decoded.type === 'P2PKH' ? Type.P2PKH : Type.P2SH\n    switch (decoded.prefix) {\n      case 'bitcoincash':\n        return {\n          hash: hash,\n          format: Format.Cashaddr,\n          network: Network.Mainnet,\n          type: type\n        }\n      case 'bchtest':\n      case 'bchreg':\n        return {\n          hash: hash,\n          format: Format.Cashaddr,\n          network: Network.Testnet,\n          type: type\n        }\n    }\n  } catch (error) {\n  }\n  throw new InvalidAddressError()\n}\n\n/**\n * Encodes the given decoded address into legacy format.\n * @private\n * @param {object} decoded\n * @returns {string}\n */\nfunction encodeAsLegacy (decoded) {\n  var versionByte = VERSION_BYTE[Format.Legacy][decoded.network][decoded.type]\n  var buffer = Buffer.alloc(1 + decoded.hash.length)\n  buffer[0] = versionByte\n  buffer.set(decoded.hash, 1)\n  return bs58check.encode(buffer)\n}\n\n/**\n * Encodes the given decoded address into bitpay format.\n * @private\n * @param {object} decoded\n * @returns {string}\n */\nfunction encodeAsBitpay (decoded) {\n  var versionByte = VERSION_BYTE[Format.Bitpay][decoded.network][decoded.type]\n  var buffer = Buffer.alloc(1 + decoded.hash.length)\n  buffer[0] = versionByte\n  buffer.set(decoded.hash, 1)\n  return bs58check.encode(buffer)\n}\n\n/**\n * Encodes the given decoded address into cashaddr format.\n * @private\n * @param {object} decoded\n * @returns {string}\n */\nfunction encodeAsCashaddr (decoded) {\n  var prefix = decoded.network === Network.Mainnet ? 'bitcoincash' : 'bchtest'\n  var type = decoded.type === Type.P2PKH ? 'P2PKH' : 'P2SH'\n  var hash = new Uint8Array(decoded.hash)\n  return cashaddr.encode(prefix, type, hash)\n}\n\n/**\n * Returns a boolean indicating whether the address is in legacy format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\nfunction isLegacyAddress (address) {\n  return detectAddressFormat(address) === Format.Legacy\n}\n\n/**\n * Returns a boolean indicating whether the address is in bitpay format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\nfunction isBitpayAddress (address) {\n  return detectAddressFormat(address) === Format.Bitpay\n}\n\n/**\n * Returns a boolean indicating whether the address is in cashaddr format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\nfunction isCashAddress (address) {\n  return detectAddressFormat(address) === Format.Cashaddr\n}\n\n/**\n * Returns a boolean indicating whether the address is a mainnet address.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\nfunction isMainnetAddress (address) {\n  return detectAddressNetwork(address) === Network.Mainnet\n}\n\n/**\n * Returns a boolean indicating whether the address is a testnet address.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\nfunction isTestnetAddress (address) {\n  return detectAddressNetwork(address) === Network.Testnet\n}\n\n/**\n * Returns a boolean indicating whether the address is a p2pkh address.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\nfunction isP2PKHAddress (address) {\n  return detectAddressType(address) === Type.P2PKH\n}\n\n/**\n * Returns a boolean indicating whether the address is a p2sh address.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\nfunction isP2SHAddress (address) {\n  return detectAddressType(address) === Type.P2SH\n}\n\n/**\n * Error thrown when the address given as input is not a valid Bitcoin Cash address.\n * @constructor\n * InvalidAddressError\n */\nfunction InvalidAddressError () {\n  var error = new Error()\n  this.name = error.name = 'InvalidAddressError'\n  this.message = error.message = 'Received an invalid Bitcoin Cash address as input.'\n  this.stack = error.stack\n}\n\nInvalidAddressError.prototype = Object.create(Error.prototype)\n\nmodule.exports = {\n  Format: Format,\n  Network: Network,\n  Type: Type,\n  isValidAddress: isValidAddress,\n  detectAddressFormat: detectAddressFormat,\n  detectAddressNetwork: detectAddressNetwork,\n  detectAddressType: detectAddressType,\n  toLegacyAddress: toLegacyAddress,\n  toBitpayAddress: toBitpayAddress,\n  toCashAddress: toCashAddress,\n  isLegacyAddress: isLegacyAddress,\n  isBitpayAddress: isBitpayAddress,\n  isCashAddress: isCashAddress,\n  isMainnetAddress: isMainnetAddress,\n  isTestnetAddress: isTestnetAddress,\n  isP2PKHAddress: isP2PKHAddress,\n  isP2SHAddress: isP2SHAddress,\n  InvalidAddressError: InvalidAddressError\n}\n","var bigInt = (function (undefined) {\r\n    \"use strict\";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        LOG_MAX_INT = Math.log(MAX_INT);\r\n\r\n    function Integer(v, radix) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 ? parseValue(v) : parseBase(v, radix);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a, b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n        if (isPrecise(a.value * this.value)) {\r\n            return new SmallInteger(a.value * this.value);\r\n        }\r\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n        if (a.value === 0) return Integer[0];\r\n        if (a.value === 1) return this;\r\n        if (a.value === -1) return this.negate();\r\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    function square(a) {\r\n        //console.assert(2 * BASE * BASE < MAX_INT);\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            carry = 0 - a_i * a_i;\r\n            for (var j = i; j < l; j++) {\r\n                a_j = a[j];\r\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n            }\r\n            r[i + l] = carry;\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        var value = n.value;\r\n        if (value === 0) return false;\r\n        if (value === 1) return true;\r\n        if (value === 2) return this.isEven();\r\n        return this.mod(n).equals(Integer[0]);\r\n    };\r\n    SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(49)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n    \r\n    function millerRabinTest(n, a) {\r\n        var nPrev = n.prev(),\r\n            b = nPrev,\r\n            r = 0,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2), r++;\r\n        next : for (i = 0; i < a.length; i++) {\r\n            if (n.lesser(a[i])) continue;\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.equals(Integer[1]) || x.equals(nPrev)) continue;\r\n            for (d = r - 1; d != 0; d--) {\r\n                x = x.square().mod(n);\r\n                if (x.isUnit()) return false;    \r\n                if (x.equals(nPrev)) continue next;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n// Set \"strict\" to true to force GRH-supported lower bound of 2*log(N)^2\r\n    BigInteger.prototype.isPrime = function (strict) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var bits = n.bitLength();\r\n        if(bits <= 64)\r\n            return millerRabinTest(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022]);\r\n        var logN = Math.log(2) * bits;\r\n        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt(i + 2));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt.randBetween(2, n.minus(2)));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.equals(bigInt.zero)) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.equals(1)) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return ((typeof n === \"number\" || typeof n === \"string\") && +Math.abs(n) <= BASE) ||\r\n            (n instanceof BigInteger && n.value.length <= 1);\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (n) {\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        n = +n;\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        if (result.isZero()) return result;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (n) {\r\n        var remQuo;\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        n = +n;\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value, x = typeof v === \"number\" ? v | LOBMASK_I : v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function integerLogarithm(value, base) {\r\n        if (base.compareTo(value) <= 0) {\r\n            var tmp = integerLogarithm(value, base.square(base));\r\n            var p = tmp.p;\r\n            var e = tmp.e;\r\n            var t = p.multiply(base);\r\n            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };\r\n        }\r\n        return { p: bigInt(1), e: 0 };\r\n    }\r\n\r\n    BigInteger.prototype.bitLength = function () {\r\n        var n = this;\r\n        if (n.compareTo(bigInt(0)) < 0) {\r\n            n = n.negate().subtract(bigInt(1));\r\n        }\r\n        if (n.compareTo(bigInt(0)) === 0) {\r\n            return bigInt(0);\r\n        }\r\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\r\n    }\r\n    SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = Math.min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(Math.random() * range));\r\n        var length = range.value.length - 1;\r\n        var result = [], restricted = true;\r\n        for (var i = length; i >= 0; i--) {\r\n            var top = restricted ? range.value[i] : BASE;\r\n            var digit = truncate(Math.random() * top);\r\n            result.unshift(digit);\r\n            if (digit < top) restricted = false;\r\n        }\r\n        result = arrayToSmall(result);\r\n        return low.add(typeof result === \"number\" ? new SmallInteger(result) : new BigInteger(result, false));\r\n    }\r\n    var parseBase = function (text, base) {\r\n        var length = text.length;\r\n        var i;\r\n        var absBase = Math.abs(base);\r\n        for (var i = 0; i < length; i++) {\r\n            var c = text[i].toLowerCase();\r\n            if (c === \"-\") continue;\r\n            if (/[a-z0-9]/.test(c)) {\r\n                if (/[0-9]/.test(c) && +c >= absBase) {\r\n                    if (c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                } else if (c.charCodeAt(0) - 87 >= absBase) {\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                }\r\n            }\r\n        }\r\n        if (2 <= base && base <= 36) {\r\n            if (length <= LOG_MAX_INT / Math.log(base)) {\r\n                var result = parseInt(text, base);\r\n                if (isNaN(result)) {\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                }\r\n                return new SmallInteger(parseInt(text, base));\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i].toLowerCase(),\r\n                charCode = c.charCodeAt(0);\r\n            if (48 <= charCode && charCode <= 57) digits.push(parseValue(c));\r\n            else if (97 <= charCode && charCode <= 122) digits.push(parseValue(c.charCodeAt(0) - 87));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\");\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit) {\r\n        if (digit <= 35) {\r\n            return \"0123456789abcdefghijklmnopqrstuvwxyz\".charAt(digit);\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            if (n.isNegative())\r\n                return {\r\n                    value: [].concat.apply([], Array.apply(null, Array(-n))\r\n                        .map(Array.prototype.valueOf, [1, 0])\r\n                    ),\r\n                    isNegative: false\r\n                };\r\n\r\n            var arr = Array.apply(null, Array(+n - 1))\r\n                .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n                value: [].concat.apply([], arr),\r\n                isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.equals(1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n\r\n            return {\r\n                value: Array.apply(null, Array(+n))\r\n                    .map(Number.prototype.valueOf, 1),\r\n                isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return { value: out.reverse(), isNegative: neg };\r\n    }\r\n\r\n    function toBaseString(n, base) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(stringify).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10) return toBaseString(this, radix);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10) return toBaseString(this, radix);\r\n        return String(this.value);\r\n    };\r\n    BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); }\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n\r\n    function parseStringValue(v) {\r\n        if (isPrecise(+v)) {\r\n            var x = +v;\r\n            if (x === truncate(x))\r\n                return new SmallInteger(x);\r\n            throw new Error(\"Invalid integer: \" + v);\r\n        }\r\n        var sign = v[0] === \"-\";\r\n        if (sign) v = v.slice(1);\r\n        var split = v.split(/e/i);\r\n        if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n        if (split.length === 2) {\r\n            var exp = split[1];\r\n            if (exp[0] === \"+\") exp = exp.slice(1);\r\n            exp = +exp;\r\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n            var text = split[0];\r\n            var decimalPlace = text.indexOf(\".\");\r\n            if (decimalPlace >= 0) {\r\n                exp -= text.length - decimalPlace - 1;\r\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n            }\r\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n            text += (new Array(exp + 1)).join(\"0\");\r\n            v = text;\r\n        }\r\n        var isValid = /^([0-9][0-9]*)$/.test(v);\r\n        if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n        while (max > 0) {\r\n            r.push(+v.slice(min, max));\r\n            min -= l;\r\n            if (min < 0) min = 0;\r\n            max -= l;\r\n        }\r\n        trim(r);\r\n        return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = new SmallInteger(i);\r\n        if (i > 0) Integer[-i] = new SmallInteger(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif (typeof define === \"function\" && define.amd) {\r\n    define(\"big-integer\", [], function () {\r\n        return bigInt;\r\n    });\r\n}\r\n","/**\n * @license\n * https://github.com/ealmansi/cashaddrjs\n * Copyright (c) 2017-2020 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\n\n'use strict';\n\nvar validate = require('./validation').validate;\n\n/**\n * Base32 encoding and decoding.\n *\n * @module base32\n */\n\n/**\n * Charset containing the 32 symbols used in the base32 encoding.\n * @private\n */\nvar CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\n\n/**\n * Inverted index mapping each symbol into its index within the charset.\n * @private\n */\nvar CHARSET_INVERSE_INDEX = {\n  'q': 0, 'p': 1, 'z': 2, 'r': 3, 'y': 4, '9': 5, 'x': 6, '8': 7,\n  'g': 8, 'f': 9, '2': 10, 't': 11, 'v': 12, 'd': 13, 'w': 14, '0': 15,\n  's': 16, '3': 17, 'j': 18, 'n': 19, '5': 20, '4': 21, 'k': 22, 'h': 23,\n  'c': 24, 'e': 25, '6': 26, 'm': 27, 'u': 28, 'a': 29, '7': 30, 'l': 31,\n};\n\n/**\n * Encodes the given array of 5-bit integers as a base32-encoded string.\n *\n * @static\n * @param {Uint8Array} data Array of integers between 0 and 31 inclusive.\n * @returns {string}\n * @throws {ValidationError}\n */\nfunction encode(data) {\n  validate(data instanceof Uint8Array, 'Invalid data: ' + data + '.');\n  var base32 = '';\n  for (var i = 0; i < data.length; ++i) {\n    var value = data[i];\n    validate(0 <= value && value < 32, 'Invalid value: ' + value + '.');\n    base32 += CHARSET[value];\n  }\n  return base32;\n}\n\n/**\n * Decodes the given base32-encoded string into an array of 5-bit integers.\n *\n * @static\n * @param {string} string\n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\nfunction decode(string) {\n  validate(typeof string === 'string', 'Invalid base32-encoded string: ' + string + '.');\n  var data = new Uint8Array(string.length);\n  for (var i = 0; i < string.length; ++i) {\n    var value = string[i];\n    validate(value in CHARSET_INVERSE_INDEX, 'Invalid value: ' + value + '.');\n    data[i] = CHARSET_INVERSE_INDEX[value];\n  }\n  return data;\n}\n\nmodule.exports = {\n  encode: encode,\n  decode: decode,\n};\n","/**\n * @license\n * https://github.com/ealmansi/cashaddrjs\n * Copyright (c) 2017-2020 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\n\n'use strict';\n\nvar base32 = require('./base32');\nvar bigInt = require('big-integer');\nvar convertBits = require('./convertBits');\nvar validation = require('./validation');\nvar validate = validation.validate;\n\n/**\n * Encoding and decoding of the new Cash Address format for Bitcoin Cash. <br />\n * Compliant with the original cashaddr specification:\n * {@link https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md}\n * @module cashaddr\n */\n\n/**\n * Encodes a hash from a given type into a Bitcoin Cash address with the given prefix.\n * \n * @static\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @param {string} type Type of address to generate. Either 'P2PKH' or 'P2SH'.\n * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.\n * @returns {string}\n * @throws {ValidationError}\n */\nfunction encode(prefix, type, hash) {\n  validate(typeof prefix === 'string' && isValidPrefix(prefix), 'Invalid prefix: ' + prefix + '.');\n  validate(typeof type === 'string', 'Invalid type: ' + type + '.');\n  validate(hash instanceof Uint8Array, 'Invalid hash: ' + hash + '.');\n  var prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n  var versionByte = getTypeBits(type) + getHashSizeBits(hash);\n  var payloadData = toUint5Array(concat(new Uint8Array([versionByte]), hash));\n  var checksumData = concat(concat(prefixData, payloadData), new Uint8Array(8));\n  var payload = concat(payloadData, checksumToUint5Array(polymod(checksumData)));\n  return prefix + ':' + base32.encode(payload);\n}\n\n/**\n * Decodes the given address into its constituting prefix, type and hash. See [#encode()]{@link encode}.\n * \n * @static\n * @param {string} address Address to decode. E.g.: 'bitcoincash:qpm2qsznhks23z7629mms6s4cwef74vcwvy22gdx6a'.\n * @returns {object}\n * @throws {ValidationError}\n */\nfunction decode(address) {\n  validate(typeof address === 'string' && hasSingleCase(address), 'Invalid address: ' + address + '.');\n  var pieces = address.toLowerCase().split(':');\n  validate(pieces.length === 2, 'Missing prefix: ' + address + '.');\n  var prefix = pieces[0];\n  var payload = base32.decode(pieces[1]);\n  validate(validChecksum(prefix, payload), 'Invalid checksum: ' + address + '.');\n  var payloadData = fromUint5Array(payload.subarray(0, -8));\n  var versionByte = payloadData[0];\n  var hash = payloadData.subarray(1);\n  validate(getHashSize(versionByte) === hash.length * 8, 'Invalid hash size: ' + address + '.');\n  var type = getType(versionByte);\n  return {\n    prefix: prefix,\n    type: type,\n    hash: hash,\n  };\n}\n\n/**\n * Error thrown when encoding or decoding fail due to invalid input.\n *\n * @constructor ValidationError\n * @param {string} message Error description.\n */\nvar ValidationError = validation.ValidationError;\n\n/**\n * Valid address prefixes.\n *\n * @private\n */\nvar VALID_PREFIXES = ['bitcoincash', 'bchtest', 'bchreg'];\n\n/**\n * Checks whether a string is a valid prefix; ie., it has a single letter case\n * and is one of 'bitcoincash', 'bchtest', or 'bchreg'.\n *\n * @private\n * @param {string} prefix \n * @returns {boolean}\n */\nfunction isValidPrefix(prefix) {\n  return hasSingleCase(prefix) && VALID_PREFIXES.indexOf(prefix.toLowerCase()) !== -1;\n}\n\n/**\n * Derives an array from the given prefix to be used in the computation\n * of the address' checksum.\n *\n * @private\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'. \n * @returns {Uint8Array}\n */\nfunction prefixToUint5Array(prefix) {\n  var result = new Uint8Array(prefix.length);\n  for (var i = 0; i < prefix.length; ++i) {\n    result[i] = prefix[i].charCodeAt(0) & 31;\n  }\n  return result;\n}\n\n/**\n * Returns an array representation of the given checksum to be encoded\n * within the address' payload.\n *\n * @private\n * @param {BigInteger} checksum Computed checksum.\n * @returns {Uint8Array}\n */\nfunction checksumToUint5Array(checksum) {\n  var result = new Uint8Array(8);\n  for (var i = 0; i < 8; ++i) {\n    result[7 - i] = checksum.and(31).toJSNumber();\n    checksum = checksum.shiftRight(5);\n  }\n  return result;\n}\n\n/**\n * Returns the bit representation of the given type within the version\n * byte.\n *\n * @private\n * @param {string} type Address type. Either 'P2PKH' or 'P2SH'.\n * @returns {number}\n * @throws {ValidationError}\n */\nfunction getTypeBits(type) {\n  switch (type) {\n  case 'P2PKH':\n    return 0;\n  case 'P2SH':\n    return 8;\n  default:\n    throw new ValidationError('Invalid type: ' + type + '.');\n  }\n}\n\n/**\n * Retrieves the address type from its bit representation within the\n * version byte.\n *\n * @private\n * @param {number} versionByte\n * @returns {string}\n * @throws {ValidationError}\n */\nfunction getType(versionByte) {\n  switch (versionByte & 120) {\n  case 0:\n    return 'P2PKH';\n  case 8:\n    return 'P2SH';\n  default:\n    throw new ValidationError('Invalid address type in version byte: ' + versionByte + '.');\n  }\n}\n\n/**\n * Returns the bit representation of the length in bits of the given\n * hash within the version byte.\n *\n * @private\n * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.\n * @returns {number}\n * @throws {ValidationError}\n */\nfunction getHashSizeBits(hash) {\n  switch (hash.length * 8) {\n  case 160:\n    return 0;\n  case 192:\n    return 1;\n  case 224:\n    return 2;\n  case 256:\n    return 3;\n  case 320:\n    return 4;\n  case 384:\n    return 5;\n  case 448:\n    return 6;\n  case 512:\n    return 7;\n  default:\n    throw new ValidationError('Invalid hash size: ' + hash.length + '.');\n  }\n}\n\n/**\n * Retrieves the the length in bits of the encoded hash from its bit\n * representation within the version byte.\n *\n * @private\n * @param {number} versionByte\n * @returns {number}\n */\nfunction getHashSize(versionByte) {\n  switch (versionByte & 7) {\n  case 0:\n    return 160;\n  case 1:\n    return 192;\n  case 2:\n    return 224;\n  case 3:\n    return 256;\n  case 4:\n    return 320;\n  case 5:\n    return 384;\n  case 6:\n    return 448;\n  case 7:\n    return 512;\n  }\n}\n\n/**\n * Converts an array of 8-bit integers into an array of 5-bit integers,\n * right-padding with zeroes if necessary.\n *\n * @private\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n */\nfunction toUint5Array(data) {\n  return convertBits(data, 8, 5);\n}\n\n/**\n * Converts an array of 5-bit integers back into an array of 8-bit integers,\n * removing extra zeroes left from padding if necessary.\n * Throws a {@link ValidationError} if input is not a zero-padded array of 8-bit integers.\n *\n * @private\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\nfunction fromUint5Array(data) {\n  return convertBits(data, 5, 8, true);\n}\n\n/**\n * Returns the concatenation a and b.\n *\n * @private\n * @param {Uint8Array} a \n * @param {Uint8Array} b \n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\nfunction concat(a, b) {\n  var ab = new Uint8Array(a.length + b.length);\n  ab.set(a);\n  ab.set(b, a.length);\n  return ab;\n}\n\n/**\n * Computes a checksum from the given input data as specified for the CashAddr\n * format: https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md.\n *\n * @private\n * @param {Uint8Array} data Array of 5-bit integers over which the checksum is to be computed.\n * @returns {BigInteger}\n */\nfunction polymod(data) {\n  var GENERATOR = [0x98f2bc8e61, 0x79b76d99e2, 0xf33e5fb3c4, 0xae2eabe2a8, 0x1e4f43e470];\n  var checksum = bigInt(1);\n  for (var i = 0; i < data.length; ++i) {\n    var value = data[i];\n    var topBits = checksum.shiftRight(35);\n    checksum = checksum.and(0x07ffffffff).shiftLeft(5).xor(value);\n    for (var j = 0; j < GENERATOR.length; ++j) {\n      if (topBits.shiftRight(j).and(1).equals(1)) {\n        checksum = checksum.xor(GENERATOR[j]);\n      }\n    }\n  }\n  return checksum.xor(1);\n}\n\n/**\n * Verify that the payload has not been corrupted by checking that the\n * checksum is valid.\n * \n * @private\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @param {Uint8Array} payload Array of 5-bit integers containing the address' payload.\n * @returns {boolean}\n */\nfunction validChecksum(prefix, payload) {\n  var prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n  var checksumData = concat(prefixData, payload);\n  return polymod(checksumData).equals(0);\n}\n\n/**\n * Returns true if, and only if, the given string contains either uppercase\n * or lowercase letters, but not both.\n *\n * @private\n * @param {string} string Input string.\n * @returns {boolean}\n */\nfunction hasSingleCase(string) {\n  return string === string.toLowerCase() || string === string.toUpperCase();\n}\n\nmodule.exports = {\n  encode: encode,\n  decode: decode,\n  ValidationError: ValidationError,\n};\n","// Copyright (c) 2017-2018 Emilio Almansi\n// Copyright (c) 2017 Pieter Wuille\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar validate = require('./validation').validate;\n\n/**\n * Converts an array of integers made up of 'from' bits into an\n * array of integers made up of 'to' bits. The output array is\n * zero-padded if necessary, unless strict mode is true.\n * Throws a {@link ValidationError} if input is invalid.\n * Original by Pieter Wuille: https://github.com/sipa/bech32.\n *\n * @param {Uint8Array} data Array of integers made up of 'from' bits.\n * @param {number} from Length in bits of elements in the input array.\n * @param {number} to Length in bits of elements in the output array.\n * @param {bool} strictMode Require the conversion to be completed without padding.\n * @returns {Uint8Array}\n */\nmodule.exports = function(data, from, to, strictMode) {\n  var length = strictMode\n    ? Math.floor(data.length * from / to)\n    : Math.ceil(data.length * from / to);\n  var mask = (1 << to) - 1;\n  var result = new Uint8Array(length);\n  var index = 0;\n  var accumulator = 0;\n  var bits = 0;\n  for (var i = 0; i < data.length; ++i) {\n    var value = data[i];\n    validate(0 <= value && (value >> from) === 0, 'Invalid value: ' + value + '.');\n    accumulator = (accumulator << from) | value;\n    bits += from;\n    while (bits >= to) {\n      bits -= to;\n      result[index] = (accumulator >> bits) & mask;\n      ++index;\n    }\n  }\n  if (!strictMode) {\n    if (bits > 0) {\n      result[index] = (accumulator << (to - bits)) & mask;\n      ++index;\n    }\n  } else {\n    validate(\n      bits < from && ((accumulator << (to - bits)) & mask) === 0,\n      'Input cannot be converted to ' + to + ' bits without padding, but strict mode was used.'\n    );\n  }\n  return result;\n};\n","/**\n * @license\n * https://github.com/ealmansi/cashaddrjs\n * Copyright (c) 2017-2020 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\n\n'use strict';\n\n/**\n * Validation utility.\n *\n * @module validation\n */\n\n/**\n * Error thrown when encoding or decoding fail due to invalid input.\n *\n * @constructor ValidationError\n * @param {string} message Error description.\n */\nfunction ValidationError(message) {\n  var error = new Error();\n  this.name = error.name = 'ValidationError';\n  this.message = error.message = message;\n  this.stack = error.stack;\n}\n\nValidationError.prototype = Object.create(Error.prototype);\n\n/**\n * Validates a given condition, throwing a {@link ValidationError} if\n * the given condition does not hold.\n *\n * @static\n * @param {boolean} condition Condition to validate.\n * @param {string} message Error message in case the condition does not hold.\n */\nfunction validate(condition, message) {\n  if (!condition) {\n    throw new ValidationError(message);\n  }\n}\n\nmodule.exports = {\n  ValidationError: ValidationError,\n  validate: validate,\n};\n","/**\n * @license\n * https://github.com/bitcoincashjs/cashaddr\n * Copyright (c) 2017-2018 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\n/**\n * Validation utility.\n *\n * @module validation\n */\n/**\n * Error thrown when encoding or decoding fail due to invalid input.\n *\n * @constructor ValidationError\n * @param {string} message Error description.\n */\nexport class ValidationError extends Error {\n  name = 'ValidationError';\n  constructor(message) {\n    super(message);\n    Object.setPrototypeOf(this, ValidationError.prototype);\n  }\n}\n/**\n * Validates a given condition, throwing a {@link ValidationError} if\n * the given condition does not hold.\n *\n * @static\n * @param {boolean} condition Condition to validate.\n * @param {string} message Error message in case the condition does not hold.\n */\nexport function validate(condition, message) {\n  if (!condition) {\n    throw new ValidationError(message);\n  }\n}\n","/**\n * @license\n * https://github.com/bitcoincashjs/cashaddr\n * Copyright (c) 2017-2018 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\nimport { validate } from './validation';\n/**\n * Base32 encoding and decoding.\n *\n * @module base32\n */\n/**\n * Charset containing the 32 symbols used in the base32 encoding.\n * @private\n */\nconst CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\n/**\n * Inverted index mapping each symbol into its index within the charset.\n * @private\n */\nconst CHARSET_INVERSE_INDEX = {\n  q: 0,\n  p: 1,\n  z: 2,\n  r: 3,\n  y: 4,\n  9: 5,\n  x: 6,\n  8: 7,\n  g: 8,\n  f: 9,\n  2: 10,\n  t: 11,\n  v: 12,\n  d: 13,\n  w: 14,\n  0: 15,\n  s: 16,\n  3: 17,\n  j: 18,\n  n: 19,\n  5: 20,\n  4: 21,\n  k: 22,\n  h: 23,\n  c: 24,\n  e: 25,\n  6: 26,\n  m: 27,\n  u: 28,\n  a: 29,\n  7: 30,\n  l: 31,\n};\n/**\n * Encodes the given array of 5-bit integers as a base32-encoded string.\n *\n * @static\n * @param {Uint8Array} data Array of integers between 0 and 31 inclusive.\n * @returns {string}\n * @throws {ValidationError}\n */\nexport function encode(data) {\n  validate(data instanceof Uint8Array, 'Invalid data: ' + data + '.');\n  let base32 = '';\n  for (const value of data) {\n    validate(0 <= value && value < 32, 'Invalid value: ' + value + '.');\n    base32 += CHARSET[value];\n  }\n  return base32;\n}\n/**\n * Decodes the given base32-encoded string into an array of 5-bit integers.\n *\n * @static\n * @param {string} string\n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\nexport function decode(strng) {\n  validate(\n    typeof strng === 'string',\n    'Invalid base32-encoded string: ' + strng + '.',\n  );\n  const data = new Uint8Array(strng.length);\n  for (let i = 0; i < strng.length; ++i) {\n    const value = strng[i];\n    validate(value in CHARSET_INVERSE_INDEX, 'Invalid value: ' + value + '.');\n    data[i] = CHARSET_INVERSE_INDEX[value];\n  }\n  return data;\n}\n","/**\n * @license\n * https://github.com/bitcoincashjs/cashaddr\n * Copyright (c) 2017-2018 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\n// @ts-ignore\nimport bigInt from 'big-integer';\nimport * as base32 from './base32';\nimport { convertBits } from './convertBits';\nimport * as validation from './validation';\nconst validate = validation.validate;\n/**\n * Encoding and decoding of the new Cash Address format for Bitcoin Cash. <br />\n * Compliant with the original cashaddr specification:\n * {@link https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md}\n * @module cashaddr\n */\n/**\n * Encodes a hash from a given type into a Bitcoin Cash address with the given prefix.\n *\n * @static\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @param {string} type Type of address to generate. Either 'P2PKH' or 'P2SH'.\n * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.\n * @returns {string}\n * @throws {ValidationError}\n */\nexport function encode(prefix, type, hash) {\n  validate(\n    typeof prefix === 'string' && isValidPrefix(prefix),\n    'Invalid prefix: ' + prefix + '.',\n  );\n  validate(typeof type === 'string', 'Invalid type: ' + type + '.');\n  validate(hash instanceof Uint8Array, 'Invalid hash: ' + hash + '.');\n  const prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n  const versionByte = getTypeBits(type) + getHashSizeBits(hash);\n  const payloadData = toUint5Array(concat(new Uint8Array([versionByte]), hash));\n  const checksumData = concat(\n    concat(prefixData, payloadData),\n    new Uint8Array(8),\n  );\n  const payload = concat(\n    payloadData,\n    checksumToUint5Array(polymod(checksumData)),\n  );\n  return prefix + ':' + base32.encode(payload);\n}\n/**\n * Decodes the given address into its constituting prefix, type and hash. See [#encode()]{@link encode}.\n *\n * @static\n * @param {string} address Address to decode. E.g.: 'bitcoincash:qpm2qsznhks23z7629mms6s4cwef74vcwvy22gdx6a'.\n * @returns {object}\n * @throws {ValidationError}\n */\nexport function decode(address) {\n  validate(\n    typeof address === 'string' && hasSingleCase(address),\n    'Invalid address: ' + address + '.',\n  );\n  const pieces = address.toLowerCase().split(':');\n  validate(pieces.length === 2, 'Missing prefix: ' + address + '.');\n  const prefix = pieces[0];\n  const payload = base32.decode(pieces[1]);\n  validate(\n    validChecksum(prefix, payload),\n    'Invalid checksum: ' + address + '.',\n  );\n  const payloadData = fromUint5Array(payload.subarray(0, -8));\n  const versionByte = payloadData[0];\n  const hash = payloadData.subarray(1);\n  validate(\n    getHashSize(versionByte) === hash.length * 8,\n    'Invalid hash size: ' + address + '.',\n  );\n  const type = getType(versionByte);\n  return {\n    prefix,\n    type,\n    hash,\n  };\n}\n/**\n * Error thrown when encoding or decoding fail due to invalid input.\n *\n * @constructor ValidationError\n * @param {string} message Error description.\n */\nexport const ValidationError = validation.ValidationError;\n/**\n * Valid address prefixes.\n *\n * @private\n */\nexport const VALID_PREFIXES = ['bitcoincash', 'bchtest', 'bchreg'];\n/**\n * Checks whether a string is a valid prefix; ie., it has a single letter case\n * and is one of 'bitcoincash', 'bchtest', or 'bchreg'.\n *\n * @private\n * @param {string} prefix\n * @returns {boolean}\n */\nfunction isValidPrefix(prefix) {\n  return (\n    hasSingleCase(prefix) && VALID_PREFIXES.indexOf(prefix.toLowerCase()) !== -1\n  );\n}\n/**\n * Derives an array from the given prefix to be used in the computation\n * of the address' checksum.\n *\n * @private\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @returns {Uint8Array}\n */\nfunction prefixToUint5Array(prefix) {\n  const result = new Uint8Array(prefix.length);\n  for (let i = 0; i < prefix.length; ++i) {\n    result[i] = prefix[i].charCodeAt(0) & 31;\n  }\n  return result;\n}\n/**\n * Returns an array representation of the given checksum to be encoded\n * within the address' payload.\n *\n * @private\n * @param {BigInteger} checksum Computed checksum.\n * @returns {Uint8Array}\n */\nfunction checksumToUint5Array(checksum) {\n  const result = new Uint8Array(8);\n  for (let i = 0; i < 8; ++i) {\n    result[7 - i] = checksum.and(31).toJSNumber();\n    checksum = checksum.shiftRight(5);\n  }\n  return result;\n}\n/**\n * Returns the bit representation of the given type within the version\n * byte.\n *\n * @private\n * @param {string} type Address type. Either 'P2PKH' or 'P2SH'.\n * @returns {number}\n * @throws {ValidationError}\n */\nfunction getTypeBits(type) {\n  switch (type) {\n    case 'P2PKH':\n      return 0;\n    case 'P2SH':\n      return 8;\n    default:\n      throw new ValidationError('Invalid type: ' + type + '.');\n  }\n}\n/**\n * Retrieves the address type from its bit representation within the\n * version byte.\n *\n * @private\n * @param {number} versionByte\n * @returns {string}\n * @throws {ValidationError}\n */\nfunction getType(versionByte) {\n  switch (versionByte & 0x78) {\n    case 0:\n      return 'P2PKH';\n    case 8:\n      return 'P2SH';\n    default:\n      throw new ValidationError(\n        'Invalid address type in version byte: ' + versionByte + '.',\n      );\n  }\n}\n/**\n * Returns the bit representation of the length in bits of the given\n * hash within the version byte.\n *\n * @private\n * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.\n * @returns {number}\n * @throws {ValidationError}\n */\nfunction getHashSizeBits(hash) {\n  switch (hash.length * 8) {\n    case 160:\n      return 0;\n    case 192:\n      return 1;\n    case 224:\n      return 2;\n    case 256:\n      return 3;\n    case 320:\n      return 4;\n    case 384:\n      return 5;\n    case 448:\n      return 6;\n    case 512:\n      return 7;\n    default:\n      throw new ValidationError('Invalid hash size: ' + hash.length + '.');\n  }\n}\n/**\n * Retrieves the the length in bits of the encoded hash from its bit\n * representation within the version byte.\n *\n * @private\n * @param {number} versionByte\n * @returns {number}\n * @throws {ValidationError}\n */\nfunction getHashSize(versionByte) {\n  switch (versionByte & 7) {\n    case 0:\n      return 160;\n    case 1:\n      return 192;\n    case 2:\n      return 224;\n    case 3:\n      return 256;\n    case 4:\n      return 320;\n    case 5:\n      return 384;\n    case 6:\n      return 448;\n    case 7:\n      return 512;\n    default:\n      throw new ValidationError(\n        'Invalid versionByte: ' + (versionByte & 7) + '.',\n      );\n  }\n}\n/**\n * Converts an array of 8-bit integers into an array of 5-bit integers,\n * right-padding with zeroes if necessary.\n *\n * @private\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n */\nfunction toUint5Array(data) {\n  return convertBits(data, 8, 5);\n}\n/**\n * Converts an array of 5-bit integers back into an array of 8-bit integers,\n * removing extra zeroes left from padding if necessary.\n * Throws a {@link ValidationError} if input is not a zero-padded array of 8-bit integers.\n *\n * @private\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\nfunction fromUint5Array(data) {\n  return convertBits(data, 5, 8, true);\n}\n/**\n * Returns the concatenation a and b.\n *\n * @private\n * @param {Uint8Array} a\n * @param {Uint8Array} b\n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\nfunction concat(a, b) {\n  const ab = new Uint8Array(a.length + b.length);\n  ab.set(a);\n  ab.set(b, a.length);\n  return ab;\n}\n/**\n * Computes a checksum from the given input data as specified for the CashAddr\n * format: https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md.\n *\n * @private\n * @param {Uint8Array} data Array of 5-bit integers over which the checksum is to be computed.\n * @returns {BigInteger}\n */\nfunction polymod(data) {\n  const GENERATOR = [\n    0x98f2bc8e61, 0x79b76d99e2, 0xf33e5fb3c4, 0xae2eabe2a8, 0x1e4f43e470,\n  ];\n  let checksum = bigInt(1);\n  for (const value of data) {\n    const topBits = checksum.shiftRight(35);\n    checksum = checksum.and(0x07ffffffff).shiftLeft(5).xor(value);\n    for (let j = 0; j < GENERATOR.length; ++j) {\n      if (topBits.shiftRight(j).and(1).equals(1)) {\n        checksum = checksum.xor(GENERATOR[j]);\n      }\n    }\n  }\n  return checksum.xor(1);\n}\n/**\n * Verify that the payload has not been corrupted by checking that the\n * checksum is valid.\n *\n * @private\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @param {Uint8Array} payload Array of 5-bit integers containing the address' payload.\n * @returns {boolean}\n */\nfunction validChecksum(prefix, payload) {\n  const prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n  const checksumData = concat(prefixData, payload);\n  return polymod(checksumData).equals(0);\n}\n/**\n * Returns true if, and only if, the given string contains either uppercase\n * or lowercase letters, but not both.\n *\n * @private\n * @param {string} string Input string.\n * @returns {boolean}\n */\nfunction hasSingleCase(strng) {\n  return strng === strng.toLowerCase() || strng === strng.toUpperCase();\n}\n","// Copyright (c) 2017-2018 Emilio Almansi\n// Copyright (c) 2017 Pieter Wuille\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { validate } from './validation';\n/**\n * Converts an array of integers made up of 'from' bits into an\n * array of integers made up of 'to' bits. The output array is\n * zero-padded if necessary, unless strict mode is true.\n * Throws a {@link ValidationError} if input is invalid.\n * Original by Pieter Wuille: https://github.com/sipa/bech32.\n *\n * @param {Uint8Array} data Array of integers made up of 'from' bits.\n * @param {number} from Length in bits of elements in the input array.\n * @param {number} to Length in bits of elements in the output array.\n * @param {bool} strictMode Require the conversion to be completed without padding.\n * @returns {Uint8Array}\n */\nexport function convertBits(data, from, to, strictMode) {\n  const length = strictMode\n    ? Math.floor((data.length * from) / to)\n    : Math.ceil((data.length * from) / to);\n  const mask = (1 << to) - 1;\n  const result = new Uint8Array(length);\n  let index = 0;\n  let accumulator = 0;\n  let bits = 0;\n  for (const value of data) {\n    validate(\n      0 <= value && value >> from === 0,\n      'Invalid value: ' + value + '.',\n    );\n    accumulator = (accumulator << from) | value;\n    bits += from;\n    while (bits >= to) {\n      bits -= to;\n      result[index] = (accumulator >> bits) & mask;\n      ++index;\n    }\n  }\n  if (!strictMode) {\n    if (bits > 0) {\n      result[index] = (accumulator << (to - bits)) & mask;\n      ++index;\n    }\n  } else {\n    validate(\n      bits < from && ((accumulator << (to - bits)) & mask) === 0,\n      'Input cannot be converted to ' +\n        to +\n        ' bits without padding, but strict mode was used.',\n    );\n  }\n  return result;\n}\n","// https://en.bitcoin.it/wiki/List_of_address_prefixes\n// Dogecoin BIP32 is a proposed standard: https://bitcointalk.org/index.php?topic=409731\nexport const bitcoingold = {\n  messagePrefix: '\\x18Bitcoin Gold Signed Message:\\n',\n  bech32: 'btg',\n  bip32: {\n    public: 0x0488b21e,\n    private: 0x0488ade4,\n  },\n  pubKeyHash: 0x26,\n  scriptHash: 0x17,\n  wif: 0x80,\n};\n/**\n * Represents the Bitcoin network configuration.\n */\nexport const bitcoin = {\n  /**\n   * The message prefix used for signing Bitcoin messages.\n   */\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  /**\n   * The Bech32 prefix used for Bitcoin addresses.\n   */\n  bech32: 'bc',\n  /**\n   * The BIP32 key prefixes for Bitcoin.\n   */\n  bip32: {\n    /**\n     * The public key prefix for BIP32 extended public keys.\n     */\n    public: 0x0488b21e,\n    /**\n     * The private key prefix for BIP32 extended private keys.\n     */\n    private: 0x0488ade4,\n  },\n  /**\n   * The prefix for Bitcoin public key hashes.\n   */\n  pubKeyHash: 0x00,\n  /**\n   * The prefix for Bitcoin script hashes.\n   */\n  scriptHash: 0x05,\n  /**\n   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.\n   */\n  wif: 0x80,\n};\n/**\n * Represents the regtest network configuration.\n */\nexport const regtest = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bcrt',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n/**\n * Represents the testnet network configuration.\n */\nexport const testnet = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'tb',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n","// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki\n// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n// NOTE: SIGHASH byte ignored AND restricted, truncate before use\n/**\n * Checks if the given buffer is a valid BIP66-encoded signature.\n *\n * @param buffer - The buffer to check.\n * @returns A boolean indicating whether the buffer is a valid BIP66-encoded signature.\n */\nexport function check(buffer) {\n  if (buffer.length < 8) return false;\n  if (buffer.length > 72) return false;\n  if (buffer[0] !== 0x30) return false;\n  if (buffer[1] !== buffer.length - 2) return false;\n  if (buffer[2] !== 0x02) return false;\n  const lenR = buffer[3];\n  if (lenR === 0) return false;\n  if (5 + lenR >= buffer.length) return false;\n  if (buffer[4 + lenR] !== 0x02) return false;\n  const lenS = buffer[5 + lenR];\n  if (lenS === 0) return false;\n  if (6 + lenR + lenS !== buffer.length) return false;\n  if (buffer[4] & 0x80) return false;\n  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) return false;\n  if (buffer[lenR + 6] & 0x80) return false;\n  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n    return false;\n  return true;\n}\n/**\n * Decodes a DER-encoded signature buffer and returns the R and S values.\n * @param buffer - The DER-encoded signature buffer.\n * @returns An object containing the R and S values.\n * @throws {Error} If the DER sequence length is too short, too long, or invalid.\n * @throws {Error} If the R or S length is zero or invalid.\n * @throws {Error} If the R or S value is negative or excessively padded.\n */\nexport function decode(buffer) {\n  if (buffer.length < 8) throw new Error('DER sequence length is too short');\n  if (buffer.length > 72) throw new Error('DER sequence length is too long');\n  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence');\n  if (buffer[1] !== buffer.length - 2)\n    throw new Error('DER sequence length is invalid');\n  if (buffer[2] !== 0x02) throw new Error('Expected DER integer');\n  const lenR = buffer[3];\n  if (lenR === 0) throw new Error('R length is zero');\n  if (5 + lenR >= buffer.length) throw new Error('R length is too long');\n  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)');\n  const lenS = buffer[5 + lenR];\n  if (lenS === 0) throw new Error('S length is zero');\n  if (6 + lenR + lenS !== buffer.length) throw new Error('S length is invalid');\n  if (buffer[4] & 0x80) throw new Error('R value is negative');\n  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))\n    throw new Error('R value excessively padded');\n  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative');\n  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n    throw new Error('S value excessively padded');\n  // non-BIP66 - extract R, S values\n  return {\n    r: buffer.slice(4, 4 + lenR),\n    s: buffer.slice(6 + lenR),\n  };\n}\n/*\n * Expects r and s to be positive DER integers.\n *\n * The DER format uses the most significant bit as a sign bit (& 0x80).\n * If the significant bit is set AND the integer is positive, a 0x00 is prepended.\n *\n * Examples:\n *\n *      0 =>     0x00\n *      1 =>     0x01\n *     -1 =>     0xff\n *    127 =>     0x7f\n *   -127 =>     0x81\n *    128 =>   0x0080\n *   -128 =>     0x80\n *    255 =>   0x00ff\n *   -255 =>   0xff01\n *  16300 =>   0x3fac\n * -16300 =>   0xc054\n *  62300 => 0x00f35c\n * -62300 => 0xff0ca4\n */\nexport function encode(r, s) {\n  const lenR = r.length;\n  const lenS = s.length;\n  if (lenR === 0) throw new Error('R length is zero');\n  if (lenS === 0) throw new Error('S length is zero');\n  if (lenR > 33) throw new Error('R length is too long');\n  if (lenS > 33) throw new Error('S length is too long');\n  if (r[0] & 0x80) throw new Error('R value is negative');\n  if (s[0] & 0x80) throw new Error('S value is negative');\n  if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80))\n    throw new Error('R value excessively padded');\n  if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80))\n    throw new Error('S value excessively padded');\n  const signature = new Uint8Array(6 + lenR + lenS);\n  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n  signature[0] = 0x30;\n  signature[1] = signature.length - 2;\n  signature[2] = 0x02;\n  signature[3] = r.length;\n  signature.set(r, 4);\n  signature[4 + lenR] = 0x02;\n  signature[5 + lenR] = s.length;\n  signature.set(s, 6 + lenR);\n  return signature;\n}\n","const OPS = {\n  OP_FALSE: 0,\n  OP_0: 0,\n  OP_PUSHDATA1: 76,\n  OP_PUSHDATA2: 77,\n  OP_PUSHDATA4: 78,\n  OP_1NEGATE: 79,\n  OP_RESERVED: 80,\n  OP_TRUE: 81,\n  OP_1: 81,\n  OP_2: 82,\n  OP_3: 83,\n  OP_4: 84,\n  OP_5: 85,\n  OP_6: 86,\n  OP_7: 87,\n  OP_8: 88,\n  OP_9: 89,\n  OP_10: 90,\n  OP_11: 91,\n  OP_12: 92,\n  OP_13: 93,\n  OP_14: 94,\n  OP_15: 95,\n  OP_16: 96,\n  OP_NOP: 97,\n  OP_VER: 98,\n  OP_IF: 99,\n  OP_NOTIF: 100,\n  OP_VERIF: 101,\n  OP_VERNOTIF: 102,\n  OP_ELSE: 103,\n  OP_ENDIF: 104,\n  OP_VERIFY: 105,\n  OP_RETURN: 106,\n  OP_TOALTSTACK: 107,\n  OP_FROMALTSTACK: 108,\n  OP_2DROP: 109,\n  OP_2DUP: 110,\n  OP_3DUP: 111,\n  OP_2OVER: 112,\n  OP_2ROT: 113,\n  OP_2SWAP: 114,\n  OP_IFDUP: 115,\n  OP_DEPTH: 116,\n  OP_DROP: 117,\n  OP_DUP: 118,\n  OP_NIP: 119,\n  OP_OVER: 120,\n  OP_PICK: 121,\n  OP_ROLL: 122,\n  OP_ROT: 123,\n  OP_SWAP: 124,\n  OP_TUCK: 125,\n  OP_CAT: 126,\n  OP_SUBSTR: 127,\n  OP_LEFT: 128,\n  OP_RIGHT: 129,\n  OP_SIZE: 130,\n  OP_INVERT: 131,\n  OP_AND: 132,\n  OP_OR: 133,\n  OP_XOR: 134,\n  OP_EQUAL: 135,\n  OP_EQUALVERIFY: 136,\n  OP_RESERVED1: 137,\n  OP_RESERVED2: 138,\n  OP_1ADD: 139,\n  OP_1SUB: 140,\n  OP_2MUL: 141,\n  OP_2DIV: 142,\n  OP_NEGATE: 143,\n  OP_ABS: 144,\n  OP_NOT: 145,\n  OP_0NOTEQUAL: 146,\n  OP_ADD: 147,\n  OP_SUB: 148,\n  OP_MUL: 149,\n  OP_DIV: 150,\n  OP_MOD: 151,\n  OP_LSHIFT: 152,\n  OP_RSHIFT: 153,\n  OP_BOOLAND: 154,\n  OP_BOOLOR: 155,\n  OP_NUMEQUAL: 156,\n  OP_NUMEQUALVERIFY: 157,\n  OP_NUMNOTEQUAL: 158,\n  OP_LESSTHAN: 159,\n  OP_GREATERTHAN: 160,\n  OP_LESSTHANOREQUAL: 161,\n  OP_GREATERTHANOREQUAL: 162,\n  OP_MIN: 163,\n  OP_MAX: 164,\n  OP_WITHIN: 165,\n  OP_RIPEMD160: 166,\n  OP_SHA1: 167,\n  OP_SHA256: 168,\n  OP_HASH160: 169,\n  OP_HASH256: 170,\n  OP_CODESEPARATOR: 171,\n  OP_CHECKSIG: 172,\n  OP_CHECKSIGVERIFY: 173,\n  OP_CHECKMULTISIG: 174,\n  OP_CHECKMULTISIGVERIFY: 175,\n  OP_NOP1: 176,\n  OP_NOP2: 177,\n  OP_CHECKLOCKTIMEVERIFY: 177,\n  OP_NOP3: 178,\n  OP_CHECKSEQUENCEVERIFY: 178,\n  OP_NOP4: 179,\n  OP_NOP5: 180,\n  OP_NOP6: 181,\n  OP_NOP7: 182,\n  OP_NOP8: 183,\n  OP_NOP9: 184,\n  OP_NOP10: 185,\n  OP_CHECKSIGADD: 186,\n  OP_PUBKEYHASH: 253,\n  OP_PUBKEY: 254,\n  OP_INVALIDOPCODE: 255,\n};\nconst REVERSE_OPS = {};\nfor (const op of Object.keys(OPS)) {\n  const code = OPS[op];\n  REVERSE_OPS[code] = op;\n}\nexport { OPS, REVERSE_OPS };\n","import { OPS } from './ops.js';\nimport * as tools from 'uint8array-tools';\n/**\n * Calculates the encoding length of a number used for push data in Bitcoin transactions.\n * @param i The number to calculate the encoding length for.\n * @returns The encoding length of the number.\n */\nexport function encodingLength(i) {\n  return i < OPS.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;\n}\n/**\n * Encodes a number into a buffer using a variable-length encoding scheme.\n * The encoded buffer is written starting at the specified offset.\n * Returns the size of the encoded buffer.\n *\n * @param buffer - The buffer to write the encoded data into.\n * @param num - The number to encode.\n * @param offset - The offset at which to start writing the encoded buffer.\n * @returns The size of the encoded buffer.\n */\nexport function encode(buffer, num, offset) {\n  const size = encodingLength(num);\n  // ~6 bit\n  if (size === 1) {\n    tools.writeUInt8(buffer, offset, num);\n    // 8 bit\n  } else if (size === 2) {\n    tools.writeUInt8(buffer, offset, OPS.OP_PUSHDATA1);\n    tools.writeUInt8(buffer, offset + 1, num);\n    // 16 bit\n  } else if (size === 3) {\n    tools.writeUInt8(buffer, offset, OPS.OP_PUSHDATA2);\n    tools.writeUInt16(buffer, offset + 1, num, 'LE');\n    // 32 bit\n  } else {\n    tools.writeUInt8(buffer, offset, OPS.OP_PUSHDATA4);\n    tools.writeUInt32(buffer, offset + 1, num, 'LE');\n  }\n  return size;\n}\n/**\n * Decodes a buffer and returns information about the opcode, number, and size.\n * @param buffer - The buffer to decode.\n * @param offset - The offset within the buffer to start decoding.\n * @returns An object containing the opcode, number, and size, or null if decoding fails.\n */\nexport function decode(buffer, offset) {\n  const opcode = tools.readUInt8(buffer, offset);\n  let num;\n  let size;\n  // ~6 bit\n  if (opcode < OPS.OP_PUSHDATA1) {\n    num = opcode;\n    size = 1;\n    // 8 bit\n  } else if (opcode === OPS.OP_PUSHDATA1) {\n    if (offset + 2 > buffer.length) return null;\n    num = tools.readUInt8(buffer, offset + 1);\n    size = 2;\n    // 16 bit\n  } else if (opcode === OPS.OP_PUSHDATA2) {\n    if (offset + 3 > buffer.length) return null;\n    num = tools.readUInt16(buffer, offset + 1, 'LE');\n    size = 3;\n    // 32 bit\n  } else {\n    if (offset + 5 > buffer.length) return null;\n    if (opcode !== OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode');\n    num = tools.readUInt32(buffer, offset + 1, 'LE');\n    size = 5;\n  }\n  return {\n    opcode,\n    number: num,\n    size,\n  };\n}\n","import * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst ZERO32 = new Uint8Array(32);\nconst EC_P = tools.fromHex(\n  'fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f',\n);\nexport const NBufferSchemaFactory = size =>\n  v.pipe(v.instance(Uint8Array), v.length(size));\n/**\n * Checks if two arrays of Buffers are equal.\n * @param a - The first array of Buffers.\n * @param b - The second array of Buffers.\n * @returns True if the arrays are equal, false otherwise.\n */\nexport function stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return tools.compare(x, b[i]) === 0;\n  });\n}\n/**\n * Checks if the given value is a valid elliptic curve point.\n * @param p - The value to check.\n * @returns True if the value is a valid elliptic curve point, false otherwise.\n */\nexport function isPoint(p) {\n  if (!(p instanceof Uint8Array)) return false;\n  if (p.length < 33) return false;\n  const t = p[0];\n  const x = p.slice(1, 33);\n  if (tools.compare(ZERO32, x) === 0) return false;\n  if (tools.compare(x, EC_P) >= 0) return false;\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    return true;\n  }\n  const y = p.slice(33);\n  if (tools.compare(ZERO32, y) === 0) return false;\n  if (tools.compare(y, EC_P) >= 0) return false;\n  if (t === 0x04 && p.length === 65) return true;\n  return false;\n}\nexport const TAPLEAF_VERSION_MASK = 0xfe;\nexport function isTapleaf(o) {\n  if (!o || !('output' in o)) return false;\n  if (!(o.output instanceof Uint8Array)) return false;\n  if (o.version !== undefined)\n    return (o.version & TAPLEAF_VERSION_MASK) === o.version;\n  return true;\n}\nexport function isTaptree(scriptTree) {\n  if (!Array.isArray(scriptTree)) return isTapleaf(scriptTree);\n  if (scriptTree.length !== 2) return false;\n  return scriptTree.every(t => isTaptree(t));\n}\nexport const Buffer256bitSchema = NBufferSchemaFactory(32);\nexport const Hash160bitSchema = NBufferSchemaFactory(20);\nexport const Hash256bitSchema = NBufferSchemaFactory(32);\nexport const BufferSchema = v.instance(Uint8Array);\nexport const HexSchema = v.pipe(v.string(), v.regex(/^([0-9a-f]{2})+$/i));\nexport const UInt8Schema = v.pipe(\n  v.number(),\n  v.integer(),\n  v.minValue(0),\n  v.maxValue(0xff),\n);\nexport const UInt32Schema = v.pipe(\n  v.number(),\n  v.integer(),\n  v.minValue(0),\n  v.maxValue(0xffffffff),\n);\nexport const UInt53Schema = v.pipe(\n  v.number(),\n  v.integer(),\n  v.minValue(0),\n  v.maxValue(Number.MAX_SAFE_INTEGER),\n);\nexport const SatoshiSchema = v.pipe(\n  v.bigint(),\n  v.minValue(0n),\n  v.maxValue(0x7fffffffffffffffn),\n);\nexport const NullablePartial = a =>\n  v.object(\n    Object.entries(a).reduce(\n      (acc, next) => ({ ...acc, [next[0]]: v.nullish(next[1]) }),\n      {},\n    ),\n  );\n","import * as bip66 from './bip66.js';\nimport { isDefinedHashType } from './script.js';\nimport * as v from 'valibot';\nimport * as tools from 'uint8array-tools';\nimport { NBufferSchemaFactory, UInt8Schema } from './types.js';\nconst ZERO = new Uint8Array(1);\n/**\n * Converts a buffer to a DER-encoded buffer.\n * @param x - The buffer to be converted.\n * @returns The DER-encoded buffer.\n */\nfunction toDER(x) {\n  let i = 0;\n  while (x[i] === 0) ++i;\n  if (i === x.length) return ZERO;\n  x = x.slice(i);\n  if (x[0] & 0x80) return tools.concat([ZERO, x]);\n  return x;\n}\n/**\n * Converts a DER-encoded signature to a buffer.\n * If the first byte of the input buffer is 0x00, it is skipped.\n * The resulting buffer is 32 bytes long, filled with zeros if necessary.\n * @param x - The DER-encoded signature.\n * @returns The converted buffer.\n */\nfunction fromDER(x) {\n  if (x[0] === 0x00) x = x.slice(1);\n  const buffer = new Uint8Array(32);\n  const bstart = Math.max(0, 32 - x.length);\n  buffer.set(x, bstart);\n  return buffer;\n}\n// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\n/**\n * Decodes a buffer into a ScriptSignature object.\n * @param buffer - The buffer to decode.\n * @returns The decoded ScriptSignature object.\n * @throws Error if the hashType is invalid.\n */\nexport function decode(buffer) {\n  const hashType = tools.readUInt8(buffer, buffer.length - 1);\n  if (!isDefinedHashType(hashType)) {\n    throw new Error('Invalid hashType ' + hashType);\n  }\n  const decoded = bip66.decode(buffer.subarray(0, -1));\n  const r = fromDER(decoded.r);\n  const s = fromDER(decoded.s);\n  const signature = tools.concat([r, s]);\n  return { signature, hashType };\n}\n/**\n * Encodes a signature and hash type into a buffer.\n * @param signature - The signature to encode.\n * @param hashType - The hash type to encode.\n * @returns The encoded buffer.\n * @throws Error if the hashType is invalid.\n */\nexport function encode(signature, hashType) {\n  v.parse(\n    v.object({\n      signature: NBufferSchemaFactory(64),\n      hashType: UInt8Schema,\n    }),\n    { signature, hashType },\n  );\n  if (!isDefinedHashType(hashType)) {\n    throw new Error('Invalid hashType ' + hashType);\n  }\n  const hashTypeBuffer = new Uint8Array(1);\n  tools.writeUInt8(hashTypeBuffer, 0, hashType);\n  const r = toDER(signature.slice(0, 32));\n  const s = toDER(signature.slice(32, 64));\n  return tools.concat([bip66.encode(r, s), hashTypeBuffer]);\n}\n","/**\n * Script tools, including decompile, compile, toASM, fromASM, toStack, isCanonicalPubKey, isCanonicalScriptSignature\n * @packageDocumentation\n */\nimport * as bip66 from './bip66.js';\nimport { OPS, REVERSE_OPS } from './ops.js';\nimport * as pushdata from './push_data.js';\nimport * as scriptNumber from './script_number.js';\nimport * as scriptSignature from './script_signature.js';\nimport * as types from './types.js';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\nexport { OPS };\nconst StackSchema = v.array(v.union([v.instance(Uint8Array), v.number()]));\nfunction isOPInt(value) {\n  return (\n    v.is(v.number(), value) &&\n    (value === OPS.OP_0 ||\n      (value >= OPS.OP_1 && value <= OPS.OP_16) ||\n      value === OPS.OP_1NEGATE)\n  );\n}\nfunction isPushOnlyChunk(value) {\n  return v.is(types.BufferSchema, value) || isOPInt(value);\n}\nexport function isPushOnly(value) {\n  return v.is(v.pipe(v.any(), v.everyItem(isPushOnlyChunk)), value);\n}\nexport function countNonPushOnlyOPs(value) {\n  return value.length - value.filter(isPushOnlyChunk).length;\n}\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return OPS.OP_1NEGATE;\n}\nfunction chunksIsBuffer(buf) {\n  return buf instanceof Uint8Array;\n}\nfunction chunksIsArray(buf) {\n  return v.is(StackSchema, buf);\n}\nfunction singleChunkIsBuffer(buf) {\n  return buf instanceof Uint8Array;\n}\n/**\n * Compiles an array of chunks into a Buffer.\n *\n * @param chunks - The array of chunks to compile.\n * @returns The compiled Buffer.\n * @throws Error if the compilation fails.\n */\nexport function compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  v.parse(StackSchema, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    // opcode\n    return accum + 1;\n  }, 0.0);\n  const buffer = new Uint8Array(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        tools.writeUInt8(buffer, offset, opcode);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      buffer.set(chunk, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      tools.writeUInt8(buffer, offset, chunk);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nexport function decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  v.parse(types.BufferSchema, buffer);\n  const chunks = [];\n  let i = 0;\n  while (i < buffer.length) {\n    const opcode = buffer[i];\n    // data chunk\n    if (opcode > OPS.OP_0 && opcode <= OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail?\n      if (d === null) return null;\n      i += d.size;\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      const op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n      // opcode\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\n/**\n * Converts the given chunks into an ASM (Assembly) string representation.\n * If the chunks parameter is a Buffer, it will be decompiled into a Stack before conversion.\n * @param chunks - The chunks to convert into ASM.\n * @returns The ASM string representation of the chunks.\n */\nexport function toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  if (!chunks) {\n    throw new Error('Could not convert invalid chunks to ASM');\n  }\n  return chunks\n    .map(chunk => {\n      // data?\n      if (singleChunkIsBuffer(chunk)) {\n        const op = asMinimalOP(chunk);\n        if (op === undefined) return tools.toHex(chunk);\n        chunk = op;\n      }\n      // opcode!\n      return REVERSE_OPS[chunk];\n    })\n    .join(' ');\n}\n/**\n * Converts an ASM string to a Buffer.\n * @param asm The ASM string to convert.\n * @returns The converted Buffer.\n */\nexport function fromASM(asm) {\n  v.parse(v.string(), asm);\n  return compile(\n    asm.split(' ').map(chunkStr => {\n      // opcode?\n      if (OPS[chunkStr] !== undefined) return OPS[chunkStr];\n      v.parse(types.HexSchema, chunkStr);\n      // data!\n      return tools.fromHex(chunkStr);\n    }),\n  );\n}\n/**\n * Converts the given chunks into a stack of buffers.\n *\n * @param chunks - The chunks to convert.\n * @returns The stack of buffers.\n */\nexport function toStack(chunks) {\n  chunks = decompile(chunks);\n  v.parse(v.custom(isPushOnly), chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === OPS.OP_0) return new Uint8Array(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\nexport function isCanonicalPubKey(buffer) {\n  return types.isPoint(buffer);\n}\nexport function isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0xc0;\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexport function isCanonicalScriptSignature(buffer) {\n  if (!(buffer instanceof Uint8Array)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nexport const number = scriptNumber;\nexport const signature = scriptSignature;\n","import * as tools from 'uint8array-tools';\n/**\n * Decodes a script number from a buffer.\n *\n * @param buffer - The buffer containing the script number.\n * @param maxLength - The maximum length of the script number. Defaults to 4.\n * @param minimal - Whether the script number should be minimal. Defaults to true.\n * @returns The decoded script number.\n * @throws {TypeError} If the script number overflows the maximum length.\n * @throws {Error} If the script number is not minimally encoded when minimal is true.\n */\nexport function decode(buffer, maxLength, minimal) {\n  maxLength = maxLength || 4;\n  minimal = minimal === undefined ? true : minimal;\n  const length = buffer.length;\n  if (length === 0) return 0;\n  if (length > maxLength) throw new TypeError('Script number overflow');\n  if (minimal) {\n    if ((buffer[length - 1] & 0x7f) === 0) {\n      if (length <= 1 || (buffer[length - 2] & 0x80) === 0)\n        throw new Error('Non-minimally encoded script number');\n    }\n  }\n  // 40-bit\n  if (length === 5) {\n    const a = tools.readUInt32(buffer, 0, 'LE');\n    const b = tools.readUInt8(buffer, 4);\n    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);\n    return b * 0x100000000 + a;\n  }\n  // 32-bit / 24-bit / 16-bit / 8-bit\n  let result = 0;\n  for (let i = 0; i < length; ++i) {\n    result |= buffer[i] << (8 * i);\n  }\n  if (buffer[length - 1] & 0x80)\n    return -(result & ~(0x80 << (8 * (length - 1))));\n  return result;\n}\nfunction scriptNumSize(i) {\n  return i > 0x7fffffff\n    ? 5\n    : i > 0x7fffff\n      ? 4\n      : i > 0x7fff\n        ? 3\n        : i > 0x7f\n          ? 2\n          : i > 0x00\n            ? 1\n            : 0;\n}\n/**\n * Encodes a number into a Uint8Array using a specific format.\n *\n * @param _number - The number to encode.\n * @returns The encoded number as a Uint8Array.\n */\nexport function encode(_number) {\n  let value = Math.abs(_number);\n  const size = scriptNumSize(value);\n  const buffer = new Uint8Array(size);\n  const negative = _number < 0;\n  for (let i = 0; i < size; ++i) {\n    tools.writeUInt8(buffer, i, value & 0xff);\n    value >>= 8;\n  }\n  if (buffer[size - 1] & 0x80) {\n    tools.writeUInt8(buffer, size - 1, negative ? 0x80 : 0x00);\n  } else if (negative) {\n    buffer[size - 1] |= 0x80;\n  }\n  return buffer;\n}\n","export function prop(object, name, f) {\n  Object.defineProperty(object, name, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      const _value = f.call(this);\n      this[name] = _value;\n      return _value;\n    },\n    set(_value) {\n      Object.defineProperty(this, name, {\n        configurable: true,\n        enumerable: true,\n        value: _value,\n        writable: true,\n      });\n    },\n  });\n}\nexport function value(f) {\n  let _value;\n  return () => {\n    if (_value !== undefined) return _value;\n    _value = f();\n    return _value;\n  };\n}\n","import { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport { BufferSchema, isPoint, stacksEqual } from '../types.js';\nimport * as lazy from './lazy.js';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\nconst OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\n// input: OP_0 [signatures ...]\n// output: m [pubKeys ...] n OP_CHECKMULTISIG\n/**\n * Represents a function that creates a Pay-to-Multisig (P2MS) payment object.\n * @param a - The payment object.\n * @param opts - Optional payment options.\n * @returns The created payment object.\n * @throws {TypeError} If the provided data is not valid.\n */\nexport function p2ms(a, opts) {\n  if (\n    !a.input &&\n    !a.output &&\n    !(a.pubkeys && a.m !== undefined) &&\n    !a.signatures\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  function isAcceptableSignature(x) {\n    return (\n      bscript.isCanonicalScriptSignature(x) ||\n      (opts.allowIncomplete && x === OPS.OP_0) !== undefined\n    );\n  }\n  v.parse(\n    v.partial(\n      v.object({\n        network: v.object({}),\n        m: v.number(),\n        n: v.number(),\n        output: BufferSchema,\n        pubkeys: v.array(v.custom(isPoint), 'Received invalid pubkey'),\n        signatures: v.array(\n          v.custom(isAcceptableSignature),\n          'Expected signature to be of type isAcceptableSignature',\n        ),\n        input: BufferSchema,\n      }),\n    ),\n    a,\n  );\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { network };\n  let chunks = [];\n  let decoded = false;\n  function decode(output) {\n    if (decoded) return;\n    decoded = true;\n    chunks = bscript.decompile(output);\n    o.m = chunks[0] - OP_INT_BASE;\n    o.n = chunks[chunks.length - 2] - OP_INT_BASE;\n    o.pubkeys = chunks.slice(1, -2);\n  }\n  lazy.prop(o, 'output', () => {\n    if (!a.m) return;\n    if (!o.n) return;\n    if (!a.pubkeys) return;\n    return bscript.compile(\n      [].concat(\n        OP_INT_BASE + a.m,\n        a.pubkeys,\n        OP_INT_BASE + o.n,\n        OPS.OP_CHECKMULTISIG,\n      ),\n    );\n  });\n  lazy.prop(o, 'm', () => {\n    if (!o.output) return;\n    decode(o.output);\n    return o.m;\n  });\n  lazy.prop(o, 'n', () => {\n    if (!o.pubkeys) return;\n    return o.pubkeys.length;\n  });\n  lazy.prop(o, 'pubkeys', () => {\n    if (!a.output) return;\n    decode(a.output);\n    return o.pubkeys;\n  });\n  lazy.prop(o, 'signatures', () => {\n    if (!a.input) return;\n    return bscript.decompile(a.input).slice(1);\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signatures) return;\n    return bscript.compile([OPS.OP_0].concat(a.signatures));\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  lazy.prop(o, 'name', () => {\n    if (!o.m || !o.n) return;\n    return `p2ms(${o.m} of ${o.n})`;\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      decode(a.output);\n      v.parse(v.number(), chunks[0], { message: 'Output is invalid' });\n      v.parse(v.number(), chunks[chunks.length - 2], {\n        message: 'Output is invalid',\n      });\n      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)\n        throw new TypeError('Output is invalid');\n      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)\n        throw new TypeError('Output is invalid');\n      if (!o.pubkeys.every(x => isPoint(x)))\n        throw new TypeError('Output is invalid');\n      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');\n      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');\n      if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))\n        throw new TypeError('Pubkeys mismatch');\n    }\n    if (a.pubkeys) {\n      if (a.n !== undefined && a.n !== a.pubkeys.length)\n        throw new TypeError('Pubkey count mismatch');\n      o.n = a.pubkeys.length;\n      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');\n    }\n    if (a.signatures) {\n      if (a.signatures.length < o.m)\n        throw new TypeError('Not enough signatures provided');\n      if (a.signatures.length > o.m)\n        throw new TypeError('Too many signatures provided');\n    }\n    if (a.input) {\n      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');\n      if (\n        o.signatures.length === 0 ||\n        !o.signatures.every(isAcceptableSignature)\n      )\n        throw new TypeError('Input has invalid signature(s)');\n      if (a.signatures && !stacksEqual(a.signatures, o.signatures))\n        throw new TypeError('Signature mismatch');\n      if (a.m !== undefined && a.m !== a.signatures.length)\n        throw new TypeError('Signature count mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\n","import { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport { BufferSchema, isPoint } from '../types.js';\nimport * as lazy from './lazy.js';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\n// input: {signature}\n// output: {pubKey} OP_CHECKSIG\n/**\n * Creates a pay-to-public-key (P2PK) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2PK payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nexport function p2pk(a, opts) {\n  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        network: v.object({}),\n        output: BufferSchema,\n        pubkey: v.custom(isPoint, 'invalid pubkey'),\n        signature: v.custom(\n          bscript.isCanonicalScriptSignature,\n          'Expected signature to be of type isCanonicalScriptSignature',\n        ),\n        input: BufferSchema,\n      }),\n    ),\n    a,\n  );\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { name: 'p2pk', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.pubkey) return;\n    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.output) return;\n    return a.output.slice(1, -1);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signature) return;\n    return bscript.compile([a.signature]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)\n        throw new TypeError('Output is invalid');\n      if (!isPoint(o.pubkey)) throw new TypeError('Output pubkey is invalid');\n      if (a.pubkey && tools.compare(a.pubkey, o.pubkey) !== 0)\n        throw new TypeError('Pubkey mismatch');\n    }\n    if (a.signature) {\n      if (a.input && tools.compare(a.input, o.input) !== 0)\n        throw new TypeError('Signature mismatch');\n    }\n    if (a.input) {\n      if (_chunks().length !== 1) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(o.signature))\n        throw new TypeError('Input has invalid signature');\n    }\n  }\n  return Object.assign(o, a);\n}\n","/**\n * A module for hashing functions.\n * include ripemd160、sha1、sha256、hash160、hash256、taggedHash\n *\n * @packageDocumentation\n */\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport * as tools from 'uint8array-tools';\nexport function hash160(buffer) {\n  return ripemd160(sha256(buffer));\n}\nexport function hash256(buffer) {\n  return sha256(sha256(buffer));\n}\nexport const TAGS = [\n  'BIP0340/challenge',\n  'BIP0340/aux',\n  'BIP0340/nonce',\n  'TapLeaf',\n  'TapBranch',\n  'TapSighash',\n  'TapTweak',\n  'KeyAgg list',\n  'KeyAgg coefficient',\n];\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\n/**\n * Defines the tagged hash prefixes used in the crypto module.\n */\nexport const TAGGED_HASH_PREFIXES = {\n  'BIP0340/challenge': Uint8Array.from([\n    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,\n    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,\n    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,\n    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,\n  ]),\n  'BIP0340/aux': Uint8Array.from([\n    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,\n    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,\n    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,\n    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,\n  ]),\n  'BIP0340/nonce': Uint8Array.from([\n    7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244,\n    52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47, 7, 73,\n    119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215,\n    62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47,\n  ]),\n  TapLeaf: Uint8Array.from([\n    174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211,\n    95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238, 174, 234, 143,\n    220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181,\n    64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238,\n  ]),\n  TapBranch: Uint8Array.from([\n    25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247,\n    33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21, 25,\n    65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33,\n    111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21,\n  ]),\n  TapSighash: Uint8Array.from([\n    244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61,\n    149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49, 244,\n    10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149,\n    253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49,\n  ]),\n  TapTweak: Uint8Array.from([\n    232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66,\n    156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233, 232,\n    15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156,\n    188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233,\n  ]),\n  'KeyAgg list': Uint8Array.from([\n    72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126,\n    215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240, 72, 28,\n    151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49,\n    156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240,\n  ]),\n  'KeyAgg coefficient': Uint8Array.from([\n    191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100,\n    130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129, 191,\n    201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130,\n    78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129,\n  ]),\n};\nexport function taggedHash(prefix, data) {\n  return sha256(tools.concat([TAGGED_HASH_PREFIXES[prefix], data]));\n}\n","// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  const BASE_MAP = new Uint8Array(256)\n  for (let j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const x = ALPHABET.charAt(i)\n    const xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  const BASE = ALPHABET.length\n  const LEADER = ALPHABET.charAt(0)\n  const FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  const iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    // eslint-disable-next-line no-empty\n    if (source instanceof Uint8Array) { } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n    // Skip & count leading zeroes.\n    let zeroes = 0\n    let length = 0\n    let pbegin = 0\n    const pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    const b58 = new Uint8Array(size)\n    // Process the bytes.\n    while (pbegin !== pend) {\n      let carry = source[pbegin]\n      // Apply \"b58 = b58 * 256 + ch\".\n      let i = 0\n      for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    let psz = 0\n    // Skip and count leading '1's.\n    let zeroes = 0\n    let length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n    // Allocate enough space in big-endian base256 representation.\n    const size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    const b256 = new Uint8Array(size)\n    // Process the characters.\n    while (source[psz]) {\n      // Decode character\n      let carry = BASE_MAP[source.charCodeAt(psz)]\n      // Invalid character\n      if (carry === 255) { return }\n      let i = 0\n      for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n    // Skip leading zeroes in b256.\n    let it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    const vch = new Uint8Array(zeroes + (size - it4))\n    let j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    const buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode,\n    decodeUnsafe,\n    decode\n  }\n}\nexport default base\n","import basex from 'base-x';\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nexport default basex(ALPHABET);\n","'use strict';\nimport { sha256 } from '@noble/hashes/sha256';\nimport bs58checkBase from './base.js';\n// SHA256(SHA256(buffer))\nfunction sha256x2(buffer) {\n    return sha256(sha256(buffer));\n}\nexport default bs58checkBase(sha256x2);\n","'use strict';\nimport base58 from 'bs58';\nexport default function (checksumFn) {\n    // Encode a buffer as a base58-check encoded string\n    function encode(payload) {\n        var payloadU8 = Uint8Array.from(payload);\n        var checksum = checksumFn(payloadU8);\n        var length = payloadU8.length + 4;\n        var both = new Uint8Array(length);\n        both.set(payloadU8, 0);\n        both.set(checksum.subarray(0, 4), payloadU8.length);\n        return base58.encode(both);\n    }\n    function decodeRaw(buffer) {\n        var payload = buffer.slice(0, -4);\n        var checksum = buffer.slice(-4);\n        var newChecksum = checksumFn(payload);\n        // eslint-disable-next-line\n        if (checksum[0] ^ newChecksum[0] |\n            checksum[1] ^ newChecksum[1] |\n            checksum[2] ^ newChecksum[2] |\n            checksum[3] ^ newChecksum[3])\n            return;\n        return payload;\n    }\n    // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n    function decodeUnsafe(str) {\n        var buffer = base58.decodeUnsafe(str);\n        if (buffer == null)\n            return;\n        return decodeRaw(buffer);\n    }\n    function decode(str) {\n        var buffer = base58.decode(str);\n        var payload = decodeRaw(buffer);\n        if (payload == null)\n            throw new Error('Invalid checksum');\n        return payload;\n    }\n    return {\n        encode: encode,\n        decode: decode,\n        decodeUnsafe: decodeUnsafe\n    };\n}\n","import * as bcrypto from '../crypto.js';\nimport { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport {\n  isPoint,\n  Hash160bitSchema,\n  NBufferSchemaFactory,\n  BufferSchema,\n} from '../types.js';\nimport * as lazy from './lazy.js';\nimport bs58check from 'bs58check';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\n// input: {signature} {pubkey}\n// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG\n/**\n * Creates a Pay-to-Public-Key-Hash (P2PKH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2PKH payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nexport function p2pkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        network: v.object({}),\n        address: v.string(),\n        hash: Hash160bitSchema,\n        output: NBufferSchemaFactory(25),\n        pubkey: v.custom(isPoint),\n        signature: v.custom(bscript.isCanonicalScriptSignature),\n        input: BufferSchema,\n      }),\n    ),\n    a,\n  );\n  const _address = lazy.value(() => {\n    const payload = bs58check.decode(a.address);\n    const version = tools.readUInt8(payload, 0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { name: 'p2pkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = new Uint8Array(21);\n    tools.writeUInt8(payload, 0, network.pubKeyHash);\n    payload.set(o.hash, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(3, 23);\n    if (a.address) return _address().hash;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([\n      OPS.OP_DUP,\n      OPS.OP_HASH160,\n      o.hash,\n      OPS.OP_EQUALVERIFY,\n      OPS.OP_CHECKSIG,\n    ]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.input) return;\n    return _chunks()[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return bscript.compile([a.signature, a.pubkey]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Uint8Array.from([]);\n    if (a.address) {\n      if (_address().version !== network.pubKeyHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && tools.compare(hash, a.hash) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 25 ||\n        a.output[0] !== OPS.OP_DUP ||\n        a.output[1] !== OPS.OP_HASH160 ||\n        a.output[2] !== 0x14 ||\n        a.output[23] !== OPS.OP_EQUALVERIFY ||\n        a.output[24] !== OPS.OP_CHECKSIG\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(3, 23);\n      if (hash.length > 0 && tools.compare(hash, hash2) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && tools.compare(hash, pkh) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n    }\n    if (a.input) {\n      const chunks = _chunks();\n      if (chunks.length !== 2) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(chunks[0]))\n        throw new TypeError('Input has invalid signature');\n      if (!isPoint(chunks[1])) throw new TypeError('Input has invalid pubkey');\n      if (a.signature && tools.compare(a.signature, chunks[0]) !== 0)\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && tools.compare(a.pubkey, chunks[1]) !== 0)\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(chunks[1]);\n      if (hash.length > 0 && tools.compare(hash, pkh) !== 0)\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\n","import * as bcrypto from '../crypto.js';\nimport { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport { BufferSchema, NBufferSchemaFactory, stacksEqual } from '../types.js';\nimport * as lazy from './lazy.js';\nimport bs58check from 'bs58check';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\n// input: [redeemScriptSig ...] {redeemScript}\n// witness: <?>\n// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL\n/**\n * Creates a Pay-to-Script-Hash (P2SH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2SH payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nexport function p2sh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        network: v.object({}),\n        address: v.string(),\n        hash: NBufferSchemaFactory(20),\n        output: NBufferSchemaFactory(23),\n        redeem: v.partial(\n          v.object({\n            network: v.object({}),\n            output: BufferSchema,\n            input: BufferSchema,\n            witness: v.array(BufferSchema),\n          }),\n        ),\n        input: BufferSchema,\n        witness: v.array(BufferSchema),\n      }),\n    ),\n    a,\n  );\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || BITCOIN_NETWORK;\n  }\n  const o = { network };\n  const _address = lazy.value(() => {\n    const payload = bs58check.decode(a.address);\n    const version = tools.readUInt8(payload, 0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const _redeem = lazy.value(() => {\n    const chunks = _chunks();\n    const lastChunk = chunks[chunks.length - 1];\n    return {\n      network,\n      output: lastChunk === OPS.OP_FALSE ? Uint8Array.from([]) : lastChunk,\n      input: bscript.compile(chunks.slice(0, -1)),\n      witness: a.witness || [],\n    };\n  });\n  // output dependents\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = new Uint8Array(21);\n    tools.writeUInt8(payload, 0, o.network.scriptHash);\n    payload.set(o.hash, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    // in order of least effort\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().hash;\n    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);\n  });\n  // input dependents\n  lazy.prop(o, 'redeem', () => {\n    if (!a.input) return;\n    return _redeem();\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;\n    return bscript.compile(\n      [].concat(bscript.decompile(a.redeem.input), a.redeem.output),\n    );\n  });\n  lazy.prop(o, 'witness', () => {\n    if (o.redeem && o.redeem.witness) return o.redeem.witness;\n    if (o.input) return [];\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2sh'];\n    if (o.redeem !== undefined && o.redeem.name !== undefined)\n      nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  if (opts.validate) {\n    let hash = Uint8Array.from([]);\n    if (a.address) {\n      if (_address().version !== network.scriptHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && tools.compare(hash, a.hash) !== 0)\n        throw new TypeError('Hash mismatch');\n      // @ts-ignore\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 23 ||\n        a.output[0] !== OPS.OP_HASH160 ||\n        a.output[1] !== 0x14 ||\n        a.output[22] !== OPS.OP_EQUAL\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2, 22);\n      if (hash.length > 0 && tools.compare(hash, hash2) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    // inlined to prevent 'no-inner-declarations' failing\n    const checkRedeem = redeem => {\n      // is the redeem output empty/invalid?\n      if (redeem.output) {\n        const decompile = bscript.decompile(redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output too short');\n        if (redeem.output.byteLength > 520)\n          throw new TypeError(\n            'Redeem.output unspendable if larger than 520 bytes',\n          );\n        if (bscript.countNonPushOnlyOPs(decompile) > 201)\n          throw new TypeError(\n            'Redeem.output unspendable with more than 201 non-push ops',\n          );\n        // match hash against other sources\n        const hash2 = bcrypto.hash160(redeem.output);\n        if (hash.length > 0 && tools.compare(hash, hash2) !== 0)\n          throw new TypeError('Hash mismatch');\n        // @ts-ignore\n        else hash = hash2;\n      }\n      if (redeem.input) {\n        const hasInput = redeem.input.length > 0;\n        const hasWitness = redeem.witness && redeem.witness.length > 0;\n        if (!hasInput && !hasWitness) throw new TypeError('Empty input');\n        if (hasInput && hasWitness)\n          throw new TypeError('Input and witness provided');\n        if (hasInput) {\n          const richunks = bscript.decompile(redeem.input);\n          if (!bscript.isPushOnly(richunks))\n            throw new TypeError('Non push-only scriptSig');\n        }\n      }\n    };\n    if (a.input) {\n      const chunks = _chunks();\n      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');\n      if (!(_redeem().output instanceof Uint8Array))\n        throw new TypeError('Input is invalid');\n      checkRedeem(_redeem());\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      if (a.input) {\n        const redeem = _redeem();\n        if (\n          a.redeem.output &&\n          tools.compare(a.redeem.output, redeem.output) !== 0\n        )\n          throw new TypeError('Redeem.output mismatch');\n        if (a.redeem.input && tools.compare(a.redeem.input, redeem.input) !== 0)\n          throw new TypeError('Redeem.input mismatch');\n      }\n      checkRedeem(a.redeem);\n    }\n    if (a.witness) {\n      if (\n        a.redeem &&\n        a.redeem.witness &&\n        !stacksEqual(a.redeem.witness, a.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\n","import * as bcrypto from '../crypto.js';\nimport { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport { BufferSchema, isPoint, NBufferSchemaFactory } from '../types.js';\nimport * as lazy from './lazy.js';\nimport { bech32 } from 'bech32';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = new Uint8Array(0);\n// witness: {signature} {pubKey}\n// input: <>\n// output: OP_0 {pubKeyHash}\n/**\n * Creates a pay-to-witness-public-key-hash (p2wpkh) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The p2wpkh payment object.\n * @throws {TypeError} If the required data is missing or invalid.\n */\nexport function p2wpkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        address: v.string(),\n        hash: NBufferSchemaFactory(20),\n        input: NBufferSchemaFactory(0),\n        network: v.object({}),\n        output: NBufferSchemaFactory(22),\n        pubkey: v.custom(isPoint, 'Not a valid pubkey'),\n        signature: v.custom(bscript.isCanonicalScriptSignature),\n        witness: v.array(BufferSchema),\n      }),\n    ),\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Uint8Array.from(data),\n    };\n  });\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { name: 'p2wpkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().data;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (!a.witness) return;\n    return a.witness[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.witness) return;\n    return a.witness[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return [a.signature, a.pubkey];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Uint8Array.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 20)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && tools.compare(hash, a.hash) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 22 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x14\n      )\n        throw new TypeError('Output is invalid');\n      if (hash.length > 0 && tools.compare(hash, a.output.slice(2)) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = a.output.slice(2);\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && tools.compare(hash, pkh) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n      if (!isPoint(a.pubkey) || a.pubkey.length !== 33)\n        throw new TypeError('Invalid pubkey for p2wpkh');\n    }\n    if (a.witness) {\n      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');\n      if (!bscript.isCanonicalScriptSignature(a.witness[0]))\n        throw new TypeError('Witness has invalid signature');\n      if (!isPoint(a.witness[1]) || a.witness[1].length !== 33)\n        throw new TypeError('Witness has invalid pubkey');\n      if (a.signature && tools.compare(a.signature, a.witness[0]) !== 0)\n        throw new TypeError('Signature mismatch');\n      // if (a.pubkey && !a.pubkey.equals(a.witness[1]))\n      if (a.pubkey && tools.compare(a.pubkey, a.witness[1]) !== 0)\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(a.witness[1]);\n      if (hash.length > 0 && tools.compare(hash, pkh) !== 0)\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\n","import { sha256 } from '@noble/hashes/sha256';\nimport { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport {\n  Buffer256bitSchema,\n  BufferSchema,\n  isPoint,\n  NBufferSchemaFactory,\n  stacksEqual,\n  NullablePartial,\n} from '../types.js';\nimport * as lazy from './lazy.js';\nimport { bech32 } from 'bech32';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = new Uint8Array(0);\nfunction chunkHasUncompressedPubkey(chunk) {\n  if (\n    chunk instanceof Uint8Array &&\n    chunk.length === 65 &&\n    chunk[0] === 0x04 &&\n    isPoint(chunk)\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n// input: <>\n// witness: [redeemScriptSig ...] {redeemScript}\n// output: OP_0 {sha256(redeemScript)}\n/**\n * Creates a Pay-to-Witness-Script-Hash (P2WSH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2WSH payment object.\n * @throws {TypeError} If the required data is missing or invalid.\n */\nexport function p2wsh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    NullablePartial({\n      network: v.object({}),\n      address: v.string(),\n      hash: Buffer256bitSchema,\n      output: NBufferSchemaFactory(34),\n      redeem: NullablePartial({\n        input: BufferSchema,\n        network: v.object({}),\n        output: BufferSchema,\n        witness: v.array(BufferSchema),\n      }),\n      input: NBufferSchemaFactory(0),\n      witness: v.array(BufferSchema),\n    }),\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Uint8Array.from(data),\n    };\n  });\n  const _rchunks = lazy.value(() => {\n    return bscript.decompile(a.redeem.input);\n  });\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || BITCOIN_NETWORK;\n  }\n  const o = { network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.redeem && o.redeem.output) return sha256(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'redeem', () => {\n    if (!a.witness) return;\n    return {\n      output: a.witness[a.witness.length - 1],\n      input: EMPTY_BUFFER,\n      witness: a.witness.slice(0, -1),\n    };\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    // transform redeem input to witness stack?\n    if (\n      a.redeem &&\n      a.redeem.input &&\n      a.redeem.input.length > 0 &&\n      a.redeem.output &&\n      a.redeem.output.length > 0\n    ) {\n      const stack = bscript.toStack(_rchunks());\n      // assign, and blank the existing input\n      o.redeem = Object.assign({ witness: stack }, a.redeem);\n      o.redeem.input = EMPTY_BUFFER;\n      return [].concat(stack, a.redeem.output);\n    }\n    if (!a.redeem) return;\n    if (!a.redeem.output) return;\n    if (!a.redeem.witness) return;\n    return [].concat(a.redeem.witness, a.redeem.output);\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2wsh'];\n    if (o.redeem !== undefined && o.redeem.name !== undefined)\n      nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Uint8Array.from([]);\n    if (a.address) {\n      if (_address().prefix !== network.bech32)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && tools.compare(hash, a.hash) !== 0)\n        throw new TypeError('Hash mismatch');\n      // @ts-ignore\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2);\n      if (hash.length > 0 && tools.compare(hash, hash2) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      // is there two redeem sources?\n      if (\n        a.redeem.input &&\n        a.redeem.input.length > 0 &&\n        a.redeem.witness &&\n        a.redeem.witness.length > 0\n      )\n        throw new TypeError('Ambiguous witness source');\n      // is the redeem output non-empty/valid?\n      if (a.redeem.output) {\n        const decompile = bscript.decompile(a.redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output is invalid');\n        if (a.redeem.output.byteLength > 3600)\n          throw new TypeError(\n            'Redeem.output unspendable if larger than 3600 bytes',\n          );\n        if (bscript.countNonPushOnlyOPs(decompile) > 201)\n          throw new TypeError(\n            'Redeem.output unspendable with more than 201 non-push ops',\n          );\n        // match hash against other sources\n        const hash2 = sha256(a.redeem.output);\n        if (hash.length > 0 && tools.compare(hash, hash2) !== 0)\n          throw new TypeError('Hash mismatch');\n        // @ts-ignore\n        else hash = hash2;\n      }\n      if (a.redeem.input && !bscript.isPushOnly(_rchunks()))\n        throw new TypeError('Non push-only scriptSig');\n      if (\n        a.witness &&\n        a.redeem.witness &&\n        !stacksEqual(a.witness, a.redeem.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n      if (\n        (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||\n        (a.redeem.output &&\n          (bscript.decompile(a.redeem.output) || []).some(\n            chunkHasUncompressedPubkey,\n          ))\n      ) {\n        throw new TypeError(\n          'redeem.input or redeem.output contains uncompressed pubkey',\n        );\n      }\n    }\n    if (a.witness && a.witness.length > 0) {\n      const wScript = a.witness[a.witness.length - 1];\n      if (\n        a.redeem &&\n        a.redeem.output &&\n        tools.compare(a.redeem.output, wScript) !== 0\n      )\n        throw new TypeError('Witness and redeem.output mismatch');\n      if (\n        a.witness.some(chunkHasUncompressedPubkey) ||\n        (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)\n      )\n        throw new TypeError('Witness contains uncompressed pubkey');\n    }\n  }\n  return Object.assign(o, a);\n}\n","import * as tools from 'uint8array-tools';\nconst _ECCLIB_CACHE = {};\n/**\n * Initializes the ECC library with the provided instance.\n * If `eccLib` is `undefined`, the library will be cleared.\n * If `eccLib` is a new instance, it will be verified before setting it as the active library.\n *\n * @param eccLib The instance of the ECC library to initialize.\n */\nexport function initEccLib(eccLib) {\n  if (!eccLib) {\n    // allow clearing the library\n    _ECCLIB_CACHE.eccLib = eccLib;\n  } else if (eccLib !== _ECCLIB_CACHE.eccLib) {\n    // new instance, verify it\n    verifyEcc(eccLib);\n    _ECCLIB_CACHE.eccLib = eccLib;\n  }\n}\n/**\n * Retrieves the ECC Library instance.\n * Throws an error if the ECC Library is not provided.\n * You must call initEccLib() with a valid TinySecp256k1Interface instance before calling this function.\n * @returns The ECC Library instance.\n * @throws Error if the ECC Library is not provided.\n */\nexport function getEccLib() {\n  if (!_ECCLIB_CACHE.eccLib)\n    throw new Error(\n      'No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance',\n    );\n  return _ECCLIB_CACHE.eccLib;\n}\nconst h = hex => tools.fromHex(hex);\n/**\n * Verifies the ECC functionality.\n *\n * @param ecc - The TinySecp256k1Interface object.\n */\nfunction verifyEcc(ecc) {\n  assert(typeof ecc.isXOnlyPoint === 'function');\n  assert(\n    ecc.isXOnlyPoint(\n      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('0000000000000000000000000000000000000000000000000000000000000001'),\n    ),\n  );\n  assert(\n    !ecc.isXOnlyPoint(\n      h('0000000000000000000000000000000000000000000000000000000000000000'),\n    ),\n  );\n  assert(\n    !ecc.isXOnlyPoint(\n      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    ),\n  );\n  assert(typeof ecc.xOnlyPointAddTweak === 'function');\n  tweakAddVectors.forEach(t => {\n    const r = ecc.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));\n    if (t.result === null) {\n      assert(r === null);\n    } else {\n      assert(r !== null);\n      assert(r.parity === t.parity);\n      assert(tools.compare(r.xOnlyPubkey, h(t.result)) === 0);\n    }\n  });\n}\nfunction assert(bool) {\n  if (!bool) throw new Error('ecc library invalid');\n}\nconst tweakAddVectors = [\n  {\n    pubkey: '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    tweak: 'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140',\n    parity: -1,\n    result: null,\n  },\n  {\n    pubkey: '1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b',\n    tweak: 'a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac',\n    parity: 1,\n    result: 'e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf',\n  },\n  {\n    pubkey: '2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991',\n    tweak: '823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47',\n    parity: 0,\n    result: '9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c',\n  },\n];\n","import * as types from './types.js';\nimport * as varuint from 'varuint-bitcoin';\nimport * as v from 'valibot';\nexport { varuint };\nimport * as tools from 'uint8array-tools';\nconst MAX_JS_NUMBER = 0x001fffffffffffff;\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number' && typeof value !== 'bigint')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0 && value < BigInt(0))\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max && value > BigInt(max))\n    throw new Error('RangeError: value out of range');\n  if (Math.floor(Number(value)) !== Number(value))\n    throw new Error('value has a fractional component');\n}\n/**\n * Reverses the order of bytes in a buffer.\n * @param buffer - The buffer to reverse.\n * @returns A new buffer with the bytes reversed.\n */\nexport function reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexport function cloneBuffer(buffer) {\n  const clone = new Uint8Array(buffer.length);\n  clone.set(buffer);\n  return clone;\n}\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nexport class BufferWriter {\n  buffer;\n  offset;\n  static withCapacity(size) {\n    return new BufferWriter(new Uint8Array(size));\n  }\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    v.parse(v.tuple([types.BufferSchema, types.UInt32Schema]), [\n      buffer,\n      offset,\n    ]);\n  }\n  writeUInt8(i) {\n    this.offset = tools.writeUInt8(this.buffer, this.offset, i);\n  }\n  writeInt32(i) {\n    this.offset = tools.writeInt32(this.buffer, this.offset, i, 'LE');\n  }\n  writeInt64(i) {\n    this.offset = tools.writeInt64(this.buffer, this.offset, BigInt(i), 'LE');\n  }\n  writeUInt32(i) {\n    this.offset = tools.writeUInt32(this.buffer, this.offset, i, 'LE');\n  }\n  writeUInt64(i) {\n    this.offset = tools.writeUInt64(this.buffer, this.offset, BigInt(i), 'LE');\n  }\n  writeVarInt(i) {\n    const { bytes } = varuint.encode(i, this.buffer, this.offset);\n    this.offset += bytes;\n  }\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error('Cannot write slice out of bounds');\n    }\n    this.buffer.set(slice, this.offset);\n    this.offset += slice.length;\n  }\n  writeVarSlice(slice) {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n  writeVector(vector) {\n    this.writeVarInt(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n  end() {\n    if (this.buffer.length === this.offset) {\n      return this.buffer;\n    }\n    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);\n  }\n}\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nexport class BufferReader {\n  buffer;\n  offset;\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    v.parse(v.tuple([types.BufferSchema, types.UInt32Schema]), [\n      buffer,\n      offset,\n    ]);\n  }\n  readUInt8() {\n    const result = tools.readUInt8(this.buffer, this.offset);\n    this.offset++;\n    return result;\n  }\n  readInt32() {\n    const result = tools.readInt32(this.buffer, this.offset, 'LE');\n    this.offset += 4;\n    return result;\n  }\n  readUInt32() {\n    const result = tools.readUInt32(this.buffer, this.offset, 'LE');\n    this.offset += 4;\n    return result;\n  }\n  readInt64() {\n    const result = tools.readInt64(this.buffer, this.offset, 'LE');\n    this.offset += 8;\n    return result;\n  }\n  readVarInt() {\n    const { bigintValue, bytes } = varuint.decode(this.buffer, this.offset);\n    this.offset += bytes;\n    return bigintValue;\n  }\n  readSlice(n) {\n    verifuint(n, MAX_JS_NUMBER);\n    const num = Number(n);\n    if (this.buffer.length < this.offset + num) {\n      throw new Error('Cannot read slice out of bounds');\n    }\n    const result = this.buffer.slice(this.offset, this.offset + num);\n    this.offset += num;\n    return result;\n  }\n  readVarSlice() {\n    return this.readSlice(this.readVarInt());\n  }\n  readVector() {\n    const count = this.readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\n","import { getEccLib } from '../ecc_lib.js';\nimport * as bcrypto from '../crypto.js';\nimport { varuint } from '../bufferutils.js';\nimport { isTapleaf } from '../types.js';\nimport * as tools from 'uint8array-tools';\nexport const LEAF_VERSION_TAPSCRIPT = 0xc0;\nexport const MAX_TAPTREE_DEPTH = 128;\nconst isHashBranch = ht => 'left' in ht && 'right' in ht;\n/**\n * Calculates the root hash from a given control block and leaf hash.\n * @param controlBlock - The control block buffer.\n * @param leafHash - The leaf hash buffer.\n * @returns The root hash buffer.\n * @throws {TypeError} If the control block length is less than 33.\n */\nexport function rootHashFromPath(controlBlock, leafHash) {\n  if (controlBlock.length < 33)\n    throw new TypeError(\n      `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n    );\n  const m = (controlBlock.length - 33) / 32;\n  let kj = leafHash;\n  for (let j = 0; j < m; j++) {\n    const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);\n    if (tools.compare(kj, ej) < 0) {\n      kj = tapBranchHash(kj, ej);\n    } else {\n      kj = tapBranchHash(ej, kj);\n    }\n  }\n  return kj;\n}\n/**\n * Build a hash tree of merkle nodes from the scripts binary tree.\n * @param scriptTree - the tree of scripts to pairwise hash.\n */\nexport function toHashTree(scriptTree) {\n  if (isTapleaf(scriptTree)) return { hash: tapleafHash(scriptTree) };\n  const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];\n  // hashes.sort((a, b) => a.hash.compare(b.hash));\n  hashes.sort((a, b) => tools.compare(a.hash, b.hash));\n  const [left, right] = hashes;\n  return {\n    hash: tapBranchHash(left.hash, right.hash),\n    left,\n    right,\n  };\n}\n/**\n * Given a HashTree, finds the path from a particular hash to the root.\n * @param node - the root of the tree\n * @param hash - the hash to search for\n * @returns - array of sibling hashes, from leaf (inclusive) to root\n * (exclusive) needed to prove inclusion of the specified hash. undefined if no\n * path is found\n */\nexport function findScriptPath(node, hash) {\n  if (isHashBranch(node)) {\n    const leftPath = findScriptPath(node.left, hash);\n    if (leftPath !== undefined) return [...leftPath, node.right.hash];\n    const rightPath = findScriptPath(node.right, hash);\n    if (rightPath !== undefined) return [...rightPath, node.left.hash];\n  } else if (tools.compare(node.hash, hash) === 0) {\n    return [];\n  }\n  return undefined;\n}\n/**\n * Calculates the tapleaf hash for a given Tapleaf object.\n * @param leaf - The Tapleaf object to calculate the hash for.\n * @returns The tapleaf hash as a Buffer.\n */\nexport function tapleafHash(leaf) {\n  const version = leaf.version || LEAF_VERSION_TAPSCRIPT;\n  return bcrypto.taggedHash(\n    'TapLeaf',\n    tools.concat([Uint8Array.from([version]), serializeScript(leaf.output)]),\n  );\n}\n/**\n * Computes the taproot tweak hash for a given public key and optional hash.\n * If a hash is provided, the public key and hash are concatenated before computing the hash.\n * If no hash is provided, only the public key is used to compute the hash.\n *\n * @param pubKey - The public key buffer.\n * @param h - The optional hash buffer.\n * @returns The taproot tweak hash.\n */\nexport function tapTweakHash(pubKey, h) {\n  return bcrypto.taggedHash(\n    'TapTweak',\n    tools.concat(h ? [pubKey, h] : [pubKey]),\n  );\n}\n/**\n * Tweak a public key with a given tweak hash.\n * @param pubKey - The public key to be tweaked.\n * @param h - The tweak hash.\n * @returns The tweaked public key or null if the input is invalid.\n */\nexport function tweakKey(pubKey, h) {\n  if (!(pubKey instanceof Uint8Array)) return null;\n  if (pubKey.length !== 32) return null;\n  if (h && h.length !== 32) return null;\n  const tweakHash = tapTweakHash(pubKey, h);\n  const res = getEccLib().xOnlyPointAddTweak(pubKey, tweakHash);\n  if (!res || res.xOnlyPubkey === null) return null;\n  return {\n    parity: res.parity,\n    x: Uint8Array.from(res.xOnlyPubkey),\n  };\n}\n/**\n * Computes the TapBranch hash by concatenating two buffers and applying the 'TapBranch' tagged hash algorithm.\n *\n * @param a - The first buffer.\n * @param b - The second buffer.\n * @returns The TapBranch hash of the concatenated buffers.\n */\nfunction tapBranchHash(a, b) {\n  return bcrypto.taggedHash('TapBranch', tools.concat([a, b]));\n}\n/**\n * Serializes a script by encoding its length as a varint and concatenating it with the script.\n *\n * @param s - The script to be serialized.\n * @returns The serialized script as a Buffer.\n */\nfunction serializeScript(s) {\n  /* global BigInt */\n  const varintLen = varuint.encodingLength(s.length);\n  const buffer = new Uint8Array(varintLen);\n  varuint.encode(s.length, buffer);\n  return tools.concat([buffer, s]);\n}\n","import { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport {\n  isTaptree,\n  TAPLEAF_VERSION_MASK,\n  stacksEqual,\n  NBufferSchemaFactory,\n  BufferSchema,\n} from '../types.js';\nimport { getEccLib } from '../ecc_lib.js';\nimport {\n  toHashTree,\n  rootHashFromPath,\n  findScriptPath,\n  tapleafHash,\n  tweakKey,\n  LEAF_VERSION_TAPSCRIPT,\n} from './bip341.js';\nimport * as lazy from './lazy.js';\nimport { bech32m } from 'bech32';\nimport { fromBech32 } from '../address.js';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\nconst TAPROOT_WITNESS_VERSION = 0x01;\nconst ANNEX_PREFIX = 0x50;\n/**\n * Creates a Pay-to-Taproot (P2TR) payment object.\n *\n * @param a - The payment object containing the necessary data for P2TR.\n * @param opts - Optional payment options.\n * @returns The P2TR payment object.\n * @throws {TypeError} If the provided data is invalid or insufficient.\n */\nexport function p2tr(a, opts) {\n  if (\n    !a.address &&\n    !a.output &&\n    !a.pubkey &&\n    !a.internalPubkey &&\n    !(a.witness && a.witness.length > 1)\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        address: v.string(),\n        input: NBufferSchemaFactory(0),\n        network: v.object({}),\n        output: NBufferSchemaFactory(34),\n        internalPubkey: NBufferSchemaFactory(32),\n        hash: NBufferSchemaFactory(32), // merkle root hash, the tweak\n        pubkey: NBufferSchemaFactory(32), // tweaked with `hash` from `internalPubkey`\n        signature: v.union([\n          NBufferSchemaFactory(64),\n          NBufferSchemaFactory(65),\n        ]),\n        witness: v.array(BufferSchema),\n        scriptTree: v.custom(isTaptree, 'Taptree is not of type isTaptree'),\n        redeem: v.partial(\n          v.object({\n            output: BufferSchema, // tapleaf script\n            redeemVersion: v.number(), // tapleaf version\n            witness: v.array(BufferSchema),\n          }),\n        ),\n        redeemVersion: v.number(),\n      }),\n    ),\n    a,\n  );\n  const _address = lazy.value(() => {\n    return fromBech32(a.address);\n  });\n  // remove annex if present, ignored by taproot\n  const _witness = lazy.value(() => {\n    if (!a.witness || !a.witness.length) return;\n    if (\n      a.witness.length >= 2 &&\n      a.witness[a.witness.length - 1][0] === ANNEX_PREFIX\n    ) {\n      return a.witness.slice(0, -1);\n    }\n    return a.witness.slice();\n  });\n  const _hashTree = lazy.value(() => {\n    if (a.scriptTree) return toHashTree(a.scriptTree);\n    if (a.hash) return { hash: a.hash };\n    return;\n  });\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { name: 'p2tr', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.pubkey) return;\n    const words = bech32m.toWords(o.pubkey);\n    words.unshift(TAPROOT_WITNESS_VERSION);\n    return bech32m.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    const hashTree = _hashTree();\n    if (hashTree) return hashTree.hash;\n    const w = _witness();\n    if (w && w.length > 1) {\n      const controlBlock = w[w.length - 1];\n      const leafVersion = controlBlock[0] & TAPLEAF_VERSION_MASK;\n      const script = w[w.length - 2];\n      const leafHash = tapleafHash({ output: script, version: leafVersion });\n      return rootHashFromPath(controlBlock, leafHash);\n    }\n    return null;\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.pubkey) return;\n    return bscript.compile([OPS.OP_1, o.pubkey]);\n  });\n  lazy.prop(o, 'redeemVersion', () => {\n    if (a.redeemVersion) return a.redeemVersion;\n    if (\n      a.redeem &&\n      a.redeem.redeemVersion !== undefined &&\n      a.redeem.redeemVersion !== null\n    ) {\n      return a.redeem.redeemVersion;\n    }\n    return LEAF_VERSION_TAPSCRIPT;\n  });\n  lazy.prop(o, 'redeem', () => {\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length < 2) return;\n    return {\n      output: witness[witness.length - 2],\n      witness: witness.slice(0, -2),\n      redeemVersion: witness[witness.length - 1][0] & TAPLEAF_VERSION_MASK,\n    };\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.internalPubkey) {\n      const tweakedKey = tweakKey(o.internalPubkey, o.hash);\n      if (tweakedKey) return tweakedKey.x;\n    }\n  });\n  lazy.prop(o, 'internalPubkey', () => {\n    if (a.internalPubkey) return a.internalPubkey;\n    const witness = _witness();\n    if (witness && witness.length > 1)\n      return witness[witness.length - 1].slice(1, 33);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (a.signature) return a.signature;\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length !== 1) return;\n    return witness[0];\n  });\n  lazy.prop(o, 'witness', () => {\n    if (a.witness) return a.witness;\n    const hashTree = _hashTree();\n    if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {\n      const leafHash = tapleafHash({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      const path = findScriptPath(hashTree, leafHash);\n      if (!path) return;\n      const outputKey = tweakKey(a.internalPubkey, hashTree.hash);\n      if (!outputKey) return;\n      const controlBock = tools.concat(\n        [\n          Uint8Array.from([o.redeemVersion | outputKey.parity]),\n          a.internalPubkey,\n        ].concat(path),\n      );\n      return [a.redeem.output, controlBock];\n    }\n    if (a.signature) return [a.signature];\n  });\n  // extended validation\n  if (opts.validate) {\n    let pubkey = Uint8Array.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== TAPROOT_WITNESS_VERSION)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      pubkey = _address().data;\n    }\n    if (a.pubkey) {\n      if (pubkey.length > 0 && tools.compare(pubkey, a.pubkey) !== 0)\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.pubkey;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_1 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      if (pubkey.length > 0 && tools.compare(pubkey, a.output.slice(2)) !== 0)\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.output.slice(2);\n    }\n    if (a.internalPubkey) {\n      const tweakedKey = tweakKey(a.internalPubkey, o.hash);\n      if (pubkey.length > 0 && tools.compare(pubkey, tweakedKey.x) !== 0)\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = tweakedKey.x;\n    }\n    if (pubkey && pubkey.length) {\n      if (!getEccLib().isXOnlyPoint(pubkey))\n        throw new TypeError('Invalid pubkey for p2tr');\n    }\n    const hashTree = _hashTree();\n    if (a.hash && hashTree) {\n      if (tools.compare(a.hash, hashTree.hash) !== 0)\n        throw new TypeError('Hash mismatch');\n    }\n    if (a.redeem && a.redeem.output && hashTree) {\n      const leafHash = tapleafHash({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      if (!findScriptPath(hashTree, leafHash))\n        throw new TypeError('Redeem script not in tree');\n    }\n    const witness = _witness();\n    // compare the provided redeem data with the one computed from witness\n    if (a.redeem && o.redeem) {\n      if (a.redeem.redeemVersion) {\n        if (a.redeem.redeemVersion !== o.redeem.redeemVersion)\n          throw new TypeError('Redeem.redeemVersion and witness mismatch');\n      }\n      if (a.redeem.output) {\n        if (bscript.decompile(a.redeem.output).length === 0)\n          throw new TypeError('Redeem.output is invalid');\n        // output redeem is constructed from the witness\n        if (\n          o.redeem.output &&\n          tools.compare(a.redeem.output, o.redeem.output) !== 0\n        )\n          throw new TypeError('Redeem.output and witness mismatch');\n      }\n      if (a.redeem.witness) {\n        if (\n          o.redeem.witness &&\n          !stacksEqual(a.redeem.witness, o.redeem.witness)\n        )\n          throw new TypeError('Redeem.witness and witness mismatch');\n      }\n    }\n    if (witness && witness.length) {\n      if (witness.length === 1) {\n        // key spending\n        if (a.signature && tools.compare(a.signature, witness[0]) !== 0)\n          throw new TypeError('Signature mismatch');\n      } else {\n        // script path spending\n        const controlBlock = witness[witness.length - 1];\n        if (controlBlock.length < 33)\n          throw new TypeError(\n            `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n          );\n        if ((controlBlock.length - 33) % 32 !== 0)\n          throw new TypeError(\n            `The control-block length of ${controlBlock.length} is incorrect!`,\n          );\n        const m = (controlBlock.length - 33) / 32;\n        if (m > 128)\n          throw new TypeError(\n            `The script path is too long. Got ${m}, expected max 128.`,\n          );\n        const internalPubkey = controlBlock.slice(1, 33);\n        if (\n          a.internalPubkey &&\n          tools.compare(a.internalPubkey, internalPubkey) !== 0\n        )\n          throw new TypeError('Internal pubkey mismatch');\n        if (!getEccLib().isXOnlyPoint(internalPubkey))\n          throw new TypeError('Invalid internalPubkey for p2tr witness');\n        const leafVersion = controlBlock[0] & TAPLEAF_VERSION_MASK;\n        const script = witness[witness.length - 2];\n        const leafHash = tapleafHash({ output: script, version: leafVersion });\n        const hash = rootHashFromPath(controlBlock, leafHash);\n        const outputKey = tweakKey(internalPubkey, hash);\n        if (!outputKey)\n          // todo: needs test data\n          throw new TypeError('Invalid outputKey for p2tr witness');\n        if (pubkey.length && tools.compare(pubkey, outputKey.x) !== 0)\n          throw new TypeError('Pubkey mismatch for p2tr witness');\n        if (outputKey.parity !== (controlBlock[0] & 1))\n          throw new Error('Incorrect parity');\n      }\n    }\n  }\n  return Object.assign(o, a);\n}\n","import * as cashaddr from './cashaddr';\nimport * as networks from './networks.js';\nimport * as payments from './payments/index.js';\nimport * as bscript from './script.js';\nimport { Hash160bitSchema, UInt8Schema } from './types.js';\nimport { bech32, bech32m } from 'bech32';\nimport bs58check from 'bs58check';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst FUTURE_SEGWIT_MAX_SIZE = 40;\nconst FUTURE_SEGWIT_MIN_SIZE = 2;\nconst FUTURE_SEGWIT_MAX_VERSION = 16;\nconst FUTURE_SEGWIT_MIN_VERSION = 2;\nconst FUTURE_SEGWIT_VERSION_DIFF = 0x50;\nconst FUTURE_SEGWIT_VERSION_WARNING =\n  'WARNING: Sending to a future segwit version address can lead to loss of funds. ' +\n  'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' +\n  'with caution. Wallets should verify the segwit version from the output of fromBech32, ' +\n  'then decide when it is safe to use which version of segwit.';\n/**\n * Converts an output buffer to a future segwit address.\n * @param output - The output buffer.\n * @param network - The network object.\n * @returns The future segwit address.\n * @throws {TypeError} If the program length or version is invalid for segwit address.\n */\nfunction _toFutureSegwitAddress(output, network) {\n  const data = output.slice(2);\n  if (\n    data.length < FUTURE_SEGWIT_MIN_SIZE ||\n    data.length > FUTURE_SEGWIT_MAX_SIZE\n  )\n    throw new TypeError('Invalid program length for segwit address');\n  const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;\n  if (\n    version < FUTURE_SEGWIT_MIN_VERSION ||\n    version > FUTURE_SEGWIT_MAX_VERSION\n  )\n    throw new TypeError('Invalid version for segwit address');\n  if (output[1] !== data.length)\n    throw new TypeError('Invalid script for segwit address');\n  console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n  return toBech32(data, version, network.bech32);\n}\n/**\n * Decodes a base58check encoded Bitcoin address and returns the version and hash.\n *\n * @param address - The base58check encoded Bitcoin address to decode.\n * @returns An object containing the version and hash of the decoded address.\n * @throws {TypeError} If the address is too short or too long.\n */\nexport function fromBase58Check(address) {\n  const isBCH = cashaddr.VALID_PREFIXES.indexOf(address.split(':')[0]) > -1;\n  if (isBCH) {\n    const result = cashaddr.decode(address);\n    let network;\n    switch (result.prefix) {\n      case 'bitcoincash':\n        network = networks.bitcoin;\n        break;\n      case 'bchtest':\n        network = networks.testnet;\n        break;\n      case 'bchreg':\n        network = networks.regtest;\n        break;\n    }\n    let version;\n    switch (result.type) {\n      case 'P2PKH':\n        version = network.pubKeyHash;\n        break;\n      case 'P2SH':\n        version = network.scriptHash;\n        break;\n    }\n    if (result.hash.length < 20) throw new TypeError(address + ' is too short');\n    if (result.hash.length > 20) throw new TypeError(address + ' is too long');\n    return {\n      version: version,\n      hash: Buffer.from(result.hash),\n    };\n  } else {\n    const payload = Buffer.from(bs58check.decode(address));\n    // TODO: 4.0.0, move to \"toOutputScript\"\n    if (payload.length < 21) throw new TypeError(address + ' is too short');\n    if (payload.length > 21) throw new TypeError(address + ' is too long');\n    const version = tools.readUInt8(payload, 0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  }\n}\n/**\n * Converts a Bech32 or Bech32m encoded address to its corresponding data representation.\n * @param address - The Bech32 or Bech32m encoded address.\n * @returns An object containing the version, prefix, and data of the address.\n * @throws {TypeError} If the address uses the wrong encoding.\n */\nexport function fromBech32(address) {\n  let result;\n  let version;\n  try {\n    result = bech32.decode(address);\n  } catch (e) {}\n  if (result) {\n    version = result.words[0];\n    if (version !== 0) throw new TypeError(address + ' uses wrong encoding');\n  } else {\n    result = bech32m.decode(address);\n    version = result.words[0];\n    if (version === 0) throw new TypeError(address + ' uses wrong encoding');\n  }\n  const data = bech32.fromWords(result.words.slice(1));\n  return {\n    version,\n    prefix: result.prefix,\n    data: Uint8Array.from(data),\n  };\n}\n/**\n * Converts a hash to a Base58Check-encoded string.\n * @param hash - The hash to be encoded.\n * @param version - The version byte to be prepended to the encoded string.\n * @returns The Base58Check-encoded string.\n */\nexport function toBase58Check(hash, version) {\n  v.parse(v.tuple([Hash160bitSchema, UInt8Schema]), [hash, version]);\n  const payload = new Uint8Array(21);\n  tools.writeUInt8(payload, 0, version);\n  payload.set(hash, 1);\n  return bs58check.encode(payload);\n}\n/**\n * Converts a buffer to a Bech32 or Bech32m encoded string.\n * @param data - The buffer to be encoded.\n * @param version - The version number to be used in the encoding.\n * @param prefix - The prefix string to be used in the encoding.\n * @returns The Bech32 or Bech32m encoded string.\n */\nexport function toBech32(data, version, prefix) {\n  const words = bech32.toWords(data);\n  words.unshift(version);\n  return version === 0\n    ? bech32.encode(prefix, words)\n    : bech32m.encode(prefix, words);\n}\n/**\n * Converts an output script to a Bitcoin address.\n * @param output - The output script as a Buffer.\n * @param network - The Bitcoin network (optional).\n * @returns The Bitcoin address corresponding to the output script.\n * @throws If the output script has no matching address.\n */\nexport function fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n  try {\n    return payments.p2pkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2sh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wpkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wsh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2tr({ output, network }).address;\n  } catch (e) {}\n  try {\n    return _toFutureSegwitAddress(output, network);\n  } catch (e) {}\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\n/**\n * Converts a Bitcoin address to its corresponding output script.\n * @param address - The Bitcoin address to convert.\n * @param network - The Bitcoin network to use. Defaults to the Bitcoin network.\n * @returns The corresponding output script as a Buffer.\n * @throws If the address has an invalid prefix or no matching script.\n */\nexport function toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash)\n      return payments.p2pkh({ hash: decodeBase58.hash }).output;\n    if (decodeBase58.version === network.scriptHash)\n      return payments.p2sh({ hash: decodeBase58.hash }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32)\n        throw new Error(address + ' has an invalid prefix');\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20)\n          return payments.p2wpkh({ hash: decodeBech32.data }).output;\n        if (decodeBech32.data.length === 32)\n          return payments.p2wsh({ hash: decodeBech32.data }).output;\n      } else if (decodeBech32.version === 1) {\n        if (decodeBech32.data.length === 32)\n          return payments.p2tr({ pubkey: decodeBech32.data }).output;\n      } else if (\n        decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION &&\n        decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION &&\n        decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE &&\n        decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE\n      ) {\n        console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n        return bscript.compile([\n          decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,\n          decodeBech32.data,\n        ]);\n      }\n    }\n  }\n  throw new Error(address + ' has no matching Script');\n}\n","import {\n  BufferReader,\n  BufferWriter,\n  reverseBuffer,\n  varuint,\n} from './bufferutils.js';\nimport * as bcrypto from './crypto.js';\nimport { sha256 } from '@noble/hashes/sha256';\nimport * as bscript from './script.js';\nimport { OPS as opcodes } from './script.js';\nimport * as types from './types.js';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return varuint.encodingLength(length) + length;\n}\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return (\n    varuint.encodingLength(length) +\n    someVector.reduce((sum, witness) => {\n      return sum + varSliceSize(witness);\n    }, 0)\n  );\n}\nconst EMPTY_BUFFER = new Uint8Array(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = tools.fromHex(\n  '0000000000000000000000000000000000000000000000000000000000000000',\n);\nconst ONE = tools.fromHex(\n  '0000000000000000000000000000000000000000000000000000000000000001',\n);\nconst VALUE_UINT64_MAX = tools.fromHex('ffffffffffffffff');\nconst BLANK_OUTPUT = {\n  script: EMPTY_BUFFER,\n  valueBuffer: VALUE_UINT64_MAX,\n};\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\n/**\n * Represents a Bitcoin transaction.\n */\nexport class Transaction {\n  static DEFAULT_SEQUENCE = 0xffffffff;\n  static SIGHASH_DEFAULT = 0x00;\n  static SIGHASH_ALL = 0x01;\n  static SIGHASH_NONE = 0x02;\n  static SIGHASH_SINGLE = 0x03;\n  static SIGHASH_ANYONECANPAY = 0x80;\n  static SIGHASH_BITCOINCASHBIP143 = 0x40;\n  static SIGHASH_OUTPUT_MASK = 0x03;\n  static SIGHASH_INPUT_MASK = 0x80;\n  static ADVANCED_TRANSACTION_MARKER = 0x00;\n  static ADVANCED_TRANSACTION_FLAG = 0x01;\n  static FORKID_BTG = 0x4f; // 79\n  static FORKID_BCH = 0x00;\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n    if (\n      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG\n    ) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n    const vinLen = bufferReader.readVarInt();\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS,\n      });\n    }\n    const voutLen = bufferReader.readVarInt();\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readInt64(),\n        script: bufferReader.readVarSlice(),\n      });\n    }\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      }\n      // was this pointless?\n      if (!tx.hasWitnesses())\n        throw new Error('Transaction has superfluous witness data');\n    }\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length)\n      throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n  static fromHex(hex) {\n    return Transaction.fromBuffer(tools.fromHex(hex), false);\n  }\n  static isCoinbaseHash(buffer) {\n    v.parse(types.Hash256bitSchema, buffer);\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n    return true;\n  }\n  version = 1;\n  locktime = 0;\n  ins = [];\n  outs = [];\n  isCoinbase() {\n    return (\n      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n    );\n  }\n  addInput(hash, index, sequence, scriptSig) {\n    v.parse(\n      v.tuple([\n        types.Hash256bitSchema,\n        types.UInt32Schema,\n        v.nullable(v.optional(types.UInt32Schema)),\n        v.nullable(v.optional(types.BufferSchema)),\n      ]),\n      [hash, index, sequence, scriptSig],\n    );\n    if (sequence === undefined || sequence === null) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    }\n    // Add the input and return the input's index\n    return (\n      this.ins.push({\n        hash,\n        index,\n        script: scriptSig || EMPTY_BUFFER,\n        sequence: sequence,\n        witness: EMPTY_WITNESS,\n      }) - 1\n    );\n  }\n  addOutput(scriptPubKey, value) {\n    v.parse(v.tuple([types.BufferSchema, types.SatoshiSchema]), [\n      scriptPubKey,\n      value,\n    ]);\n    // Add the output and return the output's index\n    return (\n      this.outs.push({\n        script: scriptPubKey,\n        value,\n      }) - 1\n    );\n  }\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n  byteLength(_ALLOW_WITNESS = true) {\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    return (\n      (hasWitnesses ? 10 : 8) +\n      varuint.encodingLength(this.ins.length) +\n      varuint.encodingLength(this.outs.length) +\n      this.ins.reduce((sum, input) => {\n        return sum + 40 + varSliceSize(input.script);\n      }, 0) +\n      this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0) +\n      (hasWitnesses\n        ? this.ins.reduce((sum, input) => {\n            return sum + vectorSize(input.witness);\n          }, 0)\n        : 0)\n    );\n  }\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness,\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value,\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    v.parse(v.tuple([types.UInt32Schema, types.BufferSchema, v.number()]), [\n      inIndex,\n      prevOutScript,\n      hashType,\n    ]);\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n    if (inIndex >= this.ins.length) return ONE;\n    // ignore OP_CODESEPARATOR\n    const ourScript = bscript.compile(\n      bscript.decompile(prevOutScript).filter(x => {\n        return x !== opcodes.OP_CODESEPARATOR;\n      }),\n    );\n    const txTmp = this.clone();\n    // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = [];\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      });\n      // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE;\n      // truncate outputs after\n      txTmp.outs.length = inIndex + 1;\n      // \"blank\" outputs before\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      }\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    }\n    // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript;\n      // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_BUFFER;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    }\n    // serialize and hash\n    const buffer = new Uint8Array(txTmp.byteLength(false) + 4);\n    tools.writeInt32(buffer, buffer.length - 4, hashType, 'LE');\n    txTmp.__toBuffer(buffer, 0, false);\n    return bcrypto.hash256(buffer);\n  }\n  hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message\n    v.parse(\n      v.tuple([\n        types.UInt32Schema,\n        v.array(types.BufferSchema),\n        v.array(types.SatoshiSchema),\n        types.UInt32Schema,\n      ]),\n      [inIndex, prevOutScripts, values, hashType],\n    );\n    if (\n      values.length !== this.ins.length ||\n      prevOutScripts.length !== this.ins.length\n    ) {\n      throw new Error('Must supply prevout script and value for all inputs');\n    }\n    const outputType =\n      hashType === Transaction.SIGHASH_DEFAULT\n        ? Transaction.SIGHASH_ALL\n        : hashType & Transaction.SIGHASH_OUTPUT_MASK;\n    const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;\n    const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;\n    const isNone = outputType === Transaction.SIGHASH_NONE;\n    const isSingle = outputType === Transaction.SIGHASH_SINGLE;\n    let hashPrevouts = EMPTY_BUFFER;\n    let hashAmounts = EMPTY_BUFFER;\n    let hashScriptPubKeys = EMPTY_BUFFER;\n    let hashSequences = EMPTY_BUFFER;\n    let hashOutputs = EMPTY_BUFFER;\n    if (!isAnyoneCanPay) {\n      let bufferWriter = BufferWriter.withCapacity(36 * this.ins.length);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      // @ts-ignore\n      hashPrevouts = sha256(bufferWriter.end());\n      bufferWriter = BufferWriter.withCapacity(8 * this.ins.length);\n      values.forEach(value => bufferWriter.writeInt64(value));\n      // @ts-ignore\n      hashAmounts = sha256(bufferWriter.end());\n      bufferWriter = BufferWriter.withCapacity(\n        prevOutScripts.map(varSliceSize).reduce((a, b) => a + b),\n      );\n      prevOutScripts.forEach(prevOutScript =>\n        bufferWriter.writeVarSlice(prevOutScript),\n      );\n      // @ts-ignore\n      hashScriptPubKeys = sha256(bufferWriter.end());\n      bufferWriter = BufferWriter.withCapacity(4 * this.ins.length);\n      this.ins.forEach(txIn => bufferWriter.writeUInt32(txIn.sequence));\n      // @ts-ignore\n      hashSequences = sha256(bufferWriter.end());\n    }\n    if (!(isNone || isSingle)) {\n      if (!this.outs.length)\n        throw new Error('Add outputs to the transaction before signing.');\n      const txOutsSize = this.outs\n        .map(output => 8 + varSliceSize(output.script))\n        .reduce((a, b) => a + b);\n      const bufferWriter = BufferWriter.withCapacity(txOutsSize);\n      this.outs.forEach(out => {\n        bufferWriter.writeInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      // @ts-ignore\n      hashOutputs = sha256(bufferWriter.end());\n    } else if (isSingle && inIndex < this.outs.length) {\n      const output = this.outs[inIndex];\n      const bufferWriter = BufferWriter.withCapacity(\n        8 + varSliceSize(output.script),\n      );\n      bufferWriter.writeInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      // @ts-ignore\n      hashOutputs = sha256(bufferWriter.end());\n    }\n    const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);\n    // Length calculation from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-14\n    // With extension from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#signature-validation\n    const sigMsgSize =\n      174 -\n      (isAnyoneCanPay ? 49 : 0) -\n      (isNone ? 32 : 0) +\n      (annex ? 32 : 0) +\n      (leafHash ? 37 : 0);\n    const sigMsgWriter = BufferWriter.withCapacity(sigMsgSize);\n    sigMsgWriter.writeUInt8(hashType);\n    // Transaction\n    sigMsgWriter.writeInt32(this.version);\n    sigMsgWriter.writeUInt32(this.locktime);\n    sigMsgWriter.writeSlice(hashPrevouts);\n    sigMsgWriter.writeSlice(hashAmounts);\n    sigMsgWriter.writeSlice(hashScriptPubKeys);\n    sigMsgWriter.writeSlice(hashSequences);\n    if (!(isNone || isSingle)) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // Input\n    sigMsgWriter.writeUInt8(spendType);\n    if (isAnyoneCanPay) {\n      const input = this.ins[inIndex];\n      sigMsgWriter.writeSlice(input.hash);\n      sigMsgWriter.writeUInt32(input.index);\n      sigMsgWriter.writeInt64(values[inIndex]);\n      sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);\n      sigMsgWriter.writeUInt32(input.sequence);\n    } else {\n      sigMsgWriter.writeUInt32(inIndex);\n    }\n    if (annex) {\n      const bufferWriter = BufferWriter.withCapacity(varSliceSize(annex));\n      bufferWriter.writeVarSlice(annex);\n      sigMsgWriter.writeSlice(sha256(bufferWriter.end()));\n    }\n    // Output\n    if (isSingle) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // BIP342 extension\n    if (leafHash) {\n      sigMsgWriter.writeSlice(leafHash);\n      sigMsgWriter.writeUInt8(0);\n      sigMsgWriter.writeUInt32(0xffffffff);\n    }\n    // Extra zero byte because:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-19\n    return bcrypto.taggedHash(\n      'TapSighash',\n      tools.concat([Uint8Array.from([0x00]), sigMsgWriter.end()]),\n    );\n  }\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    v.parse(\n      v.tuple([\n        types.UInt32Schema,\n        types.BufferSchema,\n        types.SatoshiSchema,\n        types.UInt32Schema,\n      ]),\n      [inIndex, prevOutScript, value, hashType],\n    );\n    let tbuffer = Uint8Array.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = new Uint8Array(36 * this.ins.length);\n      bufferWriter = new BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n    if (\n      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      tbuffer = new Uint8Array(4 * this.ins.length);\n      bufferWriter = new BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n    if (\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = new Uint8Array(txOutsSize);\n      bufferWriter = new BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if (\n      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n      inIndex < this.outs.length\n    ) {\n      const output = this.outs[inIndex];\n      tbuffer = new Uint8Array(8 + varSliceSize(output.script));\n      bufferWriter = new BufferWriter(tbuffer, 0);\n      bufferWriter.writeInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n    tbuffer = new Uint8Array(156 + varSliceSize(prevOutScript));\n    bufferWriter = new BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n  /**\n   * Hash transaction for signing a specific input for Bitcoin Cash.\n   */\n  hashForCashSignature(inIndex, prevOutScript, inAmount, hashType) {\n    v.parse(\n      v.tuple([\n        types.UInt32Schema,\n        types.BufferSchema,\n        types.SatoshiSchema,\n        types.UInt53Schema,\n      ]),\n      [inIndex, prevOutScript, inAmount, hashType],\n    );\n    // This function works the way it does because Bitcoin Cash\n    // uses BIP143 as their replay protection, AND their algo\n    // includes `forkId | hashType`, AND since their forkId=0,\n    // this is a NOP, and has no difference to segwit. To support\n    // other forks, another parameter is required, and a new parameter\n    // would be required in the hashForWitnessV0 function, or\n    // it could be broken into two..\n    // BIP143 sighash activated in BitcoinCash via 0x40 bit\n    if (hashType & Transaction.SIGHASH_BITCOINCASHBIP143) {\n      return this.hashForWitnessV0(inIndex, prevOutScript, inAmount, hashType);\n    } else {\n      return this.hashForSignature(inIndex, prevOutScript, hashType);\n    }\n  }\n  /**\n   * Hash transaction for signing a specific input for Bitcoin Gold.\n   */\n  hashForGoldSignature(inIndex, prevOutScript, inAmount, hashType, sigVersion) {\n    v.parse(\n      v.tuple([\n        types.UInt32Schema,\n        types.BufferSchema,\n        types.SatoshiSchema,\n        types.UInt53Schema,\n      ]),\n      [inIndex, prevOutScript, inAmount, hashType],\n    );\n    // Bitcoin Gold also implements segregated witness\n    // therefore we can pull out the setting of nForkHashType\n    // and pass it into the functions.\n    let nForkHashType = hashType;\n    const fUseForkId = (hashType & Transaction.SIGHASH_BITCOINCASHBIP143) > 0;\n    if (fUseForkId) {\n      nForkHashType |= Transaction.FORKID_BTG << 8;\n    }\n    // BIP143 sighash activated in BitcoinCash via 0x40 bit\n    if (sigVersion || fUseForkId) {\n      return this.hashForWitnessV0(\n        inIndex,\n        prevOutScript,\n        inAmount,\n        nForkHashType,\n      );\n    } else {\n      return this.hashForSignature(inIndex, prevOutScript, nForkHashType);\n    }\n  }\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return new Uint8Array(32);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return tools.toHex(reverseBuffer(this.getHash(false)));\n  }\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n  toHex() {\n    return tools.toHex(this.toBuffer(undefined, undefined));\n  }\n  setInputScript(index, scriptSig) {\n    v.parse(v.tuple([v.number(), types.BufferSchema]), [index, scriptSig]);\n    this.ins[index].script = scriptSig;\n  }\n  setWitness(index, witness) {\n    v.parse(v.tuple([v.number(), v.array(types.BufferSchema)]), [\n      index,\n      witness,\n    ]);\n    this.ins[index].witness = witness;\n  }\n  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n    if (!buffer) buffer = new Uint8Array(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new BufferWriter(buffer, initialOffset || 0);\n    bufferWriter.writeInt32(this.version);\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n    bufferWriter.writeUInt32(this.locktime);\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined)\n      return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n}\n","import {\n  BufferReader,\n  BufferWriter,\n  reverseBuffer,\n  varuint,\n} from './bufferutils.js';\nimport * as bcrypto from './crypto.js';\nimport { fastMerkleRoot } from './merkle.js';\nimport { Transaction } from './transaction.js';\nimport * as v from 'valibot';\nimport * as tools from 'uint8array-tools';\nconst errorMerkleNoTxes = new TypeError(\n  'Cannot compute merkle root for zero transactions',\n);\nconst errorWitnessNotSegwit = new TypeError(\n  'Cannot compute witness commit for non-segwit block',\n);\nexport class Block {\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n    const readTransaction = () => {\n      const tx = Transaction.fromBuffer(\n        bufferReader.buffer.slice(bufferReader.offset),\n        true,\n      );\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n    const witnessCommit = block.getWitnessCommit();\n    // This Block contains a witness commit\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n  static fromHex(hex) {\n    return Block.fromBuffer(tools.fromHex(hex));\n  }\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = new Uint8Array(32);\n    target[29 - exponent] = (mantissa >> 16) & 0xff;\n    target[30 - exponent] = (mantissa >> 8) & 0xff;\n    target[31 - exponent] = mantissa & 0xff;\n    return target;\n  }\n  static calculateMerkleRoot(transactions, forWitness) {\n    v.parse(v.array(v.object({ getHash: v.function() })), transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions))\n      throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction =>\n      transaction.getHash(forWitness),\n    );\n    const rootHash = fastMerkleRoot(hashes, bcrypto.hash256);\n    return forWitness\n      ? bcrypto.hash256(\n          tools.concat([rootHash, transactions[0].ins[0].witness[0]]),\n        )\n      : rootHash;\n  }\n  version = 1;\n  prevHash = undefined;\n  merkleRoot = undefined;\n  timestamp = 0;\n  witnessCommit = undefined;\n  bits = 0;\n  nonce = 0;\n  transactions = undefined;\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null;\n    // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n    const witnessCommits = this.transactions[0].outs\n      .filter(\n        out =>\n          tools.compare(\n            out.script.slice(0, 6),\n            Uint8Array.from([0x6a, 0x24, 0xaa, 0x21, 0xa9, 0xed]),\n          ) === 0,\n      )\n      .map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null;\n    // Use the commit with the highest output (should only be one though)\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Uint8Array && result.length === 32)) return null;\n    return result;\n  }\n  hasWitnessCommit() {\n    if (\n      this.witnessCommit instanceof Uint8Array &&\n      this.witnessCommit.length === 32\n    )\n      return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n  byteLength(headersOnly, allowWitness = true) {\n    if (headersOnly || !this.transactions) return 80;\n    return (\n      80 +\n      varuint.encodingLength(this.transactions.length) +\n      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)\n    );\n  }\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n  getId() {\n    return tools.toHex(reverseBuffer(this.getHash()));\n  }\n  getUTCDate() {\n    const date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  }\n  // TODO: buffer, offset compatibility\n  toBuffer(headersOnly) {\n    const buffer = new Uint8Array(this.byteLength(headersOnly));\n    const bufferWriter = new BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    const { bytes } = varuint.encode(\n      this.transactions.length,\n      buffer,\n      bufferWriter.offset,\n    );\n    bufferWriter.offset += bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n  toHex(headersOnly) {\n    return tools.toHex(this.toBuffer(headersOnly));\n  }\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return (\n      this.__checkMerkleRoot() &&\n      (hasWitnessCommit ? this.__checkWitnessCommit() : true)\n    );\n  }\n  checkProofOfWork() {\n    const hash = reverseBuffer(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return tools.compare(hash, target) <= 0;\n  }\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return tools.compare(this.merkleRoot, actualMerkleRoot) === 0;\n  }\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(\n      this.transactions,\n      true,\n    );\n    return tools.compare(this.witnessCommit, actualWitnessCommit) === 0;\n  }\n}\nfunction txesHaveWitnessCommit(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions[0] &&\n    transactions[0].ins &&\n    transactions[0].ins instanceof Array &&\n    transactions[0].ins[0] &&\n    transactions[0].ins[0].witness &&\n    transactions[0].ins[0].witness instanceof Array &&\n    transactions[0].ins[0].witness.length > 0\n  );\n}\nfunction anyTxHasWitness(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions.some(\n      tx =>\n        typeof tx === 'object' &&\n        tx.ins instanceof Array &&\n        tx.ins.some(\n          input =>\n            typeof input === 'object' &&\n            input.witness instanceof Array &&\n            input.witness.length > 0,\n        ),\n    )\n  );\n}\n","import * as varuint from 'varuint-bitcoin';\nimport * as bscript from '../script.js';\nimport { Transaction } from '../transaction.js';\nimport { hash160 } from '../crypto.js';\nimport * as payments from '../payments/index.js';\nimport * as tools from 'uint8array-tools';\n/**\n * Checks if a given payment factory can generate a payment script from a given script.\n * @param payment The payment factory to check.\n * @returns A function that takes a script and returns a boolean indicating whether the payment factory can generate a payment script from the script.\n */\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({ output: script });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\nexport const isP2MS = isPaymentFactory(payments.p2ms);\nexport const isP2PK = isPaymentFactory(payments.p2pk);\nexport const isP2PKH = isPaymentFactory(payments.p2pkh);\nexport const isP2WPKH = isPaymentFactory(payments.p2wpkh);\nexport const isP2WSHScript = isPaymentFactory(payments.p2wsh);\nexport const isP2SHScript = isPaymentFactory(payments.p2sh);\nexport const isP2TR = isPaymentFactory(payments.p2tr);\n/**\n * Converts a witness stack to a script witness.\n * @param witness The witness stack to convert.\n * @returns The script witness as a Buffer.\n */\nexport function witnessStackToScriptWitness(witness) {\n  let buffer = new Uint8Array(0);\n  function writeSlice(slice) {\n    // @ts-ignore\n    buffer = tools.concat([buffer, slice]);\n  }\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    // @ts-ignore\n    buffer = tools.concat([buffer, new Uint8Array(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n  writeVector(witness);\n  return buffer;\n}\n/**\n * Finds the position of a public key in a script.\n * @param pubkey The public key to search for.\n * @param script The script to search in.\n * @returns The index of the public key in the script, or -1 if not found.\n * @throws {Error} If there is an unknown script error.\n */\nexport function pubkeyPositionInScript(pubkey, script) {\n  const pubkeyHash = hash160(pubkey);\n  const pubkeyXOnly = pubkey.slice(1, 33); // slice before calling?\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  return decompiled.findIndex(element => {\n    if (typeof element === 'number') return false;\n    return (\n      tools.compare(pubkey, element) === 0 ||\n      tools.compare(pubkeyHash, element) === 0 ||\n      tools.compare(pubkeyXOnly, element) === 0\n    );\n  });\n}\n/**\n * Checks if a public key is present in a script.\n * @param pubkey The public key to check.\n * @param script The script to search in.\n * @returns A boolean indicating whether the public key is present in the script.\n */\nexport function pubkeyInScript(pubkey, script) {\n  return pubkeyPositionInScript(pubkey, script) !== -1;\n}\n/**\n * Checks if an input contains a signature for a specific action.\n * @param input - The input to check.\n * @param action - The action to check for.\n * @returns A boolean indicating whether the input contains a signature for the specified action.\n */\nexport function checkInputForSig(input, action) {\n  const pSigs = extractPartialSigs(input);\n  return pSigs.some(pSig =>\n    signatureBlocksAction(pSig, bscript.signature.decode, action),\n  );\n}\n/**\n * Determines if a given action is allowed for a signature block.\n * @param signature - The signature block.\n * @param signatureDecodeFn - The function used to decode the signature.\n * @param action - The action to be checked.\n * @returns True if the action is allowed, false otherwise.\n */\nexport function signatureBlocksAction(signature, signatureDecodeFn, action) {\n  const { hashType } = signatureDecodeFn(signature);\n  const whitelist = [];\n  const isAnyoneCanPay = hashType & Transaction.SIGHASH_ANYONECANPAY;\n  if (isAnyoneCanPay) whitelist.push('addInput');\n  const hashMod = hashType & 0x1f;\n  switch (hashMod) {\n    case Transaction.SIGHASH_ALL:\n      break;\n    case Transaction.SIGHASH_SINGLE:\n    case Transaction.SIGHASH_NONE:\n      whitelist.push('addOutput');\n      whitelist.push('setInputSequence');\n      break;\n  }\n  if (whitelist.indexOf(action) === -1) {\n    return true;\n  }\n  return false;\n}\n/**\n * Extracts the signatures from a PsbtInput object.\n * If the input has partial signatures, it returns an array of the signatures.\n * If the input does not have partial signatures, it checks if it has a finalScriptSig or finalScriptWitness.\n * If it does, it extracts the signatures from the final scripts and returns them.\n * If none of the above conditions are met, it returns an empty array.\n *\n * @param input - The PsbtInput object from which to extract the signatures.\n * @returns An array of signatures extracted from the PsbtInput object.\n */\nfunction extractPartialSigs(input) {\n  let pSigs = [];\n  if ((input.partialSig || []).length === 0) {\n    if (!input.finalScriptSig && !input.finalScriptWitness) return [];\n    pSigs = getPsigsFromInputFinalScripts(input);\n  } else {\n    pSigs = input.partialSig;\n  }\n  return pSigs.map(p => p.signature);\n}\n/**\n * Retrieves the partial signatures (Psigs) from the input's final scripts.\n * Psigs are extracted from both the final scriptSig and final scriptWitness of the input.\n * Only canonical script signatures are considered.\n *\n * @param input - The PsbtInput object representing the input.\n * @returns An array of PartialSig objects containing the extracted Psigs.\n */\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig\n    ? []\n    : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness\n    ? []\n    : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems\n    .concat(witnessItems)\n    .filter(item => {\n      return (\n        item instanceof Uint8Array && bscript.isCanonicalScriptSignature(item)\n      );\n    })\n    .map(sig => ({ signature: sig }));\n}\n","import { isTapleaf, isTaptree } from '../types.js';\nimport { Transaction } from '../transaction.js';\nimport {\n  witnessStackToScriptWitness,\n  pubkeyPositionInScript,\n  isP2TR,\n} from './psbtutils.js';\nimport {\n  tweakKey,\n  tapleafHash,\n  rootHashFromPath,\n  LEAF_VERSION_TAPSCRIPT,\n  MAX_TAPTREE_DEPTH,\n} from '../payments/bip341.js';\nimport { p2tr } from '../payments/index.js';\nimport * as tools from 'uint8array-tools';\nimport { signatureBlocksAction } from './psbtutils.js';\n/**\n * Converts a public key to an X-only public key.\n * @param pubKey The public key to convert.\n * @returns The X-only public key.\n */\nexport const toXOnly = pubKey =>\n  pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);\n/**\n * Default tapscript finalizer. It searches for the `tapLeafHashToFinalize` if provided.\n * Otherwise it will search for the tapleaf that has at least one signature and has the shortest path.\n * @param inputIndex the position of the PSBT input.\n * @param input the PSBT input.\n * @param tapLeafHashToFinalize optional, if provided the finalizer will search for a tapleaf that has this hash\n *                              and will try to build the finalScriptWitness.\n * @returns the finalScriptWitness or throws an exception if no tapleaf found.\n */\nexport function tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {\n  const tapLeaf = findTapLeafToFinalize(\n    input,\n    inputIndex,\n    tapLeafHashToFinalize,\n  );\n  try {\n    const sigs = sortSignatures(input, tapLeaf);\n    const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);\n    return { finalScriptWitness: witnessStackToScriptWitness(witness) };\n  } catch (err) {\n    throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);\n  }\n}\n/**\n * Serializes a taproot signature.\n * @param sig The signature to serialize.\n * @param sighashType The sighash type. Optional.\n * @returns The serialized taproot signature.\n */\nexport function serializeTaprootSignature(sig, sighashType) {\n  const sighashTypeByte = sighashType\n    ? Uint8Array.from([sighashType])\n    : Uint8Array.from([]);\n  return tools.concat([sig, sighashTypeByte]);\n}\n/**\n * Checks if a PSBT input is a taproot input.\n * @param input The PSBT input to check.\n * @returns True if the input is a taproot input, false otherwise.\n */\nexport function isTaprootInput(input) {\n  return (\n    input &&\n    !!(\n      input.tapInternalKey ||\n      input.tapMerkleRoot ||\n      (input.tapLeafScript && input.tapLeafScript.length) ||\n      (input.tapBip32Derivation && input.tapBip32Derivation.length) ||\n      (input.witnessUtxo && isP2TR(input.witnessUtxo.script))\n    )\n  );\n}\n/**\n * Checks if a PSBT output is a taproot output.\n * @param output The PSBT output to check.\n * @param script The script to check. Optional.\n * @returns True if the output is a taproot output, false otherwise.\n */\nexport function isTaprootOutput(output, script) {\n  return (\n    output &&\n    !!(\n      output.tapInternalKey ||\n      output.tapTree ||\n      (output.tapBip32Derivation && output.tapBip32Derivation.length) ||\n      (script && isP2TR(script))\n    )\n  );\n}\n/**\n * Checks the taproot input fields for consistency.\n * @param inputData The original input data.\n * @param newInputData The new input data.\n * @param action The action being performed.\n * @throws Throws an error if the input fields are inconsistent.\n */\nexport function checkTaprootInputFields(inputData, newInputData, action) {\n  checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);\n  checkIfTapLeafInTree(inputData, newInputData, action);\n}\n/**\n * Checks the taproot output fields for consistency.\n * @param outputData The original output data.\n * @param newOutputData The new output data.\n * @param action The action being performed.\n * @throws Throws an error if the output fields are inconsistent.\n */\nexport function checkTaprootOutputFields(outputData, newOutputData, action) {\n  checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);\n  checkTaprootScriptPubkey(outputData, newOutputData);\n}\nfunction checkTaprootScriptPubkey(outputData, newOutputData) {\n  if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;\n  const tapInternalKey =\n    newOutputData.tapInternalKey || outputData.tapInternalKey;\n  const tapTree = newOutputData.tapTree || outputData.tapTree;\n  if (tapInternalKey) {\n    const { script: scriptPubkey } = outputData;\n    const script = getTaprootScripPubkey(tapInternalKey, tapTree);\n    if (scriptPubkey && tools.compare(script, scriptPubkey) !== 0)\n      throw new Error('Error adding output. Script or address mismatch.');\n  }\n}\n/**\n * Returns the Taproot script public key.\n *\n * @param tapInternalKey - The Taproot internal key.\n * @param tapTree - The Taproot tree (optional).\n * @returns The Taproot script public key.\n */\nfunction getTaprootScripPubkey(tapInternalKey, tapTree) {\n  const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);\n  const { output } = p2tr({\n    internalPubkey: tapInternalKey,\n    scriptTree,\n  });\n  return output;\n}\n/**\n * Tweak the internal public key for a specific input.\n * @param inputIndex - The index of the input.\n * @param input - The PsbtInput object representing the input.\n * @returns The tweaked internal public key.\n * @throws Error if the tap internal key cannot be tweaked.\n */\nexport function tweakInternalPubKey(inputIndex, input) {\n  const tapInternalKey = input.tapInternalKey;\n  const outputKey =\n    tapInternalKey && tweakKey(tapInternalKey, input.tapMerkleRoot);\n  if (!outputKey)\n    throw new Error(\n      `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${\n        // tapInternalKey && tapInternalKey.toString('hex')\n        tapInternalKey && tools.toHex(tapInternalKey)\n      }`,\n    );\n  return outputKey.x;\n}\n/**\n * Convert a binary tree to a BIP371 type list. Each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @param tree the binary tap tree\n * @returns a list of BIP 371 tapleaves\n */\nexport function tapTreeToList(tree) {\n  if (!isTaptree(tree))\n    throw new Error(\n      'Cannot convert taptree to tapleaf list. Expecting a tapree structure.',\n    );\n  return _tapTreeToList(tree);\n}\n/**\n * Convert a BIP371 TapLeaf list to a TapTree (binary).\n * @param leaves a list of tapleaves where each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @returns the corresponding taptree, or throws an exception if the tree cannot be reconstructed\n */\nexport function tapTreeFromList(leaves = []) {\n  if (leaves.length === 1 && leaves[0].depth === 0)\n    return {\n      output: leaves[0].script,\n      version: leaves[0].leafVersion,\n    };\n  return instertLeavesInTree(leaves);\n}\n/**\n * Checks the taproot input for signatures.\n * @param input The PSBT input to check.\n * @param action The action being performed.\n * @returns True if the input has taproot signatures, false otherwise.\n */\nexport function checkTaprootInputForSigs(input, action) {\n  const sigs = extractTaprootSigs(input);\n  return sigs.some(sig =>\n    signatureBlocksAction(sig, decodeSchnorrSignature, action),\n  );\n}\n/**\n * Decodes a Schnorr signature.\n * @param signature The signature to decode.\n * @returns The decoded Schnorr signature.\n */\nfunction decodeSchnorrSignature(signature) {\n  return {\n    signature: signature.slice(0, 64),\n    hashType: signature.slice(64)[0] || Transaction.SIGHASH_DEFAULT,\n  };\n}\n/**\n * Extracts taproot signatures from a PSBT input.\n * @param input The PSBT input to extract signatures from.\n * @returns An array of taproot signatures.\n */\nfunction extractTaprootSigs(input) {\n  const sigs = [];\n  if (input.tapKeySig) sigs.push(input.tapKeySig);\n  if (input.tapScriptSig)\n    sigs.push(...input.tapScriptSig.map(s => s.signature));\n  if (!sigs.length) {\n    const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);\n    if (finalTapKeySig) sigs.push(finalTapKeySig);\n  }\n  return sigs;\n}\n/**\n * Gets the taproot signature from the witness.\n * @param finalScriptWitness The final script witness.\n * @returns The taproot signature, or undefined if not found.\n */\nfunction getTapKeySigFromWithness(finalScriptWitness) {\n  if (!finalScriptWitness) return;\n  const witness = finalScriptWitness.slice(2);\n  // todo: add schnorr signature validation\n  if (witness.length === 64 || witness.length === 65) return witness;\n}\n/**\n * Converts a binary tree to a BIP371 type list.\n * @param tree The binary tap tree.\n * @param leaves A list of tapleaves. Optional.\n * @param depth The current depth. Optional.\n * @returns A list of BIP 371 tapleaves.\n * @throws Throws an error if the taptree cannot be converted to a tapleaf list.\n */\nfunction _tapTreeToList(tree, leaves = [], depth = 0) {\n  if (depth > MAX_TAPTREE_DEPTH) throw new Error('Max taptree depth exceeded.');\n  if (!tree) return [];\n  if (isTapleaf(tree)) {\n    leaves.push({\n      depth,\n      leafVersion: tree.version || LEAF_VERSION_TAPSCRIPT,\n      script: tree.output,\n    });\n    return leaves;\n  }\n  if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);\n  if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);\n  return leaves;\n}\n/**\n * Inserts the tapleaves into the taproot tree.\n * @param leaves The tapleaves to insert.\n * @returns The taproot tree.\n * @throws Throws an error if there is no room left to insert a tapleaf in the tree.\n */\nfunction instertLeavesInTree(leaves) {\n  let tree;\n  for (const leaf of leaves) {\n    tree = instertLeafInTree(leaf, tree);\n    if (!tree) throw new Error(`No room left to insert tapleaf in tree`);\n  }\n  return tree;\n}\n/**\n * Inserts a tapleaf into the taproot tree.\n * @param leaf The tapleaf to insert.\n * @param tree The taproot tree.\n * @param depth The current depth. Optional.\n * @returns The updated taproot tree.\n */\nfunction instertLeafInTree(leaf, tree, depth = 0) {\n  if (depth > MAX_TAPTREE_DEPTH) throw new Error('Max taptree depth exceeded.');\n  if (leaf.depth === depth) {\n    if (!tree)\n      return {\n        output: leaf.script,\n        version: leaf.leafVersion,\n      };\n    return;\n  }\n  if (isTapleaf(tree)) return;\n  const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);\n  if (leftSide) return [leftSide, tree && tree[1]];\n  const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);\n  if (rightSide) return [tree && tree[0], rightSide];\n}\n/**\n * Checks the input fields for mixed taproot and non-taproot fields.\n * @param inputData The original input data.\n * @param newInputData The new input data.\n * @param action The action being performed.\n * @throws Throws an error if the input fields are inconsistent.\n */\nfunction checkMixedTaprootAndNonTaprootInputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootInput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootInput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootInput(newInputData) &&\n    hasNonTaprootFields(newInputData); // todo: bad? use !===\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\n/**\n * Checks the output fields for mixed taproot and non-taproot fields.\n * @param inputData The original output data.\n * @param newInputData The new output data.\n * @param action The action being performed.\n * @throws Throws an error if the output fields are inconsistent.\n */\nfunction checkMixedTaprootAndNonTaprootOutputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootOutput(newInputData) &&\n    hasNonTaprootFields(newInputData);\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\n/**\n * Checks if the tap leaf is part of the tap tree for the given input data.\n * Throws an error if the tap leaf is not part of the tap tree.\n * @param inputData - The original PsbtInput data.\n * @param newInputData - The new PsbtInput data.\n * @param action - The action being performed.\n * @throws {Error} - If the tap leaf is not part of the tap tree.\n */\nfunction checkIfTapLeafInTree(inputData, newInputData, action) {\n  if (newInputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    const oldLeafsInTree = (inputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree || !oldLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  } else if (inputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, inputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  }\n}\n/**\n * Checks if a TapLeafScript is present in a Merkle tree.\n * @param tapLeaf The TapLeafScript to check.\n * @param merkleRoot The Merkle root of the tree. If not provided, the function assumes the TapLeafScript is present.\n * @returns A boolean indicating whether the TapLeafScript is present in the tree.\n */\nfunction isTapLeafInTree(tapLeaf, merkleRoot) {\n  if (!merkleRoot) return true;\n  const leafHash = tapleafHash({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  const rootHash = rootHashFromPath(tapLeaf.controlBlock, leafHash);\n  return tools.compare(rootHash, merkleRoot) === 0;\n}\n/**\n * Sorts the signatures in the input's tapScriptSig array based on their position in the tapLeaf script.\n *\n * @param input - The PsbtInput object.\n * @param tapLeaf - The TapLeafScript object.\n * @returns An array of sorted signatures as Buffers.\n */\nfunction sortSignatures(input, tapLeaf) {\n  const leafHash = tapleafHash({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  return (\n    (input.tapScriptSig || [])\n      // .filter(tss => tss.leafHash.equals(leafHash))\n      .filter(tss => tools.compare(tss.leafHash, leafHash) === 0)\n      .map(tss => addPubkeyPositionInScript(tapLeaf.script, tss))\n      .sort((t1, t2) => t2.positionInScript - t1.positionInScript)\n      .map(t => t.signature)\n  );\n}\n/**\n * Adds the position of a public key in a script to a TapScriptSig object.\n * @param script The script in which to find the position of the public key.\n * @param tss The TapScriptSig object to add the position to.\n * @returns A TapScriptSigWitPosition object with the added position.\n */\nfunction addPubkeyPositionInScript(script, tss) {\n  return Object.assign(\n    {\n      positionInScript: pubkeyPositionInScript(tss.pubkey, script),\n    },\n    tss,\n  );\n}\n/**\n * Find tapleaf by hash, or get the signed tapleaf with the shortest path.\n */\nfunction findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {\n  if (!input.tapScriptSig || !input.tapScriptSig.length)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`,\n    );\n  const tapLeaf = (input.tapLeafScript || [])\n    .sort((a, b) => a.controlBlock.length - b.controlBlock.length)\n    .find(leaf =>\n      canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize),\n    );\n  if (!tapLeaf)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`,\n    );\n  return tapLeaf;\n}\n/**\n * Determines whether a TapLeafScript can be finalized.\n *\n * @param leaf - The TapLeafScript to check.\n * @param tapScriptSig - The array of TapScriptSig objects.\n * @param hash - The optional hash to compare with the leaf hash.\n * @returns A boolean indicating whether the TapLeafScript can be finalized.\n */\nfunction canFinalizeLeaf(leaf, tapScriptSig, hash) {\n  const leafHash = tapleafHash({\n    output: leaf.script,\n    version: leaf.leafVersion,\n  });\n  const whiteListedHash = !hash || tools.compare(leafHash, hash) === 0;\n  return (\n    whiteListedHash &&\n    tapScriptSig.find(tss => tools.compare(tss.leafHash, leafHash) === 0) !==\n      undefined\n  );\n}\n/**\n * Checks if the given PsbtInput or PsbtOutput has non-taproot fields.\n * Non-taproot fields include redeemScript, witnessScript, and bip32Derivation.\n * @param io The PsbtInput or PsbtOutput to check.\n * @returns A boolean indicating whether the given input or output has non-taproot fields.\n */\nfunction hasNonTaprootFields(io) {\n  return (\n    io &&\n    !!(\n      io.redeemScript ||\n      io.witnessScript ||\n      (io.bip32Derivation && io.bip32Derivation.length)\n    )\n  );\n}\n","import { Psbt as PsbtBase } from 'bip174';\nimport * as varuint from 'varuint-bitcoin';\nimport { checkForInput, checkForOutput } from 'bip174';\nimport { fromOutputScript, toOutputScript } from './address.js';\nimport { cloneBuffer, reverseBuffer } from './bufferutils.js';\nimport { bitcoin as btcNetwork } from './networks.js';\nimport * as payments from './payments/index.js';\nimport { tapleafHash } from './payments/bip341.js';\nimport * as bscript from './script.js';\nimport { Transaction } from './transaction.js';\nimport {\n  toXOnly,\n  tapScriptFinalizer,\n  serializeTaprootSignature,\n  isTaprootInput,\n  checkTaprootInputFields,\n  checkTaprootOutputFields,\n  checkTaprootInputForSigs,\n} from './psbt/bip371.js';\nimport {\n  witnessStackToScriptWitness,\n  checkInputForSig,\n  pubkeyInScript,\n  isP2MS,\n  isP2PK,\n  isP2PKH,\n  isP2WPKH,\n  isP2WSHScript,\n  isP2SHScript,\n  isP2TR,\n} from './psbt/psbtutils.js';\nimport * as tools from 'uint8array-tools';\nconst BCH_SIGHASH_ALL =\n  Transaction.SIGHASH_ALL | Transaction.SIGHASH_BITCOINCASHBIP143;\nconst BTG_SIGHASH_ALL =\n  Transaction.SIGHASH_ALL |\n  Transaction.SIGHASH_BITCOINCASHBIP143 |\n  (Transaction.FORKID_BTG << 8);\nconst DEFAULT_SIGHASHES = [\n  // BTC SIGHASH_ALL\n  Transaction.SIGHASH_ALL,\n  // BCH SIGHASH_ALL\n  BCH_SIGHASH_ALL,\n  // BTG SIGHASH_ALL\n  BTG_SIGHASH_ALL,\n];\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: btcNetwork,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000, // satoshi per byte\n  forkCoin: 'none', // use btg or bch to sign with forkID\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n *\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n *\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n *\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n *\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n *\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nexport class Psbt {\n  data;\n  static fromBase64(data, opts = {}) {\n    const buffer = tools.fromBase64(data);\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data, opts = {}) {\n    const buffer = tools.fromHex(data);\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = PsbtBase.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  __CACHE;\n  opts;\n  constructor(opts = {}, data = new PsbtBase(new PsbtTransaction())) {\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n      // Psbt's predecessor (TransactionBuilder - now removed) behavior\n      // was to not confirm input values  before signing.\n      // Even though we highly encourage people to get\n      // the full parent transaction to verify values, the ability to\n      // sign non-segwit inputs without the full transaction was often\n      // requested. So the only way to activate is to use @ts-ignore.\n      // We will disable exporting the Psbt when unsafe sign is active.\n      // because it is not BIP174 compliant.\n      __UNSAFE_SIGN_NONSEGWIT: false,\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) =>\n      Object.defineProperty(obj, attr, {\n        enumerable,\n        writable,\n      });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n  set version(version) {\n    this.setVersion(version);\n  }\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: cloneBuffer(input.hash),\n      index: input.index,\n      sequence: input.sequence,\n    }));\n  }\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n      try {\n        address = fromOutputScript(output.script, this.opts.network);\n      } catch (_) {}\n      return {\n        script: cloneBuffer(output.script),\n        value: output.value,\n        address,\n      };\n    });\n  }\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (\n      arguments.length > 1 ||\n      !inputData ||\n      inputData.hash === undefined ||\n      inputData.index === undefined\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addInput. ` +\n          `Requires single object with at least [hash] and [index]`,\n      );\n    }\n    checkTaprootInputFields(inputData, inputData, 'addInput');\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (\n      arguments.length > 1 ||\n      !outputData ||\n      outputData.value === undefined ||\n      (outputData.address === undefined && outputData.script === undefined)\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addOutput. ` +\n          `Requires single object with at least [script or address] and [value]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const { address } = outputData;\n    if (typeof address === 'string') {\n      const { network } = this.opts;\n      const script = toOutputScript(address, network);\n      outputData = Object.assign({}, outputData, { script });\n    }\n    checkTaprootOutputFields(outputData, outputData, 'addOutput');\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue(\n      '__FEE_RATE',\n      'fee rate',\n      this.data.inputs,\n      this.__CACHE,\n    );\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    checkForInput(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc) {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (isTaprootInput(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        undefined,\n        finalScriptsFunc,\n      );\n    return this._finalizeInput(inputIndex, input, finalScriptsFunc);\n  }\n  finalizeTaprootInput(\n    inputIndex,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = tapScriptFinalizer,\n  ) {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (isTaprootInput(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n        finalScriptsFunc,\n      );\n    throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);\n  }\n  _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {\n    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(\n      inputIndex,\n      input,\n      this.__CACHE,\n    );\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(\n      inputIndex,\n      input,\n      script,\n      isSegwit,\n      isP2SH,\n      isP2WSH,\n    );\n    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });\n    if (finalScriptWitness)\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    if (!finalScriptSig && !finalScriptWitness)\n      throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  _finalizeTaprootInput(\n    inputIndex,\n    input,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = tapScriptFinalizer,\n  ) {\n    if (!input.witnessUtxo)\n      throw new Error(\n        `Cannot finalize input #${inputIndex}. Missing withness utxo.`,\n      );\n    // Check key spend first. Increased privacy and reduced block space.\n    if (input.tapKeySig) {\n      const payment = payments.p2tr({\n        output: input.witnessUtxo.script,\n        signature: input.tapKeySig,\n      });\n      const finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    } else {\n      const { finalScriptWitness } = finalScriptsFunc(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n      );\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    }\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  getInputType(inputIndex) {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n    const result = getMeaningfulScript(\n      script,\n      inputIndex,\n      'input',\n      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),\n      input.witnessScript ||\n        redeemFromFinalWitnessScript(input.finalScriptWitness),\n    );\n    const type = result.type === 'raw' ? '' : result.type + '-';\n    const mainType = classifyScript(result.meaningfulScript);\n    return type + mainType;\n  }\n  inputHasPubkey(inputIndex, pubkey) {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n  }\n  inputHasHDKey(inputIndex, root) {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  outputHasPubkey(outputIndex, pubkey) {\n    const output = checkForOutput(this.data.outputs, outputIndex);\n    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n  }\n  outputHasHDKey(outputIndex, root) {\n    const output = checkForOutput(this.data.outputs, outputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  validateSignaturesOfAllInputs(validator) {\n    checkForInput(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx =>\n      this.validateSignaturesOfInput(idx, validator),\n    );\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    if (isTaprootInput(input))\n      return this.validateSignaturesOfTaprootInput(\n        inputIndex,\n        validator,\n        pubkey,\n      );\n    return this._validateSignaturesOfInput(inputIndex, validator, pubkey);\n  }\n  _validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1)\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    const mySigs = pubkey\n      ? partialSig.filter(sig => tools.compare(sig.pubkey, pubkey) === 0)\n      : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const { hash, script } =\n        sighashCache !== sig.hashType\n          ? getHashForSig(\n              inputIndex,\n              Object.assign({}, input, { sighashType: sig.hashType }),\n              this.__CACHE,\n              true,\n              this.opts.forkCoin,\n            )\n          : { hash: hashCache, script: scriptCache };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      results.push(validator(pSig.pubkey, hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const tapKeySig = (input || {}).tapKeySig;\n    const tapScriptSig = (input || {}).tapScriptSig;\n    if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    pubkey = pubkey && toXOnly(pubkey);\n    const allHashses = pubkey\n      ? getTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          pubkey,\n          this.__CACHE,\n        )\n      : getAllTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          this.__CACHE,\n        );\n    if (!allHashses.length) throw new Error('No signatures for this pubkey');\n    const tapKeyHash = allHashses.find(h => !h.leafHash);\n    let validationResultCount = 0;\n    if (tapKeySig && tapKeyHash) {\n      const isValidTapkeySig = validator(\n        tapKeyHash.pubkey,\n        tapKeyHash.hash,\n        trimTaprootSig(tapKeySig),\n      );\n      if (!isValidTapkeySig) return false;\n      validationResultCount++;\n    }\n    if (tapScriptSig) {\n      for (const tapSig of tapScriptSig) {\n        const tapSigHash = allHashses.find(\n          h => tools.compare(h.pubkey, tapSig.pubkey) === 0,\n        );\n        if (tapSigHash) {\n          const isValidTapScriptSig = validator(\n            tapSig.pubkey,\n            tapSigHash.hash,\n            trimTaprootSig(tapSig.signature),\n          );\n          if (!isValidTapScriptSig) return false;\n          validationResultCount++;\n        }\n      }\n    }\n    return validationResultCount > 0;\n  }\n  signAllInputsHD(hdKeyPair, sighashTypes) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(hdKeyPair, sighashTypes) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(\n          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(inputIndex, hdKeyPair, sighashTypes) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(inputIndex, hdKeyPair, sighashTypes) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer =>\n        this.signInputAsync(inputIndex, signer, sighashTypes),\n      );\n      return Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n  signAllInputs(keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(keyPair, sighashTypes) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(\n          this.signInputAsync(i, keyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(inputIndex, keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (isTaprootInput(input)) {\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        undefined,\n        sighashTypes,\n      );\n    }\n    return this._signInput(inputIndex, keyPair, sighashTypes);\n  }\n  signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (isTaprootInput(input))\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        tapLeafHashToSign,\n        sighashTypes,\n      );\n    throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n  }\n  _signInput(inputIndex, keyPair, sighashTypes = DEFAULT_SIGHASHES) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n      this.opts.forkCoin,\n    );\n    const partialSig = [\n      {\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(\n          keyPair.sign(hash),\n          sighashType & 0xff,\n        ),\n      },\n    ];\n    this.data.updateInput(inputIndex, { partialSig });\n    return this;\n  }\n  _signTaprootInput(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes = [Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    const tapKeySig = hashesForSig\n      .filter(h => !h.leafHash)\n      .map(h =>\n        serializeTaprootSignature(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n      )[0];\n    const tapScriptSig = hashesForSig\n      .filter(h => !!h.leafHash)\n      .map(h => ({\n        pubkey: toXOnly(keyPair.publicKey),\n        signature: serializeTaprootSignature(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n        leafHash: h.leafHash,\n      }));\n    if (tapKeySig) {\n      this.data.updateInput(inputIndex, { tapKeySig });\n    }\n    if (tapScriptSig.length) {\n      this.data.updateInput(inputIndex, { tapScriptSig });\n    }\n    return this;\n  }\n  signInputAsync(inputIndex, keyPair, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = checkForInput(this.data.inputs, inputIndex);\n      if (isTaprootInput(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          undefined,\n          sighashTypes,\n        );\n      return this._signInputAsync(inputIndex, keyPair, sighashTypes);\n    });\n  }\n  signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = checkForInput(this.data.inputs, inputIndex);\n      if (isTaprootInput(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          tapLeafHash,\n          sighashTypes,\n        );\n      throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n    });\n  }\n  _signInputAsync(inputIndex, keyPair, sighashTypes = DEFAULT_SIGHASHES) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n      this.opts.forkCoin,\n    );\n    return Promise.resolve(keyPair.sign(hash)).then(signature => {\n      const partialSig = [\n        {\n          pubkey: keyPair.publicKey,\n          signature: bscript.signature.encode(signature, sighashType),\n        },\n      ];\n      this.data.updateInput(inputIndex, { partialSig });\n    });\n  }\n  async _signTaprootInputAsync(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHash,\n    sighashTypes = [Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHash,\n      sighashTypes,\n    );\n    const signaturePromises = [];\n    const tapKeyHash = hashesForSig.filter(h => !h.leafHash)[0];\n    if (tapKeyHash) {\n      const tapKeySigPromise = Promise.resolve(\n        keyPair.signSchnorr(tapKeyHash.hash),\n      ).then(sig => {\n        return { tapKeySig: serializeTaprootSignature(sig, input.sighashType) };\n      });\n      signaturePromises.push(tapKeySigPromise);\n    }\n    const tapScriptHashes = hashesForSig.filter(h => !!h.leafHash);\n    if (tapScriptHashes.length) {\n      const tapScriptSigPromises = tapScriptHashes.map(tsh => {\n        return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(\n          signature => {\n            const tapScriptSig = [\n              {\n                pubkey: toXOnly(keyPair.publicKey),\n                signature: serializeTaprootSignature(\n                  signature,\n                  input.sighashType,\n                ),\n                leafHash: tsh.leafHash,\n              },\n            ];\n            return { tapScriptSig };\n          },\n        );\n      });\n      signaturePromises.push(...tapScriptSigPromises);\n    }\n    return Promise.all(signaturePromises).then(results => {\n      results.forEach(v => this.data.updateInput(inputIndex, v));\n    });\n  }\n  checkTaprootHashesForSig(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes,\n  ) {\n    if (typeof keyPair.signSchnorr !== 'function')\n      throw new Error(\n        `Need Schnorr Signer to sign taproot input #${inputIndex}.`,\n      );\n    const hashesForSig = getTaprootHashesForSig(\n      inputIndex,\n      input,\n      this.data.inputs,\n      keyPair.publicKey,\n      this.__CACHE,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    if (!hashesForSig || !hashesForSig.length)\n      throw new Error(\n        `Can not sign for input #${inputIndex} with the key ${tools.toHex(keyPair.publicKey)}`,\n      );\n    return hashesForSig;\n  }\n  toBuffer() {\n    checkCache(this.__CACHE);\n    return this.data.toBuffer();\n  }\n  toHex() {\n    checkCache(this.__CACHE);\n    return this.data.toHex();\n  }\n  toBase64() {\n    checkCache(this.__CACHE);\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);\n    checkTaprootInputFields(\n      this.data.inputs[inputIndex],\n      updateData,\n      'updateInput',\n    );\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(\n        this.__CACHE,\n        this.data.inputs[inputIndex],\n        inputIndex,\n      );\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const outputData = this.data.outputs[outputIndex];\n    checkTaprootOutputFields(outputData, updateData, 'updateOutput');\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  tx;\n  constructor(buffer = Uint8Array.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true,\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length,\n    };\n  }\n  addInput(input) {\n    if (\n      input.hash === undefined ||\n      input.index === undefined ||\n      (!(input.hash instanceof Uint8Array) && typeof input.hash !== 'string') ||\n      typeof input.index !== 'number'\n    ) {\n      throw new Error('Error adding input.');\n    }\n    const hash =\n      typeof input.hash === 'string'\n        ? reverseBuffer(tools.fromHex(input.hash))\n        : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (\n      output.script === undefined ||\n      output.value === undefined ||\n      !(output.script instanceof Uint8Array) ||\n      typeof output.value !== 'bigint'\n    ) {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({ output: script });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction checkCache(cache) {\n  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n    throw new Error('Not BIP174 compliant, can not export');\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys\n      .map(pkey => {\n        const pubkey = compressPubkey(pkey);\n        return partialSig.find(\n          pSig => tools.compare(pSig.pubkey, pubkey) === 0,\n        );\n      })\n      .filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction bip32DerivationIsMine(root) {\n  return d => {\n    if (tools.compare(root.fingerprint, d.masterFingerprint)) return false;\n    if (tools.compare(root.derivePath(d.path).publicKey, d.pubkey))\n      return false;\n    return true;\n  };\n}\nfunction check32Bit(num) {\n  if (\n    typeof num !== 'number' ||\n    num !== Math.floor(num) ||\n    num > 0xffffffff ||\n    num < 0\n  ) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\n      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n        `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n        `pass true to the first arg of extractTransaction.`,\n    );\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    const throws = isTaprootInput(input)\n      ? checkTaprootInputForSigs(input, action)\n      : checkInputForSig(input, action);\n    if (throws)\n      throw new Error('Can not modify transaction, signatures exist.');\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const { partialSig, sighashType } = input;\n  partialSig.forEach(pSig => {\n    const { hashType } = bscript.signature.decode(pSig.signature);\n    if ((sighashType & 0xff) !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  if (!pubkeyInScript(pubkey, script)) {\n    throw new Error(\n      `Can not ${action} for this input with the key ${tools.toHex(pubkey)}`,\n    );\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(\n    input =>\n      input.script &&\n      input.script.length === 0 &&\n      input.witness &&\n      input.witness.length === 0,\n  );\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key =\n    tools.toHex(reverseBuffer(Uint8Array.from(input.hash))) + ':' + input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n    const redeemScriptOutput = payment({\n      redeem: { output: redeemScript },\n    }).output;\n    if (tools.compare(scriptPubKey, redeemScriptOutput)) {\n      throw new Error(\n        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,\n      );\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(\n  payments.p2wsh,\n  'Witness script',\n);\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized))\n    throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;\n  else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType))\n    throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(\n    script,\n    scriptType,\n    input.partialSig,\n    isSegwit,\n    isP2SH,\n    isP2WSH,\n  );\n}\nfunction prepareFinalScripts(\n  script,\n  scriptType,\n  partialSig,\n  isSegwit,\n  isP2SH,\n  isP2WSH,\n) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);\n    } else {\n      finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness,\n  };\n}\nfunction getHashAndSighashType(\n  inputs,\n  inputIndex,\n  pubkey,\n  cache,\n  sighashTypes,\n  forkCoin,\n) {\n  const input = checkForInput(inputs, inputIndex);\n  const { hash, sighashType, script } = getHashForSig(\n    inputIndex,\n    input,\n    cache,\n    false,\n    forkCoin,\n    sighashTypes,\n  );\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType,\n  };\n}\nfunction getDefaultSighash(forkCoin) {\n  switch (forkCoin) {\n    case 'bch':\n      return BCH_SIGHASH_ALL;\n    case 'btg':\n      return BTG_SIGHASH_ALL;\n    case 'none':\n      return Transaction.SIGHASH_ALL;\n  }\n}\nfunction getHashForSig(\n  inputIndex,\n  input,\n  cache,\n  forValidate,\n  forkCoin,\n  sighashTypes,\n) {\n  const unsignedTx = cache.__TX;\n  const sighashType = input.sighashType || getDefaultSighash(forkCoin);\n  checkSighashTypeAllowed(sighashType, sighashTypes);\n  let hash;\n  let prevout;\n  const isForkId = (sighashType & Transaction.SIGHASH_BITCOINCASHBIP143) > 0;\n  const isBTG = (sighashType & (Transaction.FORKID_BTG << 8)) > 0;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (tools.compare(prevoutHash, utxoHash) !== 0) {\n      throw new Error(\n        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,\n      );\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n  } else if (input.witnessUtxo) {\n    prevout = input.witnessUtxo;\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  const { meaningfulScript, type } = getMeaningfulScript(\n    prevout.script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n    if (isForkId && isBTG) {\n      hash = unsignedTx.hashForGoldSignature(\n        inputIndex,\n        meaningfulScript,\n        prevout.value,\n        sighashType,\n        true,\n      );\n    } else {\n      hash = unsignedTx.hashForWitnessV0(\n        inputIndex,\n        meaningfulScript,\n        prevout.value,\n        sighashType,\n      );\n    }\n  } else if (isP2WPKH(meaningfulScript)) {\n    // P2WPKH uses the P2PKH template for prevoutScript when signing\n    const signingScript = payments.p2pkh({\n      hash: meaningfulScript.slice(2),\n    }).output;\n    if (isForkId && isBTG) {\n      hash = unsignedTx.hashForGoldSignature(\n        inputIndex,\n        signingScript,\n        prevout.value,\n        sighashType,\n        true,\n      );\n    } else {\n      hash = unsignedTx.hashForWitnessV0(\n        inputIndex,\n        signingScript,\n        prevout.value,\n        sighashType,\n      );\n    }\n  } else {\n    // non-segwit\n    if (\n      !isForkId &&\n      input.nonWitnessUtxo === undefined &&\n      cache.__UNSAFE_SIGN_NONSEGWIT === false\n    )\n      throw new Error(\n        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n          `${tools.toHex(meaningfulScript)}`,\n      );\n    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)\n      console.warn(\n        'Warning: Signing non-segwit inputs without the full parent transaction ' +\n          'means there is a chance that a miner could feed you incorrect information ' +\n          \"to trick you into paying large fees. This behavior is the same as Psbt's predecessor \" +\n          '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' +\n          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +\n          'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' +\n          '*********************',\n      );\n    if (isForkId && isBTG) {\n      hash = unsignedTx.hashForGoldSignature(\n        inputIndex,\n        meaningfulScript,\n        prevout.value,\n        sighashType,\n        true,\n      );\n    } else if (isForkId) {\n      hash = unsignedTx.hashForCashSignature(\n        inputIndex,\n        meaningfulScript,\n        prevout.value,\n        sighashType,\n      );\n    } else {\n      hash = unsignedTx.hashForSignature(\n        inputIndex,\n        meaningfulScript,\n        sighashType,\n      );\n    }\n  }\n  return {\n    script: meaningfulScript,\n    sighashType,\n    hash,\n  };\n}\nfunction getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {\n  const allPublicKeys = [];\n  if (input.tapInternalKey) {\n    const key = getPrevoutTaprootKey(inputIndex, input, cache);\n    if (key) {\n      allPublicKeys.push(key);\n    }\n  }\n  if (input.tapScriptSig) {\n    const tapScriptPubkeys = input.tapScriptSig.map(tss => tss.pubkey);\n    allPublicKeys.push(...tapScriptPubkeys);\n  }\n  const allHashes = allPublicKeys.map(publicKey =>\n    getTaprootHashesForSig(inputIndex, input, inputs, publicKey, cache),\n  );\n  return allHashes.flat();\n}\nfunction getPrevoutTaprootKey(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return isP2TR(script) ? script.subarray(2, 34) : null;\n}\nfunction trimTaprootSig(signature) {\n  return signature.length === 64 ? signature : signature.subarray(0, 64);\n}\nfunction getTaprootHashesForSig(\n  inputIndex,\n  input,\n  inputs,\n  pubkey,\n  cache,\n  tapLeafHashToSign,\n  allowedSighashTypes,\n) {\n  const unsignedTx = cache.__TX;\n  const sighashType = input.sighashType || Transaction.SIGHASH_DEFAULT;\n  checkSighashTypeAllowed(sighashType, allowedSighashTypes);\n  const prevOuts = inputs.map((i, index) =>\n    getScriptAndAmountFromUtxo(index, i, cache),\n  );\n  const signingScripts = prevOuts.map(o => o.script);\n  const values = prevOuts.map(o => o.value);\n  const hashes = [];\n  if (input.tapInternalKey && !tapLeafHashToSign) {\n    const outputKey =\n      getPrevoutTaprootKey(inputIndex, input, cache) || Uint8Array.from([]);\n    if (tools.compare(toXOnly(pubkey), outputKey) === 0) {\n      const tapKeyHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n      );\n      hashes.push({ pubkey, hash: tapKeyHash });\n    }\n  }\n  const tapLeafHashes = (input.tapLeafScript || [])\n    .filter(tapLeaf => pubkeyInScript(pubkey, tapLeaf.script))\n    .map(tapLeaf => {\n      const hash = tapleafHash({\n        output: tapLeaf.script,\n        version: tapLeaf.leafVersion,\n      });\n      return Object.assign({ hash }, tapLeaf);\n    })\n    .filter(\n      tapLeaf =>\n        !tapLeafHashToSign ||\n        tools.compare(tapLeafHashToSign, tapLeaf.hash) === 0,\n    )\n    .map(tapLeaf => {\n      const tapScriptHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n        tapLeaf.hash,\n      );\n      return {\n        pubkey,\n        hash: tapScriptHash,\n        leafHash: tapLeaf.hash,\n      };\n    });\n  return hashes.concat(tapLeafHashes);\n}\nfunction checkSighashTypeAllowed(sighashType, sighashTypes) {\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\n      `Sighash type is not allowed. Retry the sign method passing the ` +\n        `sighashTypes array of whitelisted types. Sighash type: ${str}`,\n    );\n  }\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs,\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n  }\n  return payment;\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false,\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n        cache,\n        input,\n        inputIndex,\n      );\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || isP2WPKH(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = checkForInput(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation\n    .map(bipDv => {\n      if (tools.compare(bipDv.masterFingerprint, hdKeyPair.fingerprint) === 0) {\n        return bipDv;\n      } else {\n        return;\n      }\n    })\n    .filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error(\n      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',\n    );\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (tools.compare(bipDv.pubkey, node.publicKey) !== 0) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({ output: script });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys\n    .map(pk => {\n      // filter partialSig array by pubkey being equal\n      return (\n        partialSig.filter(ps => {\n          return tools.compare(ps.pubkey, pk) === 0;\n        })[0] || {}\n      ).signature;\n      // Any pubkey without a match will return undefined\n      // this last filter removes all the undefined items in the array.\n    })\n    .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(vi.bigintValue);\n    return vi.numberValue;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text =\n    sighashType & Transaction.SIGHASH_ANYONECANPAY\n      ? 'SIGHASH_ANYONECANPAY | '\n      : '';\n  if (sighashType & Transaction.SIGHASH_BITCOINCASHBIP143)\n    text += 'SIGHASH_BITCOINCASHBIP143 | ';\n  if (sighashType & (Transaction.FORKID_BTG << 8)) {\n    text += 'FORKID_BTG | ';\n  } else {\n    text += 'FORKID_BCH | ';\n  }\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    },\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0n;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig)\n      tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(\n        input.finalScriptWitness,\n      );\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0n);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(Number(fee / BigInt(bytes)));\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return script;\n}\nfunction getScriptAndAmountFromUtxo(inputIndex, input, cache) {\n  if (input.witnessUtxo !== undefined) {\n    return {\n      script: input.witnessUtxo.script,\n      value: input.witnessUtxo.value,\n    };\n  } else if (input.nonWitnessUtxo !== undefined) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];\n    return { script: o.script, value: o.value };\n  } else {\n    throw new Error(\"Can't find pubkey in input without Utxo data\");\n  }\n}\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n  const script = getScriptFromUtxo(inputIndex, input, cache);\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n  const script = cache.__TX.outs[outputIndex].script;\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    outputIndex,\n    'output',\n    output.redeemScript,\n    output.witnessScript,\n  );\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\nfunction redeemFromFinalScriptSig(finalScript) {\n  if (!finalScript) return;\n  const decomp = bscript.decompile(finalScript);\n  if (!decomp) return;\n  const lastItem = decomp[decomp.length - 1];\n  if (\n    !(lastItem instanceof Uint8Array) ||\n    isPubkeyLike(lastItem) ||\n    isSigLike(lastItem)\n  )\n    return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction redeemFromFinalWitnessScript(finalScript) {\n  if (!finalScript) return;\n  const decomp = scriptWitnessToWitnessStack(finalScript);\n  const lastItem = decomp[decomp.length - 1];\n  if (isPubkeyLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction compressPubkey(pubkey) {\n  if (pubkey.length === 65) {\n    const parity = pubkey[64] & 1;\n    const newKey = pubkey.slice(0, 33);\n    newKey[0] = 2 | parity;\n    return newKey;\n  }\n  return pubkey.slice();\n}\nfunction isPubkeyLike(buf) {\n  return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\nfunction isSigLike(buf) {\n  return bscript.isCanonicalScriptSignature(buf);\n}\nfunction getMeaningfulScript(\n  script,\n  index,\n  ioType,\n  redeemScript,\n  witnessScript,\n) {\n  const isP2SH = isP2SHScript(script);\n  const isP2SHP2WSH = isP2SH && redeemScript && isP2WSHScript(redeemScript);\n  const isP2WSH = isP2WSHScript(script);\n  if (isP2SH && redeemScript === undefined)\n    throw new Error('scriptPubkey is P2SH but redeemScript missing');\n  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)\n    throw new Error(\n      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',\n    );\n  let meaningfulScript;\n  if (isP2SHP2WSH) {\n    meaningfulScript = witnessScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n    checkWitnessScript(index, redeemScript, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2WSH) {\n    meaningfulScript = witnessScript;\n    checkWitnessScript(index, script, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2SH) {\n    meaningfulScript = redeemScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n  } else {\n    meaningfulScript = script;\n  }\n  return {\n    meaningfulScript,\n    type: isP2SHP2WSH\n      ? 'p2sh-p2wsh'\n      : isP2SH\n        ? 'p2sh'\n        : isP2WSH\n          ? 'p2wsh'\n          : 'raw',\n  };\n}\nfunction checkInvalidP2WSH(script) {\n  if (isP2WPKH(script) || isP2SHScript(script)) {\n    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n  }\n}\nfunction classifyScript(script) {\n  if (isP2WPKH(script)) return 'witnesspubkeyhash';\n  if (isP2PKH(script)) return 'pubkeyhash';\n  if (isP2MS(script)) return 'multisig';\n  if (isP2PK(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n"],"names":["BASE","LOG_BASE","MAX_INT","MAX_INT_ARR","smallToArray","DEFAULT_ALPHABET","supportsNativeBigInt","BigInt","Integer","v","radix","alphabet","caseSensitive","parseBase","parseValue","BigInteger","value","sign","this","isSmall","SmallInteger","NativeBigInt","isPrecise","n","Math","floor","arrayToSmall","arr","trim","length","compareAbs","i","createArray","x","Array","truncate","ceil","add","a","b","sum","l_a","l_b","r","carry","base","push","addAny","addSmall","l","subtract","difference","a_l","b_l","borrow","subtractSmall","multiplyLong","product","a_i","j","multiplySmall","shiftLeft","concat","multiplyKaratsuba","y","max","slice","d","c","ac","bd","abcd","multiplySmallAndArray","square","divModSmall","lambda","q","remainder","divisor","quotient","divModAny","self","Error","negate","abs","comparison","divMod1","quotientDigit","shift","result","divisorMostSignificantDigit","divMod2","guess","xlen","highx","highy","check","part","unshift","reverse","qSign","mod","mSign","isBasicPrime","isUnit","equals","isEven","isDivisibleBy","lesser","millerRabinTest","nPrev","prev","divide","next","bigInt","modPow","prototype","Object","create","plus","subtractAny","minus","small","multiply","useKaratsuba","l1","l2","times","_multiplyBySmall","divmod","over","pow","toString","_0","_1","_2","isNegative","exp","isZero","modInv","isPositive","isOdd","compare","Infinity","compareTo","eq","notEquals","neq","greater","gt","lt","greaterOrEquals","geq","lesserOrEquals","leq","isPrime","strict","undefined","bits","bitLength","logN","log","toJSNumber","t","isProbablePrime","iterations","rng","randBetween","lastT","lastR","zero","newT","one","newR","powersOfTwo","powers2Length","highestPower2","shift_isSmall","bitwise","fn","xSign","ySign","xRem","not","yRem","xDigit","yDigit","xDivMod","yDivMod","String","shiftRight","remQuo","and","or","xor","LOBMASK_I","LOBMASK_BI","roughLOB","integerLogarithm","tmp","p","e","min","gcd","text","toLowerCase","absBase","alphabetValues","digits","start","parseBaseFromArray","val","toBase","apply","map","valueOf","neg","Number","out","left","digit","toBaseString","stringify","join","parseStringValue","split","decimalPlace","indexOf","test","parseNumberValue","toArray","str","toJSON","parseInt","minusOne","lcm","isInstance","usedRNG","random","low","range","restricted","top","fromArray","module","hasOwnProperty","exports","base58","Buffer","checksumFn","decodeRaw","buffer","payload","checksum","newChecksum","encode","decode","string","decodeUnsafe","createHash","bs58checkBase","sha256x2","update","digest","bs58check","cashaddr","Format","Network","Type","detectAddressFormat","address","decodeAddress","format","detectAddressNetwork","network","detectAddressType","type","P2PKH","P2SH","VERSION_BYTE","decodeBase58Address","BASE_58_CHECK_PAYLOAD_LENGTH","InvalidAddressError","versionByte","hash","call","Legacy","Mainnet","Testnet","Bitpay","error","decodeCashAddress","decodeCashAddressWithPrefix","prefixes","decoded","prefix","Cashaddr","name","message","stack","isValidAddress","input","toLegacyAddress","encodeAsLegacy","alloc","set","toBitpayAddress","encodeAsBitpay","toCashAddress","encodeAsCashaddr","Uint8Array","isLegacyAddress","isBitpayAddress","isCashAddress","isMainnetAddress","isTestnetAddress","isP2PKHAddress","isP2SHAddress","LOG_MAX_INT","charCodeAt","isNaN","charCode","charAt","validate","CHARSET_INVERSE_INDEX","data","base32","convertBits","validation","ValidationError","VALID_PREFIXES","prefixToUint5Array","ab","polymod","GENERATOR","topBits","hasSingleCase","toUpperCase","isValidPrefix","prefixData","getTypeBits","getHashSizeBits","payloadData","toUint5Array","checksumData","checksumToUint5Array","pieces","validChecksum","fromUint5Array","subarray","getHashSize","getType","from","to","strictMode","mask","index","accumulator","condition","constructor","super","setPrototypeOf","z","g","f","w","s","k","h","m","u","strng","bitcoin","messagePrefix","bech32","bip32","public","private","pubKeyHash","scriptHash","wif","regtest","testnet","lenR","lenS","signature","OP_FALSE","OP_0","OP_PUSHDATA1","OP_PUSHDATA2","OP_PUSHDATA4","OP_1NEGATE","OP_RESERVED","OP_TRUE","OP_1","OP_2","OP_3","OP_4","OP_5","OP_6","OP_7","OP_8","OP_9","OP_10","OP_11","OP_12","OP_13","OP_14","OP_15","OP_16","OP_NOP","OP_VER","OP_IF","OP_NOTIF","OP_VERIF","OP_VERNOTIF","OP_ELSE","OP_ENDIF","OP_VERIFY","OP_RETURN","OP_TOALTSTACK","OP_FROMALTSTACK","OP_2DROP","OP_2DUP","OP_3DUP","OP_2OVER","OP_2ROT","OP_2SWAP","OP_IFDUP","OP_DEPTH","OP_DROP","OP_DUP","OP_NIP","OP_OVER","OP_PICK","OP_ROLL","OP_ROT","OP_SWAP","OP_TUCK","OP_CAT","OP_SUBSTR","OP_LEFT","OP_RIGHT","OP_SIZE","OP_INVERT","OP_AND","OP_OR","OP_XOR","OP_EQUAL","OP_EQUALVERIFY","OP_RESERVED1","OP_RESERVED2","OP_1ADD","OP_1SUB","OP_2MUL","OP_2DIV","OP_NEGATE","OP_ABS","OP_NOT","OP_0NOTEQUAL","OP_ADD","OP_SUB","OP_MUL","OP_DIV","OP_MOD","OP_LSHIFT","OP_RSHIFT","OP_BOOLAND","OP_BOOLOR","OP_NUMEQUAL","OP_NUMEQUALVERIFY","OP_NUMNOTEQUAL","OP_LESSTHAN","OP_GREATERTHAN","OP_LESSTHANOREQUAL","OP_GREATERTHANOREQUAL","OP_MIN","OP_MAX","OP_WITHIN","OP_RIPEMD160","OP_SHA1","OP_SHA256","OP_HASH160","OP_HASH256","OP_CODESEPARATOR","OP_CHECKSIG","OP_CHECKSIGVERIFY","OP_CHECKMULTISIG","OP_CHECKMULTISIGVERIFY","OP_NOP1","OP_NOP2","OP_CHECKLOCKTIMEVERIFY","OP_NOP3","OP_CHECKSEQUENCEVERIFY","OP_NOP4","OP_NOP5","OP_NOP6","OP_NOP7","OP_NOP8","OP_NOP9","OP_NOP10","OP_CHECKSIGADD","OP_PUBKEYHASH","OP_PUBKEY","OP_INVALIDOPCODE","REVERSE_OPS","op","keys","code","encodingLength","offset","opcode","num","size","number","ZERO32","EC_P","NBufferSchemaFactory","every","isPoint","TAPLEAF_VERSION_MASK","o","output","version","scriptTree","isArray","Buffer256bitSchema","Hash256bitSchema","UInt32Schema","UInt53Schema","MAX_SAFE_INTEGER","SatoshiSchema","NullablePartial","entries","reduce","acc","ZERO","toDER","fromDER","bstart","hashType","isDefinedHashType","hashTypeBuffer","OP_INT_BASE","StackSchema","isPushOnlyChunk","isOPInt","isPushOnly","countNonPushOnlyOPs","filter","asMinimalOP","chunksIsBuffer","buf","singleChunkIsBuffer","compile","chunks","bufferSize","accum","chunk","forEach","chunksIsArray","toStack","_number","scriptNumSize","negative","hashTypeMod","isCanonicalScriptSignature","prop","object","defineProperty","configurable","enumerable","get","_value","writable","opts","pubkeys","signatures","TypeError","isAcceptableSignature","allowIncomplete","assign","p2pk","pubkey","_chunks","hash160","ripemd160","sha256","hash256","TAGGED_HASH_PREFIXES","TapLeaf","TapBranch","TapSighash","TapTweak","taggedHash","ALPHABET","BASE_MAP","xc","LEADER","FACTOR","iFACTOR","source","psz","zeroes","b256","it3","it4","vch","ArrayBuffer","isView","byteOffset","byteLength","pbegin","pend","b58","it1","it2","repeat","payloadU8","both","p2pkh","_address","hash2","pkh","redeem","witness","_redeem","lastChunk","nameParts","checkRedeem","decompile","hasInput","hasWitness","EMPTY_BUFFER","p2wpkh","words","fromWords","toWords","chunkHasUncompressedPubkey","_rchunks","some","wScript","_ECCLIB_CACHE","getEccLib","eccLib","cloneBuffer","clone","withCapacity","writeUInt8","writeInt32","writeInt64","writeUInt32","writeUInt64","writeVarInt","bytes","writeSlice","writeVarSlice","writeVector","vector","end","readUInt8","readInt32","readUInt32","readInt64","readVarInt","bigintValue","readSlice","verifuint","readVarSlice","readVector","count","isHashBranch","ht","rootHashFromPath","controlBlock","leafHash","kj","ej","tapBranchHash","toHashTree","tapleafHash","hashes","sort","right","findScriptPath","node","leftPath","rightPath","leaf","serializeScript","pubKey","tweakHash","tapTweakHash","res","xOnlyPointAddTweak","xOnlyPubkey","parity","varintLen","TAPROOT_WITNESS_VERSION","ANNEX_PREFIX","p2tr","internalPubkey","redeemVersion","fromBech32","_witness","_hashTree","bech32m","hashTree","leafVersion","tweakedKey","path","outputKey","controlBock","isXOnlyPoint","FUTURE_SEGWIT_MAX_SIZE","FUTURE_SEGWIT_MIN_SIZE","FUTURE_SEGWIT_MAX_VERSION","FUTURE_SEGWIT_MIN_VERSION","FUTURE_SEGWIT_VERSION_DIFF","FUTURE_SEGWIT_VERSION_WARNING","_toFutureSegwitAddress","console","warn","toBech32","fromOutputScript","toASM","toOutputScript","decodeBase58","decodeBech32","fromBase58Check","varSliceSize","someScript","EMPTY_WITNESS","ONE","VALUE_UINT64_MAX","BLANK_OUTPUT","script","valueBuffer","static","fromBuffer","_NO_STRICT","bufferReader","tx","marker","flag","hasWitnesses","ADVANCED_TRANSACTION_MARKER","ADVANCED_TRANSACTION_FLAG","vinLen","ins","sequence","voutLen","outs","locktime","fromHex","hex","isCoinbaseHash","isCoinbase","addInput","scriptSig","DEFAULT_SEQUENCE","addOutput","scriptPubKey","weight","virtualSize","_ALLOW_WITNESS","vectorSize","someVector","newTx","txIn","txOut","hashForSignature","inIndex","prevOutScript","ourScript","txTmp","SIGHASH_NONE","SIGHASH_SINGLE","SIGHASH_ANYONECANPAY","__toBuffer","hashForWitnessV1","prevOutScripts","values","annex","outputType","SIGHASH_DEFAULT","SIGHASH_ALL","SIGHASH_OUTPUT_MASK","isAnyoneCanPay","SIGHASH_INPUT_MASK","isNone","isSingle","hashPrevouts","hashAmounts","hashScriptPubKeys","hashSequences","hashOutputs","bufferWriter","txOutsSize","spendType","sigMsgSize","sigMsgWriter","hashForWitnessV0","tbuffer","hashSequence","hashForCashSignature","inAmount","SIGHASH_BITCOINCASHBIP143","hashForGoldSignature","sigVersion","nForkHashType","fUseForkId","FORKID_BTG","getHash","forWitness","getId","toBuffer","initialOffset","toHex","setInputScript","setWitness","isOutput","isPaymentFactory","payment","err","isP2MS","isP2PK","isP2PKH","isP2WPKH","isP2WSHScript","isP2SHScript","isP2TR","witnessStackToScriptWitness","currentLen","pubkeyPositionInScript","pubkeyHash","pubkeyXOnly","decompiled","findIndex","element","pubkeyInScript","checkInputForSig","action","pSigs","extractPartialSigs","partialSig","finalScriptSig","finalScriptWitness","getPsigsFromInputFinalScripts","scriptItems","witnessItems","item","sig","pSig","signatureBlocksAction","signatureDecodeFn","whitelist","toXOnly","tapScriptFinalizer","inputIndex","tapLeafHashToFinalize","tapLeaf","findTapLeafToFinalize","leafHashToFinalize","tapScriptSig","tapLeafScript","find","canFinalizeLeaf","tss","sigs","sortSignatures","addPubkeyPositionInScript","positionInScript","t1","t2","serializeTaprootSignature","sighashType","sighashTypeByte","isTaprootInput","tapInternalKey","tapMerkleRoot","tapBip32Derivation","witnessUtxo","isTaprootOutput","tapTree","checkTaprootInputFields","inputData","newInputData","checkMixedTaprootAndNonTaprootInputFields","isBadTaprootUpdate","hasNonTaprootFields","isBadNonTaprootUpdate","hasMixedFields","checkIfTapLeafInTree","newLeafsInTree","isTapLeafInTree","oldLeafsInTree","checkTaprootOutputFields","outputData","newOutputData","checkMixedTaprootAndNonTaprootOutputFields","checkTaprootScriptPubkey","scriptPubkey","getTaprootScripPubkey","tapTreeFromList","leaves","depth","instertLeavesInTree","tree","instertLeafInTree","checkTaprootInputForSigs","extractTaprootSigs","tapKeySig","finalTapKeySig","getTapKeySigFromWithness","decodeSchnorrSignature","leftSide","rightSide","merkleRoot","rootHash","io","redeemScript","witnessScript","bip32Derivation","BCH_SIGHASH_ALL","BTG_SIGHASH_ALL","DEFAULT_SIGHASHES","DEFAULT_OPTS","maximumFeeRate","forkCoin","Psbt","fromBase64","psbtBase","transactionFromBuffer","psbt","checkTxForDupeIns","cache","checkTxInputCache","__CACHE","__TX","PsbtTransaction","__NON_WITNESS_UTXO_TX_CACHE","__NON_WITNESS_UTXO_BUF_CACHE","__TX_IN_CACHE","globalMap","unsignedTx","__UNSAFE_SIGN_NONSEGWIT","inputs","setVersion","dpew","obj","attr","inputCount","setLocktime","txInputs","txOutputs","_","combine","those","JSON","parse","setMaximumFeeRate","satoshiPerByte","check32Bit","checkInputsForPartialSig","__EXTRACTED_TX","setInputSequence","addInputs","inputDatas","arguments","checkInvalidP2WSH","nonWitnessUtxo","addNonWitnessTxCache","__FEE","__FEE_RATE","addOutputs","outputDatas","extractTransaction","disableFeeCheck","isFinalized","checkFees","feeRate","getFeeRate","vsize","satoshis","toFixed","inputFinalizeGetAmts","getTxCacheValue","getFee","finalizeAllInputs","idx","finalizeInput","finalScriptsFunc","_finalizeTaprootInput","_finalizeInput","finalizeTaprootInput","getFinalScripts","isP2SH","isP2WSH","isSegwit","getScriptFromInput","nonWitnessUtxoTx","nonWitnessUtxoTxFromCache","prevoutIndex","checkPartialSigSighashes","updateInput","clearFinalizedInput","getInputType","getMeaningfulScript","getScriptFromUtxo","redeemFromFinalScriptSig","finalScript","decomp","lastItem","isPubkeyLike","isSigLike","redeemFromFinalWitnessScript","scriptWitnessToWitnessStack","classifyScript","meaningfulScript","inputHasPubkey","pubkeyInInput","inputHasHDKey","root","derivationIsMine","bip32DerivationIsMine","outputHasPubkey","outputIndex","pubkeyInOutput","outputs","outputHasHDKey","validateSignaturesOfAllInputs","validator","validateSignaturesOfInput","final","validateSignaturesOfTaprootInput","_validateSignaturesOfInput","mySigs","results","hashCache","scriptCache","sighashCache","getHashForSig","checkScriptForPubkey","allHashses","getTaprootHashesForSig","getAllTaprootHashesForSig","allPublicKeys","key","getPrevoutTaprootKey","tapScriptPubkeys","allHashes","publicKey","flat","tapKeyHash","validationResultCount","trimTaprootSig","tapSig","tapSigHash","signAllInputsHD","hdKeyPair","sighashTypes","fingerprint","signInputHD","signAllInputsHDAsync","Promise","resolve","reject","promises","signInputHDAsync","then","all","getSignersFromHD","signer","signInput","signInputAsync","catch","signAllInputs","keyPair","signAllInputsAsync","_signTaprootInput","_signInput","signTaprootInput","tapLeafHashToSign","getHashAndSighashType","allowedSighashTypes","hashesForSig","checkTaprootHashesForSig","signSchnorr","_signTaprootInputAsync","_signInputAsync","signTaprootInputAsync","tapLeafHash","signaturePromises","tapKeySigPromise","tapScriptHashes","tapScriptSigPromises","tsh","checkCache","toBase64","updateGlobal","updateData","updateOutput","addUnknownKeyValToGlobal","keyVal","addUnknownKeyValToInput","addUnknownKeyValToOutput","checkTxEmpty","getInputOutputCounts","outputCount","hasSigs","neededSigs","pkey","compressPubkey","newKey","masterFingerprint","derivePath","scriptCheckerFactory","paymentScriptName","ioType","redeemScriptOutput","checkRedeemScript","checkWitnessScript","mustFinalize","scriptType","canFinalize","p2ms","prepareFinalScripts","getPayment","getSortedSigs","pk","ps","p2wsh","p2sh","forValidate","getDefaultSighash","prevout","checkSighashTypeAllowed","isForkId","isBTG","prevoutHash","utxoHash","signingScript","getScriptAndAmountFromUtxo","prevOuts","signingScripts","tapLeafHashes","tapScriptHash","sighashTypeToString","myDerivations","bipDv","vi","numberValue","selfIndex","txCache","newBuf","inputAmount","nwTx","vout","outputAmount","total","fee","isCanonicalPubKey","isP2SHP2WSH"],"sourceRoot":""}
{"version":3,"file":"static/js/7418.b95f15a1d4.chunk.js","mappings":"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","sources":["webpack://web/../../node_modules/cborg/lib/is.js","webpack://web/../../node_modules/cborg/lib/token.js","webpack://web/../../node_modules/cborg/lib/byte-utils.js","webpack://web/../../node_modules/cborg/lib/bl.js","webpack://web/../../node_modules/cborg/lib/common.js","webpack://web/../../node_modules/cborg/lib/0uint.js","webpack://web/../../node_modules/cborg/lib/1negint.js","webpack://web/../../node_modules/cborg/lib/2bytes.js","webpack://web/../../node_modules/cborg/lib/3string.js","webpack://web/../../node_modules/cborg/lib/4array.js","webpack://web/../../node_modules/cborg/lib/5map.js","webpack://web/../../node_modules/cborg/lib/6tag.js","webpack://web/../../node_modules/cborg/lib/7float.js","webpack://web/../../node_modules/cborg/lib/jump.js","webpack://web/../../node_modules/cborg/lib/encode.js","webpack://web/../../node_modules/cborg/lib/decode.js","webpack://web/../../node_modules/@ipld/dag-cbor/node_modules/multiformats/vendor/base-x.js","webpack://web/../../node_modules/@ipld/dag-cbor/node_modules/multiformats/src/bytes.js","webpack://web/../../node_modules/@ipld/dag-cbor/node_modules/multiformats/src/bases/base.js","webpack://web/../../node_modules/@ipld/dag-cbor/node_modules/multiformats/src/bases/base32.js","webpack://web/../../node_modules/@ipld/dag-cbor/node_modules/multiformats/src/bases/base58.js","webpack://web/../../node_modules/@ipld/dag-cbor/node_modules/multiformats/vendor/varint.js","webpack://web/../../node_modules/@ipld/dag-cbor/node_modules/multiformats/src/varint.js","webpack://web/../../node_modules/@ipld/dag-cbor/node_modules/multiformats/src/hashes/digest.js","webpack://web/../../node_modules/@ipld/dag-cbor/node_modules/multiformats/src/cid.js","webpack://web/../../node_modules/@ipld/dag-cbor/src/index.js"],"sourcesContent":["// This is an unfortunate replacement for @sindresorhus/is that we need to\n// re-implement for performance purposes. In particular the is.observable()\n// check is expensive, and unnecessary for our purposes. The values returned\n// are compatible with @sindresorhus/is, however.\n\nconst typeofs = [\n  'string',\n  'number',\n  'bigint',\n  'symbol'\n]\n\nconst objectTypeNames = [\n  'Function',\n  'Generator',\n  'AsyncGenerator',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'AsyncFunction',\n  'Observable',\n  'Array',\n  'Buffer',\n  'Object',\n  'RegExp',\n  'Date',\n  'Error',\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Promise',\n  'URL',\n  'HTMLElement',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array'\n]\n\n/**\n * @param {any} value\n * @returns {string}\n */\nexport function is (value) {\n  if (value === null) {\n    return 'null'\n  }\n  if (value === undefined) {\n    return 'undefined'\n  }\n  if (value === true || value === false) {\n    return 'boolean'\n  }\n  const typeOf = typeof value\n  if (typeofs.includes(typeOf)) {\n    return typeOf\n  }\n  /* c8 ignore next 4 */\n  // not going to bother testing this, it's not going to be valid anyway\n  if (typeOf === 'function') {\n    return 'Function'\n  }\n  if (Array.isArray(value)) {\n    return 'Array'\n  }\n  if (isBuffer(value)) {\n    return 'Buffer'\n  }\n  const objectType = getObjectType(value)\n  if (objectType) {\n    return objectType\n  }\n  /* c8 ignore next */\n  return 'Object'\n}\n\n/**\n * @param {any} value\n * @returns {boolean}\n */\nfunction isBuffer (value) {\n  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value)\n}\n\n/**\n * @param {any} value\n * @returns {string|undefined}\n */\nfunction getObjectType (value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1)\n  if (objectTypeNames.includes(objectTypeName)) {\n    return objectTypeName\n  }\n  /* c8 ignore next */\n  return undefined\n}\n","class Type {\n  /**\n   * @param {number} major\n   * @param {string} name\n   * @param {boolean} terminal\n   */\n  constructor (major, name, terminal) {\n    this.major = major\n    this.majorEncoded = major << 5\n    this.name = name\n    this.terminal = terminal\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Type[${this.major}].${this.name}`\n  }\n\n  /**\n   * @param {Type} typ\n   * @returns {number}\n   */\n  compare (typ) {\n    /* c8 ignore next 1 */\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0\n  }\n}\n\n// convert to static fields when better supported\nType.uint = new Type(0, 'uint', true)\nType.negint = new Type(1, 'negint', true)\nType.bytes = new Type(2, 'bytes', true)\nType.string = new Type(3, 'string', true)\nType.array = new Type(4, 'array', false)\nType.map = new Type(5, 'map', false)\nType.tag = new Type(6, 'tag', false) // terminal?\nType.float = new Type(7, 'float', true)\nType.false = new Type(7, 'false', true)\nType.true = new Type(7, 'true', true)\nType.null = new Type(7, 'null', true)\nType.undefined = new Type(7, 'undefined', true)\nType.break = new Type(7, 'break', true)\n// Type.indefiniteLength = new Type(0, 'indefiniteLength', true)\n\nclass Token {\n  /**\n   * @param {Type} type\n   * @param {any} [value]\n   * @param {number} [encodedLength]\n   */\n  constructor (type, value, encodedLength) {\n    this.type = type\n    this.value = value\n    this.encodedLength = encodedLength\n    /** @type {Uint8Array|undefined} */\n    this.encodedBytes = undefined\n    /** @type {Uint8Array|undefined} */\n    this.byteValue = undefined\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Token[${this.type}].${this.value}`\n  }\n}\n\nexport { Type, Token }\n","// Use Uint8Array directly in the browser, use Buffer in Node.js but don't\n// speak its name directly to avoid bundlers pulling in the `Buffer` polyfill\n\n// @ts-ignore\nexport const useBuffer = globalThis.process &&\n  // @ts-ignore\n  !globalThis.process.browser &&\n  // @ts-ignore\n  globalThis.Buffer &&\n  // @ts-ignore\n  typeof globalThis.Buffer.isBuffer === 'function'\n\nconst textDecoder = new TextDecoder()\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isBuffer (buf) {\n  // @ts-ignore\n  return useBuffer && globalThis.Buffer.isBuffer(buf)\n}\n\n/**\n * @param {Uint8Array|number[]} buf\n * @returns {Uint8Array}\n */\nexport function asU8A (buf) {\n  /* c8 ignore next */\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf)\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf\n}\n\nexport const toString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8')\n        : utf8Slice(bytes, start, end)\n    }\n  /* c8 ignore next 11 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? textDecoder.decode(bytes.subarray(start, end))\n        : utf8Slice(bytes, start, end)\n    }\n\nexport const fromString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(string)\n        : utf8ToBytes(string)\n    }\n  /* c8 ignore next 7 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string)\n    }\n\n/**\n * Buffer variant not fast enough for what we need\n * @param {number[]} arr\n * @returns {Uint8Array}\n */\nexport const fromArray = (arr) => {\n  return Uint8Array.from(arr)\n}\n\nexport const slice = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      if (isBuffer(bytes)) {\n        return new Uint8Array(bytes.subarray(start, end))\n      }\n      return bytes.slice(start, end)\n    }\n  /* c8 ignore next 9 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return bytes.slice(start, end)\n    }\n\nexport const concat = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      // might get a stray plain Array here\n      /* c8 ignore next 1 */\n      chunks = chunks.map((c) => c instanceof Uint8Array\n        ? c\n        // this case is occasionally missed during test runs so becomes coverage-flaky\n        /* c8 ignore next 4 */\n        : // eslint-disable-line operator-linebreak\n        // @ts-ignore\n        globalThis.Buffer.from(c))\n      // @ts-ignore\n      return asU8A(globalThis.Buffer.concat(chunks, length))\n    }\n  /* c8 ignore next 19 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      const out = new Uint8Array(length)\n      let off = 0\n      for (let b of chunks) {\n        if (off + b.length > out.length) {\n          // final chunk that's bigger than we need\n          b = b.subarray(0, out.length - off)\n        }\n        out.set(b, off)\n        off += b.length\n      }\n      return out\n    }\n\nexport const alloc = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      // we always write over the contents we expose so this should be safe\n      // @ts-ignore\n      return globalThis.Buffer.allocUnsafe(size)\n    }\n  /* c8 ignore next 8 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      return new Uint8Array(size)\n    }\n\nexport const toHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(toBytes(d)).toString('hex')\n    }\n  /* c8 ignore next 12 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore not smart enough to figure this out\n      return Array.prototype.reduce.call(toBytes(d), (p, c) => `${p}${c.toString(16).padStart(2, '0')}`, '')\n    }\n\nexport const fromHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(hex, 'hex')\n    }\n  /* c8 ignore next 17 */\n  : // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      if (!hex.length) {\n        return new Uint8Array(0)\n      }\n      return new Uint8Array(hex.split('')\n        .map((/** @type {string} */ c, /** @type {number} */ i, /** @type {string[]} */ d) => i % 2 === 0 ? `0x${c}${d[i + 1]}` : '')\n        .filter(Boolean)\n        .map((/** @type {string} */ e) => parseInt(e, 16)))\n    }\n\n/**\n * @param {Uint8Array|ArrayBuffer|ArrayBufferView} obj\n * @returns {Uint8Array}\n */\nfunction toBytes (obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj)\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength)\n  }\n  /* c8 ignore next */\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compare (b1, b2) {\n  /* c8 ignore next 5 */\n  if (isBuffer(b1) && isBuffer(b2)) {\n    // probably not possible to get here in the current API\n    // @ts-ignore Buffer\n    return b1.compare(b2)\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue\n    }\n    return b1[i] < b2[i] ? -1 : 1\n  } /* c8 ignore next 3 */\n  return 0\n}\n\n// The below code is taken from https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n// Licensed Apache-2.0.\n\n/**\n * @param {string} str\n * @returns {number[]}\n */\nfunction utf8ToBytes (str) {\n  const out = []\n  let p = 0\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i)\n    if (c < 128) {\n      out[p++] = c\n    } else if (c < 2048) {\n      out[p++] = (c >> 6) | 192\n      out[p++] = (c & 63) | 128\n    } else if (\n      ((c & 0xFC00) === 0xD800) && (i + 1) < str.length &&\n      ((str.charCodeAt(i + 1) & 0xFC00) === 0xDC00)) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF)\n      out[p++] = (c >> 18) | 240\n      out[p++] = ((c >> 12) & 63) | 128\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    } else {\n      out[p++] = (c >> 12) | 224\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    }\n  }\n  return out\n}\n\n// The below code is mostly taken from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n\n/**\n * @param {Uint8Array} buf\n * @param {number} offset\n * @param {number} end\n * @returns {string}\n */\nfunction utf8Slice (buf, offset, end) {\n  const res = []\n\n  while (offset < end) {\n    const firstByte = buf[offset]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[offset + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          fourthByte = buf[offset + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    /* c8 ignore next 5 */\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xfffd\n      bytesPerSequence = 1\n    } else if (codePoint > 0xffff) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3ff | 0xd800)\n      codePoint = 0xdc00 | codePoint & 0x3ff\n    }\n\n    res.push(codePoint)\n    offset += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\n/**\n * @param {number[]} codePoints\n * @returns {string}\n */\nexport function decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n  /* c8 ignore next 10 */\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n","/**\n * Bl is a list of byte chunks, similar to https://github.com/rvagg/bl but for\n * writing rather than reading.\n * A Bl object accepts set() operations for individual bytes and copyTo() for\n * inserting byte arrays. These write operations don't automatically increment\n * the internal cursor so its \"length\" won't be changed. Instead, increment()\n * must be called to extend its length to cover the inserted data.\n * The toBytes() call will convert all internal memory to a single Uint8Array of\n * the correct length, truncating any data that is stored but hasn't been\n * included by an increment().\n * get() can retrieve a single byte.\n * All operations (except toBytes()) take an \"offset\" argument that will perform\n * the write at the offset _from the current cursor_. For most operations this\n * will be `0` to write at the current cursor position but it can be ahead of\n * the current cursor. Negative offsets probably work but are untested.\n */\n\n// TODO: ipjs doesn't support this, only for test files: https://github.com/mikeal/ipjs/blob/master/src/package/testFile.js#L39\nimport { alloc, concat, slice } from './byte-utils.js'\n\n// the ts-ignores in this file are almost all for the `Uint8Array|number[]` duality that exists\n// for perf reasons. Consider better approaches to this or removing it entirely, it is quite\n// risky because of some assumptions about small chunks === number[] and everything else === Uint8Array.\n\nconst defaultChunkSize = 256\n\nexport class Bl {\n  /**\n   * @param {number} [chunkSize]\n   */\n  constructor (chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize\n    /** @type {number} */\n    this.cursor = 0\n    /** @type {number} */\n    this.maxCursor = -1\n    /** @type {(Uint8Array|number[])[]} */\n    this.chunks = []\n    // keep the first chunk around if we can to save allocations for future encodes\n    /** @type {Uint8Array|number[]|null} */\n    this._initReuseChunk = null\n  }\n\n  reset () {\n    this.cursor = 0\n    this.maxCursor = -1\n    if (this.chunks.length) {\n      this.chunks = []\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk)\n      this.maxCursor = this._initReuseChunk.length - 1\n    }\n  }\n\n  /**\n   * @param {Uint8Array|number[]} bytes\n   */\n  push (bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1]\n    const newMax = this.cursor + bytes.length\n    if (newMax <= this.maxCursor + 1) {\n      // we have at least one chunk and we can fit these bytes into that chunk\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n      // @ts-ignore\n      topChunk.set(bytes, chunkPos)\n    } else {\n      // can't fit it in\n      if (topChunk) {\n        // trip the last chunk to `cursor` if we need to\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n        if (chunkPos < topChunk.length) {\n          // @ts-ignore\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos)\n          this.maxCursor = this.cursor - 1\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        // make a new chunk and copy the new one into it\n        topChunk = alloc(this.chunkSize)\n        this.chunks.push(topChunk)\n        this.maxCursor += topChunk.length\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk\n        }\n        // @ts-ignore\n        topChunk.set(bytes, 0)\n      } else {\n        // push the new bytes in as its own chunk\n        this.chunks.push(bytes)\n        this.maxCursor += bytes.length\n      }\n    }\n    this.cursor += bytes.length\n  }\n\n  /**\n   * @param {boolean} [reset]\n   * @returns {Uint8Array}\n   */\n  toBytes (reset = false) {\n    let byts\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0]\n      if (reset && this.cursor > chunk.length / 2) {\n        /* c8 ignore next 2 */\n        // @ts-ignore\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor)\n        this._initReuseChunk = null\n        this.chunks = []\n      } else {\n        // @ts-ignore\n        byts = slice(chunk, 0, this.cursor)\n      }\n    } else {\n      // @ts-ignore\n      byts = concat(this.chunks, this.cursor)\n    }\n    if (reset) {\n      this.reset()\n    }\n    return byts\n  }\n}\n","const decodeErrPrefix = 'CBOR decode error:'\nconst encodeErrPrefix = 'CBOR encode error:'\n\nconst uintMinorPrefixBytes = []\nuintMinorPrefixBytes[23] = 1\nuintMinorPrefixBytes[24] = 2\nuintMinorPrefixBytes[25] = 3\nuintMinorPrefixBytes[26] = 5\nuintMinorPrefixBytes[27] = 9\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} need\n */\nfunction assertEnoughData (data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${decodeErrPrefix} not enough data for type`)\n  }\n}\n\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n}\n","/* globals BigInt */\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix, assertEnoughData } from './common.js'\n\nexport const uintBoundaries = [24, 256, 65536, 4294967296, BigInt('18446744073709551616')]\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint8 (data, offset, options) {\n  assertEnoughData(data, offset, 1)\n  const value = data[offset]\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint16 (data, offset, options) {\n  assertEnoughData(data, offset, 2)\n  const value = (data[offset] << 8) | data[offset + 1]\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint32 (data, offset, options) {\n  assertEnoughData(data, offset, 4)\n  const value = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number|bigint}\n */\nexport function readUint64 (data, offset, options) {\n  // assume BigInt, convert back to Number if within safe range\n  assertEnoughData(data, offset, 8)\n  const hi = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  const lo = (data[offset + 4] * 16777216 /* 2 ** 24 */) + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7]\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo)\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value)\n  }\n  if (options.allowBigInt === true) {\n    return value\n  }\n  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n}\n\n/* not required thanks to quick[] list\nconst oneByteTokens = new Array(24).fill(0).map((v, i) => new Token(Type.uint, i, 1))\nexport function decodeUintCompact (data, pos, minor, options) {\n  return oneByteTokens[minor]\n}\n*/\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint8 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint16 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint32 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint64 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeUint (buf, token) {\n  return encodeUintValue(buf, 0, token.value)\n}\n\n/**\n * @param {Bl} buf\n * @param {number} major\n * @param {number|bigint} uint\n */\nexport function encodeUintValue (buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint)\n    // pack into one byte, minor=0, additional=value\n    buf.push([major | nuint])\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint)\n    // pack into two byte, minor=0, additional=24\n    buf.push([major | 24, nuint])\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint)\n    // pack into three byte, minor=0, additional=25\n    buf.push([major | 25, nuint >>> 8, nuint & 0xff])\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint)\n    // pack into five byte, minor=0, additional=26\n    buf.push([major | 26, (nuint >>> 24) & 0xff, (nuint >>> 16) & 0xff, (nuint >>> 8) & 0xff, nuint & 0xff])\n  } else {\n    const buint = BigInt(uint)\n    if (buint < uintBoundaries[4]) {\n      // pack into nine byte, minor=0, additional=27\n      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0]\n      // simulate bitwise above 32 bits\n      let lo = Number(buint & BigInt(0xffffffff))\n      let hi = Number(buint >> BigInt(32) & BigInt(0xffffffff))\n      set[8] = lo & 0xff\n      lo = lo >> 8\n      set[7] = lo & 0xff\n      lo = lo >> 8\n      set[6] = lo & 0xff\n      lo = lo >> 8\n      set[5] = lo & 0xff\n      set[4] = hi & 0xff\n      hi = hi >> 8\n      set[3] = hi & 0xff\n      hi = hi >> 8\n      set[2] = hi & 0xff\n      hi = hi >> 8\n      set[1] = hi & 0xff\n      buf.push(set)\n    } else {\n      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`)\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeUint.encodedSize = function encodedSize (token) {\n  return encodeUintValue.encodedSize(token.value)\n}\n\n/**\n * @param {number} uint\n * @returns {number}\n */\nencodeUintValue.encodedSize = function encodedSize (uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeUint.compareTokens = function compareTokens (tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : /* c8 ignore next */ 0\n}\n","/* eslint-env es2020 */\n\nimport { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint8 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint16 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint32 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5)\n}\n\nconst neg1b = BigInt(-1)\nconst pos1b = BigInt(1)\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint64 (data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options)\n  if (typeof int !== 'bigint') {\n    const value = -1 - int\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9)\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeNegint (buf, token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeNegint.encodedSize = function encodedSize (token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  /* c8 ignore next 4 */\n  // handled by quickEncode, we shouldn't get here but it's included for completeness\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeNegint.compareTokens = function compareTokens (tok1, tok2) {\n  // opposite of the uint comparison since we store the uint version in bytes\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : /* c8 ignore next */ 0\n}\n","import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { compare, fromString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length)\n  const buf = slice(data, pos + prefix, pos + prefix + length)\n  return new Token(Type.bytes, buf, prefix + length)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeBytesCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * `encodedBytes` allows for caching when we do a byte version of a string\n * for key sorting purposes\n * @param {Token} token\n * @returns {Uint8Array}\n */\nfunction tokenBytes (token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value\n  }\n  // @ts-ignore c'mon\n  return token.encodedBytes\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeBytes (buf, token) {\n  const bytes = tokenBytes(token)\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length)\n  buf.push(bytes)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeBytes.encodedSize = function encodedSize (token) {\n  const bytes = tokenBytes(token)\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeBytes.compareTokens = function compareTokens (tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2))\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compareBytes (b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2)\n}\n","import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { toString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length, options) {\n  const totLength = prefix + length\n  assertEnoughData(data, pos, totLength)\n  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength)\n  if (options.retainStringBytes === true) {\n    tok.byteValue = slice(data, pos + prefix, pos + totLength)\n  }\n  return tok\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeStringCompact (data, pos, minor, options) {\n  return toToken(data, pos, 1, minor, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options), options)\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`)\n  }\n  return toToken(data, pos, 9, l, options)\n}\n\nexport const encodeString = encodeBytes\n","import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeArrayCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArrayIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeArray (buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value)\n}\n\n// using an array as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeArray.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeArray.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n","import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeMapCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMapIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeMap (buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value)\n}\n\n// using a map as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeMap.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeMap.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n","import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeTagCompact (_data, _pos, minor, _options) {\n  return new Token(Type.tag, minor, 1)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag8 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag16 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag32 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag64 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeTag (buf, token) {\n  uint.encodeUintValue(buf, Type.tag.majorEncoded, token.value)\n}\n\nencodeTag.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeTag.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n","// TODO: shift some of the bytes logic to bytes-utils so we can use Buffer\n// where possible\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix } from './common.js'\nimport { encodeUint } from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n */\n\nconst MINOR_FALSE = 20\nconst MINOR_TRUE = 21\nconst MINOR_NULL = 22\nconst MINOR_UNDEFINED = 23\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUndefined (_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${decodeErrPrefix} undefined values are not supported`)\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1)\n  }\n  return new Token(Type.undefined, undefined, 1)\n}\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBreak (_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return new Token(Type.break, undefined, 1)\n}\n\n/**\n * @param {number} value\n * @param {number} bytes\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction createToken (value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${decodeErrPrefix} NaN values are not supported`)\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${decodeErrPrefix} Infinity values are not supported`)\n    }\n  }\n  return new Token(Type.float, value, bytes)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat16 (data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat32 (data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat64 (data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n * @param {EncodeOptions} options\n */\nexport function encodeFloat (buf, token, options) {\n  const float = token.value\n\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE])\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE])\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL])\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED])\n  } else {\n    let decoded\n    let success = false\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float)\n      decoded = readFloat16(ui8a, 1)\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 0xf9\n        buf.push(ui8a.slice(0, 3))\n        success = true\n      } else {\n        encodeFloat32(float)\n        decoded = readFloat32(ui8a, 1)\n        if (float === decoded) {\n          ui8a[0] = 0xfa\n          buf.push(ui8a.slice(0, 5))\n          success = true\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float)\n      decoded = readFloat64(ui8a, 1)\n      ui8a[0] = 0xfb\n      buf.push(ui8a.slice(0, 9))\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @param {EncodeOptions} options\n * @returns {number}\n */\nencodeFloat.encodedSize = function encodedSize (token, options) {\n  const float = token.value\n\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1\n  }\n\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float)\n    let decoded = readFloat16(ui8a, 1)\n    if (float === decoded || Number.isNaN(float)) {\n      return 3\n    }\n    encodeFloat32(float)\n    decoded = readFloat32(ui8a, 1)\n    if (float === decoded) {\n      return 5\n    }\n  }\n  return 9\n}\n\nconst buffer = new ArrayBuffer(9)\nconst dataView = new DataView(buffer, 1)\nconst ui8a = new Uint8Array(buffer, 0)\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat16 (inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 0x7c00, false)\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 0xfc00, false)\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 0x7e00, false)\n  } else {\n    dataView.setFloat32(0, inp)\n    const valu32 = dataView.getUint32(0)\n    const exponent = (valu32 & 0x7f800000) >> 23\n    const mantissa = valu32 & 0x7fffff\n\n    /* c8 ignore next 6 */\n    if (exponent === 0xff) {\n      // too big, Infinity, but this should be hard (impossible?) to trigger\n      dataView.setUint16(0, 0x7c00, false)\n    } else if (exponent === 0x00) {\n      // 0.0, -0.0 and subnormals, shouldn't be possible to get here because 0.0 should be counted as an int\n      dataView.setUint16(0, ((inp & 0x80000000) >> 16) | (mantissa >> 13), false)\n    } else { // standard numbers\n      // chunks of logic here borrowed from https://github.com/PJK/libcbor/blob/c78f437182533e3efa8d963ff4b945bb635c2284/src/cbor/encoding.c#L127\n      const logicalExponent = exponent - 127\n      // Now we know that 2^exponent <= 0 logically\n      /* c8 ignore next 6 */\n      if (logicalExponent < -24) {\n        /* No unambiguous representation exists, this float is not a half float\n          and is too small to be represented using a half, round off to zero.\n          Consistent with the reference implementation. */\n        // should be difficult (impossible?) to get here in JS\n        dataView.setUint16(0, 0)\n      } else if (logicalExponent < -14) {\n        /* Offset the remaining decimal places by shifting the significand, the\n          value is lost. This is an implementation decision that works around the\n          absence of standard half-float in the language. */\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | /* sign bit */ (1 << (24 + logicalExponent)), false)\n      } else {\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | ((logicalExponent + 15) << 10) | (mantissa >> 13), false)\n      }\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat16 (ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${decodeErrPrefix} not enough data for float16`)\n  }\n\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1]\n  if (half === 0x7c00) {\n    return Infinity\n  }\n  if (half === 0xfc00) {\n    return -Infinity\n  }\n  if (half === 0x7e00) {\n    return NaN\n  }\n  const exp = (half >> 10) & 0x1f\n  const mant = half & 0x3ff\n  let val\n  if (exp === 0) {\n    val = mant * (2 ** -24)\n  } else if (exp !== 31) {\n    val = (mant + 1024) * (2 ** (exp - 25))\n  /* c8 ignore next 4 */\n  } else {\n    // may not be possible to get here\n    val = mant === 0 ? Infinity : NaN\n  }\n  return (half & 0x8000) ? -val : val\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat32 (inp) {\n  dataView.setFloat32(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat32 (ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${decodeErrPrefix} not enough data for float32`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false)\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat64 (inp) {\n  dataView.setFloat64(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat64 (ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${decodeErrPrefix} not enough data for float64`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false)\n}\n\n/**\n * @param {Token} _tok1\n * @param {Token} _tok2\n * @returns {number}\n */\nencodeFloat.compareTokens = encodeUint.compareTokens\n/*\nencodeFloat.compareTokens = function compareTokens (_tok1, _tok2) {\n  return _tok1\n  throw new Error(`${encodeErrPrefix} cannot use floats as map keys`)\n}\n*/\n","import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport * as negint from './1negint.js'\nimport * as bytes from './2bytes.js'\nimport * as string from './3string.js'\nimport * as array from './4array.js'\nimport * as map from './5map.js'\nimport * as tag from './6tag.js'\nimport * as float from './7float.js'\nimport { decodeErrPrefix } from './common.js'\nimport { fromArray } from './byte-utils.js'\n\n/**\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n */\nfunction invalidMinor (data, pos, minor) {\n  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`)\n}\n\n/**\n * @param {string} msg\n * @returns {()=>any}\n */\nfunction errorer (msg) {\n  return () => { throw new Error(`${decodeErrPrefix} ${msg}`) }\n}\n\n/** @type {((data:Uint8Array, pos:number, minor:number, options?:DecodeOptions) => any)[]} */\nexport const jump = []\n\n// unsigned integer, 0x00..0x17 (0..23)\nfor (let i = 0; i <= 0x17; i++) {\n  jump[i] = invalidMinor // uint.decodeUintCompact, handled by quick[]\n}\njump[0x18] = uint.decodeUint8 // unsigned integer, one-byte uint8_t follows\njump[0x19] = uint.decodeUint16 // unsigned integer, two-byte uint16_t follows\njump[0x1a] = uint.decodeUint32 // unsigned integer, four-byte uint32_t follows\njump[0x1b] = uint.decodeUint64 // unsigned integer, eight-byte uint64_t follows\njump[0x1c] = invalidMinor\njump[0x1d] = invalidMinor\njump[0x1e] = invalidMinor\njump[0x1f] = invalidMinor\n// negative integer, -1-0x00..-1-0x17 (-1..-24)\nfor (let i = 0x20; i <= 0x37; i++) {\n  jump[i] = invalidMinor // negintDecode, handled by quick[]\n}\njump[0x38] = negint.decodeNegint8 // negative integer, -1-n one-byte uint8_t for n follows\njump[0x39] = negint.decodeNegint16 // negative integer, -1-n two-byte uint16_t for n follows\njump[0x3a] = negint.decodeNegint32 // negative integer, -1-n four-byte uint32_t for follows\njump[0x3b] = negint.decodeNegint64 // negative integer, -1-n eight-byte uint64_t for follows\njump[0x3c] = invalidMinor\njump[0x3d] = invalidMinor\njump[0x3e] = invalidMinor\njump[0x3f] = invalidMinor\n// byte string, 0x00..0x17 bytes follow\nfor (let i = 0x40; i <= 0x57; i++) {\n  jump[i] = bytes.decodeBytesCompact\n}\njump[0x58] = bytes.decodeBytes8 // byte string, one-byte uint8_t for n, and then n bytes follow\njump[0x59] = bytes.decodeBytes16 // byte string, two-byte uint16_t for n, and then n bytes follow\njump[0x5a] = bytes.decodeBytes32 // byte string, four-byte uint32_t for n, and then n bytes follow\njump[0x5b] = bytes.decodeBytes64 // byte string, eight-byte uint64_t for n, and then n bytes follow\njump[0x5c] = invalidMinor\njump[0x5d] = invalidMinor\njump[0x5e] = invalidMinor\njump[0x5f] = errorer('indefinite length bytes/strings are not supported') // byte string, byte strings follow, terminated by \"break\"\n// UTF-8 string 0x00..0x17 bytes follow\nfor (let i = 0x60; i <= 0x77; i++) {\n  jump[i] = string.decodeStringCompact\n}\njump[0x78] = string.decodeString8 // UTF-8 string, one-byte uint8_t for n, and then n bytes follow\njump[0x79] = string.decodeString16 // UTF-8 string, two-byte uint16_t for n, and then n bytes follow\njump[0x7a] = string.decodeString32 // UTF-8 string, four-byte uint32_t for n, and then n bytes follow\njump[0x7b] = string.decodeString64 // UTF-8 string, eight-byte uint64_t for n, and then n bytes follow\njump[0x7c] = invalidMinor\njump[0x7d] = invalidMinor\njump[0x7e] = invalidMinor\njump[0x7f] = errorer('indefinite length bytes/strings are not supported') // UTF-8 strings follow, terminated by \"break\"\n// array, 0x00..0x17 data items follow\nfor (let i = 0x80; i <= 0x97; i++) {\n  jump[i] = array.decodeArrayCompact\n}\njump[0x98] = array.decodeArray8 // array, one-byte uint8_t for n, and then n data items follow\njump[0x99] = array.decodeArray16 // array, two-byte uint16_t for n, and then n data items follow\njump[0x9a] = array.decodeArray32 // array, four-byte uint32_t for n, and then n data items follow\njump[0x9b] = array.decodeArray64 // array, eight-byte uint64_t for n, and then n data items follow\njump[0x9c] = invalidMinor\njump[0x9d] = invalidMinor\njump[0x9e] = invalidMinor\njump[0x9f] = array.decodeArrayIndefinite // array, data items follow, terminated by \"break\"\n// map, 0x00..0x17 pairs of data items follow\nfor (let i = 0xa0; i <= 0xb7; i++) {\n  jump[i] = map.decodeMapCompact\n}\njump[0xb8] = map.decodeMap8 // map, one-byte uint8_t for n, and then n pairs of data items follow\njump[0xb9] = map.decodeMap16 // map, two-byte uint16_t for n, and then n pairs of data items follow\njump[0xba] = map.decodeMap32 // map, four-byte uint32_t for n, and then n pairs of data items follow\njump[0xbb] = map.decodeMap64 // map, eight-byte uint64_t for n, and then n pairs of data items follow\njump[0xbc] = invalidMinor\njump[0xbd] = invalidMinor\njump[0xbe] = invalidMinor\njump[0xbf] = map.decodeMapIndefinite // map, pairs of data items follow, terminated by \"break\"\n// tags\nfor (let i = 0xc0; i <= 0xd7; i++) {\n  jump[i] = tag.decodeTagCompact\n}\njump[0xd8] = tag.decodeTag8\njump[0xd9] = tag.decodeTag16\njump[0xda] = tag.decodeTag32\njump[0xdb] = tag.decodeTag64\njump[0xdc] = invalidMinor\njump[0xdd] = invalidMinor\njump[0xde] = invalidMinor\njump[0xdf] = invalidMinor\n// 0xe0..0xf3 simple values, unsupported\nfor (let i = 0xe0; i <= 0xf3; i++) {\n  jump[i] = errorer('simple values are not supported')\n}\njump[0xf4] = invalidMinor // false, handled by quick[]\njump[0xf5] = invalidMinor // true, handled by quick[]\njump[0xf6] = invalidMinor // null, handled by quick[]\njump[0xf7] = float.decodeUndefined // undefined\njump[0xf8] = errorer('simple values are not supported') // simple value, one byte follows, unsupported\njump[0xf9] = float.decodeFloat16 // half-precision float (two-byte IEEE 754)\njump[0xfa] = float.decodeFloat32 // single-precision float (four-byte IEEE 754)\njump[0xfb] = float.decodeFloat64 // double-precision float (eight-byte IEEE 754)\njump[0xfc] = invalidMinor\njump[0xfd] = invalidMinor\njump[0xfe] = invalidMinor\njump[0xff] = float.decodeBreak // \"break\" stop code\n\n/** @type {Token[]} */\nexport const quick = []\n// ints <24\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1)\n}\n// negints >= -24\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1)\n}\n// empty bytes\nquick[0x40] = new Token(Type.bytes, new Uint8Array(0), 1)\n// empty string\nquick[0x60] = new Token(Type.string, '', 1)\n// empty list\nquick[0x80] = new Token(Type.array, 0, 1)\n// empty map\nquick[0xa0] = new Token(Type.map, 0, 1)\n// false\nquick[0xf4] = new Token(Type.false, false, 1)\n// true\nquick[0xf5] = new Token(Type.true, true, 1)\n// null\nquick[0xf6] = new Token(Type.null, null, 1)\n\n/**\n * @param {Token} token\n * @returns {Uint8Array|undefined}\n */\nexport function quickEncodeToken (token) {\n  switch (token.type) {\n    case Type.false:\n      return fromArray([0xf4])\n    case Type.true:\n      return fromArray([0xf5])\n    case Type.null:\n      return fromArray([0xf6])\n    case Type.bytes:\n      if (!token.value.length) {\n        return fromArray([0x40])\n      }\n      return\n    case Type.string:\n      if (token.value === '') {\n        return fromArray([0x60])\n      }\n      return\n    case Type.array:\n      if (token.value === 0) {\n        return fromArray([0x80])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.map:\n      if (token.value === 0) {\n        return fromArray([0xa0])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.uint:\n      if (token.value < 24) {\n        return fromArray([Number(token.value)])\n      }\n      return\n    case Type.negint:\n      if (token.value >= -24) {\n        return fromArray([31 - Number(token.value)])\n      }\n  }\n}\n","import { is } from './is.js'\nimport { Token, Type } from './token.js'\nimport { Bl } from './bl.js'\nimport { encodeErrPrefix } from './common.js'\nimport { quickEncodeToken } from './jump.js'\nimport { asU8A } from './byte-utils.js'\n\nimport { encodeUint } from './0uint.js'\nimport { encodeNegint } from './1negint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { encodeString } from './3string.js'\nimport { encodeArray } from './4array.js'\nimport { encodeMap } from './5map.js'\nimport { encodeTag } from './6tag.js'\nimport { encodeFloat } from './7float.js'\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').OptionalTypeEncoder} OptionalTypeEncoder\n * @typedef {import('../interface').Reference} Reference\n * @typedef {import('../interface').StrictTypeEncoder} StrictTypeEncoder\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n}\n\n/** @returns {TokenTypeEncoder[]} */\nexport function makeCborEncoders () {\n  const encoders = []\n  encoders[Type.uint.major] = encodeUint\n  encoders[Type.negint.major] = encodeNegint\n  encoders[Type.bytes.major] = encodeBytes\n  encoders[Type.string.major] = encodeString\n  encoders[Type.array.major] = encodeArray\n  encoders[Type.map.major] = encodeMap\n  encoders[Type.tag.major] = encodeTag\n  encoders[Type.float.major] = encodeFloat\n  return encoders\n}\n\nconst cborEncoders = makeCborEncoders()\n\nconst buf = new Bl()\n\n/** @implements {Reference} */\nclass Ref {\n  /**\n   * @param {object|any[]} obj\n   * @param {Reference|undefined} parent\n   */\n  constructor (obj, parent) {\n    this.obj = obj\n    this.parent = parent\n  }\n\n  /**\n   * @param {object|any[]} obj\n   * @returns {boolean}\n   */\n  includes (obj) {\n    /** @type {Reference|undefined} */\n    let p = this\n    do {\n      if (p.obj === obj) {\n        return true\n      }\n    } while (p = p.parent) // eslint-disable-line\n    return false\n  }\n\n  /**\n   * @param {Reference|undefined} stack\n   * @param {object|any[]} obj\n   * @returns {Reference}\n   */\n  static createCheck (stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${encodeErrPrefix} object contains circular references`)\n    }\n    return new Ref(obj, stack)\n  }\n}\n\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n}\n\n/** @type {{[typeName: string]: StrictTypeEncoder}} */\nconst typeEncoders = {\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  number (obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj)\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  bigint (obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Uint8Array (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  string (obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  boolean (obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  null (_obj, _typ, _options, _refStack) {\n    return simpleTokens.null\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  undefined (_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  ArrayBuffer (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  DataView (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Array (obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)]\n      }\n      return simpleTokens.emptyArray\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    const entries = []\n    let i = 0\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack)\n    }\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.array, obj.length), entries]\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Object (obj, typ, options, refStack) {\n    // could be an Object or a Map\n    const isMap = typ !== 'Object'\n    // it's slightly quicker to use Object.keys() than Object.entries()\n    const keys = isMap ? obj.keys() : Object.keys(obj)\n    const length = isMap ? obj.size : keys.length\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)]\n      }\n      return simpleTokens.emptyMap\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    /** @type {TokenOrNestedTokens[]} */\n    const entries = []\n    let i = 0\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ]\n    }\n    sortMapEntries(entries, options)\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.map, length), entries]\n  }\n}\n\ntypeEncoders.Map = typeEncoders.Object\ntypeEncoders.Buffer = typeEncoders.Uint8Array\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView\n}\n\n/**\n * @param {any} obj\n * @param {EncodeOptions} [options]\n * @param {Reference} [refStack]\n * @returns {TokenOrNestedTokens}\n */\nfunction objectToTokens (obj, options = {}, refStack) {\n  const typ = is(obj)\n  const customTypeEncoder = (options && options.typeEncoders && /** @type {OptionalTypeEncoder} */ options.typeEncoders[typ]) || typeEncoders[typ]\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack)\n    if (tokens != null) {\n      return tokens\n    }\n  }\n  const typeEncoder = typeEncoders[typ]\n  if (!typeEncoder) {\n    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`)\n  }\n  return typeEncoder(obj, typ, options, refStack)\n}\n\n/*\nCBOR key sorting is a mess.\n\nThe canonicalisation recommendation from https://tools.ietf.org/html/rfc7049#section-3.9\nincludes the wording:\n\n> The keys in every map must be sorted lowest value to highest.\n> Sorting is performed on the bytes of the representation of the key\n> data items without paying attention to the 3/5 bit splitting for\n> major types.\n> ...\n>  *  If two keys have different lengths, the shorter one sorts\n      earlier;\n>  *  If two keys have the same length, the one with the lower value\n      in (byte-wise) lexical order sorts earlier.\n\n1. It is not clear what \"bytes of the representation of the key\" means: is it\n   the CBOR representation, or the binary representation of the object itself?\n   Consider the int and uint difference here.\n2. It is not clear what \"without paying attention to\" means: do we include it\n   and compare on that? Or do we omit the special prefix byte, (mostly) treating\n   the key in its plain binary representation form.\n\nThe FIDO 2.0: Client To Authenticator Protocol spec takes the original CBOR\nwording and clarifies it according to their understanding.\nhttps://fidoalliance.org/specs/fido-v2.0-rd-20170927/fido-client-to-authenticator-protocol-v2.0-rd-20170927.html#message-encoding\n\n> The keys in every map must be sorted lowest value to highest. Sorting is\n> performed on the bytes of the representation of the key data items without\n> paying attention to the 3/5 bit splitting for major types. The sorting rules\n> are:\n>  * If the major types are different, the one with the lower value in numerical\n>    order sorts earlier.\n>  * If two keys have different lengths, the shorter one sorts earlier;\n>  * If two keys have the same length, the one with the lower value in\n>    (byte-wise) lexical order sorts earlier.\n\nSome other implementations, such as borc, do a full encode then do a\nlength-first, byte-wise-second comparison:\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/encoder.js#L358\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/utils.js#L143-L151\n\nThis has the benefit of being able to easily handle arbitrary keys, including\ncomplex types (maps and arrays).\n\nWe'll opt for the FIDO approach, since it affords some efficies since we don't\nneed a full encode of each key to determine order and can defer to the types\nto determine how to most efficiently order their values (i.e. int and uint\nordering can be done on the numbers, no need for byte-wise, for example).\n\nRecommendation: stick to single key types or you'll get into trouble, and prefer\nstring keys because it's much simpler that way.\n*/\n\n/*\n(UPDATE, Dec 2020)\nhttps://tools.ietf.org/html/rfc8949 is the updated CBOR spec and clarifies some\nof the questions above with a new recommendation for sorting order being much\ncloser to what would be expected in other environments (i.e. no length-first\nweirdness).\nThis new sorting order is not yet implemented here but could be added as an\noption. \"Determinism\" (canonicity) is system dependent and it's difficult to\nchange existing systems that are built with existing expectations. So if a new\nordering is introduced here, the old needs to be kept as well with the user\nhaving the option.\n*/\n\n/**\n * @param {TokenOrNestedTokens[]} entries\n * @param {EncodeOptions} options\n */\nfunction sortMapEntries (entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter)\n  }\n}\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  // the key position ([0]) could have a single token or an array\n  // almost always it'll be a single token but complex key might get involved\n  /* c8 ignore next 2 */\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0]\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0]\n\n  // different key types\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type)\n  }\n\n  const major = keyToken1.type.major\n  // TODO: handle case where cmp === 0 but there are more keyToken e. complex type)\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2)\n  /* c8 ignore next 5 */\n  if (tcmp === 0) {\n    // duplicate key or complex type where the first token matched,\n    // i.e. a map or array and we're only comparing the opening token\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone')\n  }\n  return tcmp\n}\n\n/**\n * @param {Bl} buf\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n */\nfunction tokensToEncoded (buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options)\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options)\n  }\n}\n\n/**\n * @param {any} data\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n * @returns {Uint8Array}\n */\nfunction encodeCustom (data, encoders, options) {\n  const tokens = objectToTokens(data, options)\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens)\n    if (quickBytes) {\n      return quickBytes\n    }\n    const encoder = encoders[tokens.type.major]\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options)\n      const buf = new Bl(size)\n      encoder(buf, tokens, options)\n      /* c8 ignore next 4 */\n      // this would be a problem with encodedSize() functions\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`)\n      }\n      return asU8A(buf.chunks[0])\n    }\n  }\n  buf.reset()\n  tokensToEncoded(buf, tokens, encoders, options)\n  return buf.toBytes(true)\n}\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  return encodeCustom(data, cborEncoders, options)\n}\n\nexport { objectToTokens, encode, encodeCustom, Ref }\n","import { decodeErrPrefix } from './common.js'\nimport { Type } from './token.js'\nimport { jump, quick } from './jump.js'\n\n/**\n * @typedef {import('./token.js').Token} Token\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').DecodeTokenizer} DecodeTokenizer\n */\n\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokeniser {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  next () {\n    const byt = this.data[this._pos]\n    let token = quick[byt]\n    if (token === undefined) {\n      const decoder = jump[byt]\n      /* c8 ignore next 4 */\n      // if we're here then there's something wrong with our jump or quick lists!\n      if (!decoder) {\n        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, '0')})`)\n      }\n      const minor = byt & 31\n      token = decoder(this.data, this._pos, minor, this.options)\n    }\n    // @ts-ignore we get to assume encodedLength is set (crossing fingers slightly)\n    this._pos += token.encodedLength\n    return token\n  }\n}\n\nconst DONE = Symbol.for('DONE')\nconst BREAK = Symbol.for('BREAK')\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToArray (token, tokeniser, options) {\n  const arr = []\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options)\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length array\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)\n    }\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`)\n    }\n    arr[i] = value\n  }\n  return arr\n}\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToMap (token, tokeniser, options) {\n  const useMaps = options.useMaps === true\n  const obj = useMaps ? undefined : {}\n  const m = useMaps ? new Map() : undefined\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options)\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length map\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)\n    }\n    if (key === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`)\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`)\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      // @ts-ignore\n      if ((useMaps && m.has(key)) || (!useMaps && (key in obj))) {\n        throw new Error(`${decodeErrPrefix} found repeat map key \"${key}\"`)\n      }\n    }\n    const value = tokensToObject(tokeniser, options)\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`)\n    }\n    if (useMaps) {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      m.set(key, value)\n    } else {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      obj[key] = value\n    }\n  }\n  // @ts-ignore c'mon man\n  return useMaps ? m : obj\n}\n\n/**\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokensToObject (tokeniser, options) {\n  // should we support array as an argument?\n  // check for tokenIter[Symbol.iterator] and replace tokenIter with what that returns?\n  if (tokeniser.done()) {\n    return DONE\n  }\n\n  const token = tokeniser.next()\n\n  if (token.type === Type.break) {\n    return BREAK\n  }\n\n  if (token.type.terminal) {\n    return token.value\n  }\n\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options)\n  }\n\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options)\n  }\n\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options)\n      return options.tags[token.value](tagged)\n    }\n    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`)\n  }\n  /* c8 ignore next */\n  throw new Error('unsupported')\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`)\n  }\n  options = Object.assign({}, defaultDecodeOptions, options)\n  const tokeniser = options.tokenizer || new Tokeniser(data, options)\n  const decoded = tokensToObject(tokeniser, options)\n  if (decoded === DONE) {\n    throw new Error(`${decodeErrPrefix} did not find any content to decode`)\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${decodeErrPrefix} got unexpected break`)\n  }\n  return [decoded, data.subarray(tokeniser.pos())]\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  const [decoded, remainder] = decodeFirst(data, options)\n  if (remainder.length > 0) {\n    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`)\n  }\n  return decoded\n}\n\nexport { Tokeniser, tokensToObject, decode, decodeFirst }\n","// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import * as cborg from 'cborg'\nimport { CID } from 'multiformats/cid'\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal.\n *\n * @param {any} obj\n * @returns {cborg.Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1)\n  bytes.set(cid.bytes, 1) // prefix is 0x00, for historical reasons\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ]\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null\n}\n\nconst encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {CID}\n */\nfunction cidDecoder (bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00')\n  }\n  return CID.decode(bytes.subarray(1)) // ignore leading 0x00\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\ndecodeOptions.tags[CID_CBOR_TAG] = cidDecoder\n\nexport const name = 'dag-cbor'\nexport const code = 0x71\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborg.encode(node, encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => cborg.decode(data, decodeOptions)\n"],"names":["typeofs","objectTypeNames","is","value","undefined","typeOf","includes","Array","isArray","isBuffer","constructor","call","objectType","getObjectType","objectTypeName","Object","prototype","toString","slice","Type","major","name","terminal","this","majorEncoded","compare","typ","uint","negint","bytes","string","array","map","tag","float","false","true","null","break","Token","type","encodedLength","encodedBytes","byteValue","useBuffer","globalThis","process","browser","Buffer","textDecoder","TextDecoder","textEncoder","TextEncoder","buf","asU8A","Uint8Array","buffer","byteOffset","byteLength","from","start","end","subarray","utf8Slice","decode","fromString","length","utf8ToBytes","encode","fromArray","arr","concat","chunks","c","out","off","b","set","alloc","size","allocUnsafe","str","p","i","charCodeAt","offset","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","push","decodeCodePointsArray","codePoints","len","MAX_ARGUMENTS_LENGTH","String","fromCharCode","apply","Bl","chunkSize","cursor","maxCursor","_initReuseChunk","reset","topChunk","chunkPos","toBytes","byts","chunk","decodeErrPrefix","encodeErrPrefix","uintMinorPrefixBytes","assertEnoughData","data","pos","need","Error","uintBoundaries","BigInt","readUint8","options","strict","readUint16","readUint32","readUint64","hi","lo","Number","MAX_SAFE_INTEGER","allowBigInt","encodeUint","token","encodeUintValue","nuint","buint","encodedSize","compareTokens","tok1","tok2","neg1b","pos1b","encodeNegint","unsigned","toToken","prefix","decodeBytesCompact","minor","_options","tokenBytes","encodeBytes","totLength","tok","retainStringBytes","decodeStringCompact","compareBytes","b1","b2","encodeString","_data","_pos","decodeArrayCompact","encodeArray","decodeMapCompact","encodeMap","decodeTagCompact","encodeTag","MINOR_FALSE","MINOR_TRUE","MINOR_NULL","MINOR_UNDEFINED","createToken","allowNaN","isNaN","allowInfinity","Infinity","encodeFloat","decoded","success","float64","encodeFloat16","readFloat16","ui8a","encodeFloat32","readFloat32","encodeFloat64","inp","dataView","setFloat64","readFloat64","ArrayBuffer","DataView","setUint16","setFloat32","valu32","getUint32","exponent","mantissa","logicalExponent","half","NaN","exp","mant","val","getFloat32","getFloat64","invalidMinor","errorer","msg","jump","decodeUint8","_minor","decodeUint16","decodeUint32","decodeUint64","decodeNegint8","decodeNegint16","decodeNegint32","decodeNegint64","int","MIN_SAFE_INTEGER","decodeBytes8","decodeBytes16","decodeBytes32","decodeBytes64","l","decodeString8","decodeString16","decodeString32","decodeString64","decodeArray8","decodeArray16","decodeArray32","decodeArray64","decodeArrayIndefinite","allowIndefinite","decodeMap8","decodeMap16","decodeMap32","decodeMap64","decodeMapIndefinite","decodeTag8","decodeTag16","decodeTag32","decodeTag64","decodeUndefined","allowUndefined","coerceUndefinedToNull","decodeFloat16","decodeFloat32","decodeFloat64","decodeBreak","quick","defaultEncodeOptions","mapSorter","e1","e2","keyToken1","keyToken2","tcmp","cborEncoders","console","warn","quickEncodeToken","makeCborEncoders","encoders","Ref","obj","parent","createCheck","stack","simpleTokens","emptyArray","emptyMap","typeEncoders","number","_typ","_refStack","isInteger","isSafeInteger","bigint","boolean","_obj","refStack","addBreakTokens","entries","e","objectToTokens","isMap","keys","key","get","sortMapEntries","sort","Map","split","customTypeEncoder","tokens","typeEncoder","tokensToEncoded","encodeCustom","quickBytes","encoder","defaultDecodeOptions","Tokeniser","done","next","byt","decoder","padStart","DONE","Symbol","for","BREAK","tokensToObject","tokeniser","tokenToArray","tokenToMap","useMaps","m","rejectDuplicateMapKeys","has","tags","tagged","remainder","decodeFirst","assign","tokenizer","src","base","ALPHABET","TypeError","BASE_MAP","j","x","charAt","xc","BASE","LEADER","FACTOR","Math","log","iFACTOR","decodeUnsafe","source","psz","zeroes","b256","carry","it3","it4","vch","isView","pbegin","pend","b58","it1","it2","repeat","coerce","o","Encoder","baseEncode","Decoder","baseDecode","codePointAt","prefixCodePoint","text","JSON","stringify","or","ComposedDecoder","decoders","input","RangeError","left","right","Codec","baseX","alphabet","rfc4648","bitsPerChar","pad","mask","bits","codes","written","SyntaxError","base32","base58btc","encode_1","num","oldOffset","INT","MSB","MSBALL","pow","read","shift","counter","REST$1","MSB$1","N1","N2","N3","N4","N5","N6","N7","N8","N9","encodingLength","encodeTo","target","Digest","code","digest","format","link","version","toStringV0","baseCache","toStringV1","cache","WeakMap","cid","CID","multihash","asCID","toV0","DAG_PB_CODE","SHA_256_CODE","createV0","toV1","sizeOffset","digestOffset","createV1","equals","other","self","unknown","a","aa","bb","ii","toJSON","toStringTag","encodeCID","cidSymbol","create","specs","inspectBytes","prefixSize","multihashSize","multihashBytes","digestBytes","digestSize","multihashCode","codec","initialBytes","parse","parseCIDtoBytes","codeOffset","hashOffset","encodeOptions","cidEncoder","undefinedEncoder","numberEncoder","decodeOptions","cidDecoder","node"],"sourceRoot":""}